   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"mcg.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.comm	drs_val,1,1
  18              		.comm	dmx32_val,1,1
  19              		.global	__aeabi_idiv
  20              		.section	.text.pll_init,"ax",%progbits
  21              		.align	2
  22              		.global	pll_init
  23              		.code	16
  24              		.thumb_func
  26              	pll_init:
  27              	.LFB0:
  28              		.file 1 "../Sources/mcg.c"
   1:../Sources/mcg.c **** /*
   2:../Sources/mcg.c ****  * File:    mcg.c
   3:../Sources/mcg.c ****  *
   4:../Sources/mcg.c ****  * MCG drivers for Freescale Kinetis L - series devices
   5:../Sources/mcg.c ****  * Notes:
   6:../Sources/mcg.c ****  * Assumes the MCG mode is in the default FEI mode out of reset
   7:../Sources/mcg.c ****  */
   8:../Sources/mcg.c **** 
   9:../Sources/mcg.c **** #include "derivative.h"
  10:../Sources/mcg.c **** #include "mcg.h"
  11:../Sources/mcg.c **** 
  12:../Sources/mcg.c **** 
  13:../Sources/mcg.c **** // global variables
  14:../Sources/mcg.c **** extern int core_clk_khz;
  15:../Sources/mcg.c **** 
  16:../Sources/mcg.c **** 
  17:../Sources/mcg.c **** char drs_val, dmx32_val;
  18:../Sources/mcg.c **** 
  19:../Sources/mcg.c **** 
  20:../Sources/mcg.c **** 
  21:../Sources/mcg.c **** // prototypes
  22:../Sources/mcg.c **** void rtc_as_refclk(void);
  23:../Sources/mcg.c **** int fee_fei(int slow_irc_freq);
  24:../Sources/mcg.c **** int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  25:../Sources/mcg.c **** int fbe_fei(int slow_irc_freq);
  26:../Sources/mcg.c **** int fei_fbi(int irc_freq, unsigned char irc_select);
  27:../Sources/mcg.c **** int fbi_fei(int slow_irc_freq);
  28:../Sources/mcg.c **** int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  29:../Sources/mcg.c **** int pbe_pee(int crystal_val);
  30:../Sources/mcg.c **** int pee_pbe(int crystal_val);
  31:../Sources/mcg.c **** int pbe_fbe(int crystal_val);
  32:../Sources/mcg.c **** int fbe_fbi(int irc_freq, unsigned char irc_select);
  33:../Sources/mcg.c **** int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  34:../Sources/mcg.c **** int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  35:../Sources/mcg.c **** int fbe_fee(int crystal_val);
  36:../Sources/mcg.c **** int fee_fbe(int crystal_val);
  37:../Sources/mcg.c **** int pbe_blpe(int crystal_val);
  38:../Sources/mcg.c **** int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  39:../Sources/mcg.c **** int blpe_fbe(int crystal_val);
  40:../Sources/mcg.c **** int fbi_blpi(int irc_freq, unsigned char irc_select);
  41:../Sources/mcg.c **** int blpi_fbi(int irc_freq, unsigned char irc_select);
  42:../Sources/mcg.c **** int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val);
  43:../Sources/mcg.c **** int fee_fbi(int irc_freq, unsigned char irc_select);
  44:../Sources/mcg.c **** int fbe_blpe(int crystal_val);
  45:../Sources/mcg.c **** 
  46:../Sources/mcg.c **** 
  47:../Sources/mcg.c **** int new_pll_freq(int crystal_val, signed char prdiv_val, signed char vdiv_val);
  48:../Sources/mcg.c **** 
  49:../Sources/mcg.c **** int fll_freq(int fll_ref);
  50:../Sources/mcg.c **** unsigned char what_mcg_mode(void);
  51:../Sources/mcg.c **** unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq);
  52:../Sources/mcg.c **** void clk_monitor_0(unsigned char en_dis);
  53:../Sources/mcg.c **** unsigned char chk_for_resistor(void);
  54:../Sources/mcg.c **** 
  55:../Sources/mcg.c **** 
  56:../Sources/mcg.c **** 
  57:../Sources/mcg.c **** /*********************************************************************************************/
  58:../Sources/mcg.c **** /* Functon name : pll_init
  59:../Sources/mcg.c ****  *
  60:../Sources/mcg.c ****  * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
  61:../Sources/mcg.c ****  *
  62:../Sources/mcg.c ****  * This function initializess PLL0. Either OSC0 is selected for the
  63:../Sources/mcg.c ****  * reference clock source. The oscillators can be configured to use a crystal or take in an
  64:../Sources/mcg.c ****  * external square wave clock.
  65:../Sources/mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
  66:../Sources/mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
  67:../Sources/mcg.c ****  * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
  68:../Sources/mcg.c ****  * All parameters must be provided, for example crystal_val must be provided even if the
  69:../Sources/mcg.c ****  * oscillator associated with that parameter is already initialized.
  70:../Sources/mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
  71:../Sources/mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
  72:../Sources/mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
  73:../Sources/mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
  74:../Sources/mcg.c ****  *
  75:../Sources/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
  76:../Sources/mcg.c ****  *                           wave clock source
  77:../Sources/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
  78:../Sources/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
  79:../Sources/mcg.c ****  *                           external clock is used.
  80:../Sources/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
  81:../Sources/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
  82:../Sources/mcg.c ****  *                           PLL reference clock frequency
  83:../Sources/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
  84:../Sources/mcg.c ****  *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
  85:../Sources/mcg.c ****  *                              to provide the MCGOUT clock for the system.
  86:../Sources/mcg.c ****  *
  87:../Sources/mcg.c ****  * Return value : PLL frequency (Hz) or error code
  88:../Sources/mcg.c ****  */
  89:../Sources/mcg.c **** 
  90:../Sources/mcg.c **** int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val
  91:../Sources/mcg.c **** {
  29              		.loc 1 91 0
  30              		.cfi_startproc
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 86B0     		sub	sp, sp, #24
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 32
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
  43 0008 081C     		mov	r0, r1
  44 000a 111C     		mov	r1, r2
  45 000c 1A1C     		mov	r2, r3
  46 000e FB1C     		add	r3, r7, #3
  47 0010 1870     		strb	r0, [r3]
  48 0012 BB1C     		add	r3, r7, #2
  49 0014 1970     		strb	r1, [r3]
  50 0016 7B1C     		add	r3, r7, #1
  51 0018 1A70     		strb	r2, [r3]
  92:../Sources/mcg.c ****   unsigned char frdiv_val;
  93:../Sources/mcg.c ****   unsigned char temp_reg;
  94:../Sources/mcg.c ****   unsigned char prdiv, vdiv;
  95:../Sources/mcg.c ****   short i;
  96:../Sources/mcg.c ****   int ref_freq;
  97:../Sources/mcg.c ****   int pll_freq;
  98:../Sources/mcg.c **** 
  99:../Sources/mcg.c ****   // check if in FEI mode
 100:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
  52              		.loc 1 100 0
  53 001a C24B     		ldr	r3, .L61
  54 001c 9B79     		ldrb	r3, [r3, #6]
  55 001e DBB2     		uxtb	r3, r3
  56 0020 1A1C     		mov	r2, r3
  57 0022 0C23     		mov	r3, #12
  58 0024 1340     		and	r3, r2
  59 0026 9B08     		lsr	r3, r3, #2
  60 0028 0DD1     		bne	.L2
 101:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
  61              		.loc 1 101 0 discriminator 1
  62 002a BE4B     		ldr	r3, .L61
  63 002c 9B79     		ldrb	r3, [r3, #6]
  64 002e DBB2     		uxtb	r3, r3
  65 0030 1A1C     		mov	r2, r3
  66 0032 1023     		mov	r3, #16
  67 0034 1340     		and	r3, r2
 100:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
  68              		.loc 1 100 0 discriminator 1
  69 0036 06D0     		beq	.L2
 102:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
  70              		.loc 1 102 0 discriminator 1
  71 0038 BA4B     		ldr	r3, .L61
  72 003a 9B79     		ldrb	r3, [r3, #6]
  73 003c DBB2     		uxtb	r3, r3
  74 003e 1A1C     		mov	r2, r3
  75 0040 2023     		mov	r3, #32
  76 0042 1340     		and	r3, r2
 100:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
  77              		.loc 1 100 0 discriminator 1
  78 0044 01D0     		beq	.L3
  79              	.L2:
 103:../Sources/mcg.c ****   {
 104:../Sources/mcg.c ****     return 0x1;                                                     // return error code
  80              		.loc 1 104 0
  81 0046 0123     		mov	r3, #1
  82 0048 73E2     		b	.L4
  83              	.L3:
 105:../Sources/mcg.c ****   }
 106:../Sources/mcg.c **** 
 107:../Sources/mcg.c ****   // check external frequency is less than the maximum frequency
 108:../Sources/mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
  84              		.loc 1 108 0
  85 004a 7A68     		ldr	r2, [r7, #4]
  86 004c B64B     		ldr	r3, .L61+4
  87 004e 9A42     		cmp	r2, r3
  88 0050 01DD     		ble	.L5
  89              		.loc 1 108 0 is_stmt 0 discriminator 1
  90 0052 2123     		mov	r3, #33
  91 0054 6DE2     		b	.L4
  92              	.L5:
 109:../Sources/mcg.c **** 
 110:../Sources/mcg.c ****   // check crystal frequency is within spec. if crystal osc is being used as PLL ref
 111:../Sources/mcg.c ****   if (erefs_val)
  93              		.loc 1 111 0 is_stmt 1
  94 0056 BB1C     		add	r3, r7, #2
  95 0058 1B78     		ldrb	r3, [r3]
  96 005a 002B     		cmp	r3, #0
  97 005c 09D0     		beq	.L6
 112:../Sources/mcg.c ****   {
 113:../Sources/mcg.c ****     if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of t
  98              		.loc 1 113 0
  99 005e 7A68     		ldr	r2, [r7, #4]
 100 0060 B24B     		ldr	r3, .L61+8
 101 0062 9A42     		cmp	r2, r3
 102 0064 03DD     		ble	.L7
 103              		.loc 1 113 0 is_stmt 0 discriminator 2
 104 0066 7A68     		ldr	r2, [r7, #4]
 105 0068 B14B     		ldr	r3, .L61+12
 106 006a 9A42     		cmp	r2, r3
 107 006c 01DD     		ble	.L6
 108              	.L7:
 109              		.loc 1 113 0 discriminator 1
 110 006e 2223     		mov	r3, #34
 111 0070 5FE2     		b	.L4
 112              	.L6:
 114:../Sources/mcg.c ****   }
 115:../Sources/mcg.c **** 
 116:../Sources/mcg.c ****   // make sure HGO will never be greater than 1. Could return an error instead if desired.
 117:../Sources/mcg.c ****   if (hgo_val > 0)
 113              		.loc 1 117 0 is_stmt 1
 114 0072 FB1C     		add	r3, r7, #3
 115 0074 1B78     		ldrb	r3, [r3]
 116 0076 002B     		cmp	r3, #0
 117 0078 02D0     		beq	.L8
 118:../Sources/mcg.c ****   {
 119:../Sources/mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 118              		.loc 1 119 0
 119 007a FB1C     		add	r3, r7, #3
 120 007c 0122     		mov	r2, #1
 121 007e 1A70     		strb	r2, [r3]
 122              	.L8:
 120:../Sources/mcg.c ****   }
 121:../Sources/mcg.c **** 
 122:../Sources/mcg.c ****   // Check PLL divider settings are within spec.
 123:../Sources/mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 123              		.loc 1 123 0
 124 0080 7B1C     		add	r3, r7, #1
 125 0082 1B78     		ldrb	r3, [r3]
 126 0084 5BB2     		sxtb	r3, r3
 127 0086 002B     		cmp	r3, #0
 128 0088 04DD     		ble	.L9
 129              		.loc 1 123 0 is_stmt 0 discriminator 2
 130 008a 7B1C     		add	r3, r7, #1
 131 008c 1B78     		ldrb	r3, [r3]
 132 008e 5BB2     		sxtb	r3, r3
 133 0090 192B     		cmp	r3, #25
 134 0092 01DD     		ble	.L10
 135              	.L9:
 136              		.loc 1 123 0 discriminator 1
 137 0094 4123     		mov	r3, #65
 138 0096 4CE2     		b	.L4
 139              	.L10:
 124:../Sources/mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 140              		.loc 1 124 0 is_stmt 1
 141 0098 3B1C     		mov	r3, r7
 142 009a 2033     		add	r3, r3, #32
 143 009c 1B78     		ldrb	r3, [r3]
 144 009e 5BB2     		sxtb	r3, r3
 145 00a0 172B     		cmp	r3, #23
 146 00a2 05DD     		ble	.L11
 147              		.loc 1 124 0 is_stmt 0 discriminator 2
 148 00a4 3B1C     		mov	r3, r7
 149 00a6 2033     		add	r3, r3, #32
 150 00a8 1B78     		ldrb	r3, [r3]
 151 00aa 5BB2     		sxtb	r3, r3
 152 00ac 322B     		cmp	r3, #50
 153 00ae 01DD     		ble	.L12
 154              	.L11:
 155              		.loc 1 124 0 discriminator 1
 156 00b0 4223     		mov	r3, #66
 157 00b2 3EE2     		b	.L4
 158              	.L12:
 125:../Sources/mcg.c **** 
 126:../Sources/mcg.c ****   // Check PLL reference clock frequency is within spec.
 127:../Sources/mcg.c ****   ref_freq = crystal_val / prdiv_val;
 159              		.loc 1 127 0 is_stmt 1
 160 00b4 7B1C     		add	r3, r7, #1
 161 00b6 1B78     		ldrb	r3, [r3]
 162 00b8 5BB2     		sxtb	r3, r3
 163 00ba 7868     		ldr	r0, [r7, #4]
 164 00bc 191C     		mov	r1, r3
 165 00be FFF7FEFF 		bl	__aeabi_idiv
 166 00c2 031C     		mov	r3, r0
 167 00c4 3B61     		str	r3, [r7, #16]
 128:../Sources/mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 168              		.loc 1 128 0
 169 00c6 3A69     		ldr	r2, [r7, #16]
 170 00c8 9A4B     		ldr	r3, .L61+16
 171 00ca 9A42     		cmp	r2, r3
 172 00cc 03DD     		ble	.L13
 173              		.loc 1 128 0 is_stmt 0 discriminator 2
 174 00ce 3A69     		ldr	r2, [r7, #16]
 175 00d0 994B     		ldr	r3, .L61+20
 176 00d2 9A42     		cmp	r2, r3
 177 00d4 01DD     		ble	.L14
 178              	.L13:
 179              		.loc 1 128 0 discriminator 1
 180 00d6 4323     		mov	r3, #67
 181 00d8 2BE2     		b	.L4
 182              	.L14:
 129:../Sources/mcg.c **** 
 130:../Sources/mcg.c ****   // Check PLL output frequency is within spec.
 131:../Sources/mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 183              		.loc 1 131 0 is_stmt 1
 184 00da 7B1C     		add	r3, r7, #1
 185 00dc 1B78     		ldrb	r3, [r3]
 186 00de 5BB2     		sxtb	r3, r3
 187 00e0 7868     		ldr	r0, [r7, #4]
 188 00e2 191C     		mov	r1, r3
 189 00e4 FFF7FEFF 		bl	__aeabi_idiv
 190 00e8 031C     		mov	r3, r0
 191 00ea 3A1C     		mov	r2, r7
 192 00ec 2032     		add	r2, r2, #32
 193 00ee 1278     		ldrb	r2, [r2]
 194 00f0 52B2     		sxtb	r2, r2
 195 00f2 5343     		mul	r3, r2
 196 00f4 FB60     		str	r3, [r7, #12]
 132:../Sources/mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 197              		.loc 1 132 0
 198 00f6 FA68     		ldr	r2, [r7, #12]
 199 00f8 904B     		ldr	r3, .L61+24
 200 00fa 9A42     		cmp	r2, r3
 201 00fc 03DD     		ble	.L15
 202              		.loc 1 132 0 is_stmt 0 discriminator 2
 203 00fe FA68     		ldr	r2, [r7, #12]
 204 0100 8F4B     		ldr	r3, .L61+28
 205 0102 9A42     		cmp	r2, r3
 206 0104 01DD     		ble	.L16
 207              	.L15:
 208              		.loc 1 132 0 discriminator 1
 209 0106 4523     		mov	r3, #69
 210 0108 13E2     		b	.L4
 211              	.L16:
 133:../Sources/mcg.c **** 
 134:../Sources/mcg.c ****   // configure the MCG_C2 register
 135:../Sources/mcg.c ****   // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the
 136:../Sources/mcg.c ****   // it still needs to be set correctly even if the oscillator is not being used
 137:../Sources/mcg.c ****       
 138:../Sources/mcg.c ****   temp_reg = MCG_C2;
 212              		.loc 1 138 0 is_stmt 1
 213 010a 864A     		ldr	r2, .L61
 214 010c 3B1C     		mov	r3, r7
 215 010e 1633     		add	r3, r3, #22
 216 0110 5278     		ldrb	r2, [r2, #1]
 217 0112 1A70     		strb	r2, [r3]
 139:../Sources/mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 218              		.loc 1 139 0
 219 0114 3B1C     		mov	r3, r7
 220 0116 1633     		add	r3, r3, #22
 221 0118 3A1C     		mov	r2, r7
 222 011a 1632     		add	r2, r2, #22
 223 011c 1278     		ldrb	r2, [r2]
 224 011e 3C21     		mov	r1, #60
 225 0120 8A43     		bic	r2, r1
 226 0122 1A70     		strb	r2, [r3]
 140:../Sources/mcg.c ****     
 141:../Sources/mcg.c ****   if (crystal_val <= 8000000)
 227              		.loc 1 141 0
 228 0124 7A68     		ldr	r2, [r7, #4]
 229 0126 874B     		ldr	r3, .L61+32
 230 0128 9A42     		cmp	r2, r3
 231 012a 14DC     		bgt	.L17
 142:../Sources/mcg.c ****   {
 143:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 232              		.loc 1 143 0
 233 012c FB1C     		add	r3, r7, #3
 234 012e 1B78     		ldrb	r3, [r3]
 235 0130 DB00     		lsl	r3, r3, #3
 236 0132 DAB2     		uxtb	r2, r3
 237 0134 BB1C     		add	r3, r7, #2
 238 0136 1B78     		ldrb	r3, [r3]
 239 0138 9B00     		lsl	r3, r3, #2
 240 013a DBB2     		uxtb	r3, r3
 241 013c 1343     		orr	r3, r2
 242 013e DAB2     		uxtb	r2, r3
 243 0140 3B1C     		mov	r3, r7
 244 0142 1633     		add	r3, r3, #22
 245 0144 1B78     		ldrb	r3, [r3]
 246 0146 1343     		orr	r3, r2
 247 0148 DAB2     		uxtb	r2, r3
 248 014a 3B1C     		mov	r3, r7
 249 014c 1633     		add	r3, r3, #22
 250 014e 1021     		mov	r1, #16
 251 0150 0A43     		orr	r2, r1
 252 0152 1A70     		strb	r2, [r3]
 253 0154 13E0     		b	.L18
 254              	.L17:
 144:../Sources/mcg.c ****   }
 145:../Sources/mcg.c ****   else
 146:../Sources/mcg.c ****   {
 147:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 255              		.loc 1 147 0
 256 0156 FB1C     		add	r3, r7, #3
 257 0158 1B78     		ldrb	r3, [r3]
 258 015a DB00     		lsl	r3, r3, #3
 259 015c DAB2     		uxtb	r2, r3
 260 015e BB1C     		add	r3, r7, #2
 261 0160 1B78     		ldrb	r3, [r3]
 262 0162 9B00     		lsl	r3, r3, #2
 263 0164 DBB2     		uxtb	r3, r3
 264 0166 1343     		orr	r3, r2
 265 0168 DAB2     		uxtb	r2, r3
 266 016a 3B1C     		mov	r3, r7
 267 016c 1633     		add	r3, r3, #22
 268 016e 1B78     		ldrb	r3, [r3]
 269 0170 1343     		orr	r3, r2
 270 0172 DAB2     		uxtb	r2, r3
 271 0174 3B1C     		mov	r3, r7
 272 0176 1633     		add	r3, r3, #22
 273 0178 2021     		mov	r1, #32
 274 017a 0A43     		orr	r2, r1
 275 017c 1A70     		strb	r2, [r3]
 276              	.L18:
 148:../Sources/mcg.c ****   }
 149:../Sources/mcg.c ****   MCG_C2 = temp_reg;
 277              		.loc 1 149 0
 278 017e 694B     		ldr	r3, .L61
 279 0180 3A1C     		mov	r2, r7
 280 0182 1632     		add	r2, r2, #22
 281 0184 1278     		ldrb	r2, [r2]
 282 0186 5A70     		strb	r2, [r3, #1]
 150:../Sources/mcg.c ****   
 151:../Sources/mcg.c ****   // determine FRDIV based on reference clock frequency
 152:../Sources/mcg.c ****   // since the external frequency has already been checked only the maximum frequency for each FRDI
 153:../Sources/mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 283              		.loc 1 153 0
 284 0188 7A68     		ldr	r2, [r7, #4]
 285 018a 6F4B     		ldr	r3, .L61+36
 286 018c 9A42     		cmp	r2, r3
 287 018e 04DC     		bgt	.L19
 288              		.loc 1 153 0 is_stmt 0 discriminator 1
 289 0190 3B1C     		mov	r3, r7
 290 0192 1733     		add	r3, r3, #23
 291 0194 0022     		mov	r2, #0
 292 0196 1A70     		strb	r2, [r3]
 293 0198 27E0     		b	.L20
 294              	.L19:
 154:../Sources/mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 295              		.loc 1 154 0 is_stmt 1
 296 019a 7A68     		ldr	r2, [r7, #4]
 297 019c 6B4B     		ldr	r3, .L61+40
 298 019e 9A42     		cmp	r2, r3
 299 01a0 04DC     		bgt	.L21
 300              		.loc 1 154 0 is_stmt 0 discriminator 1
 301 01a2 3B1C     		mov	r3, r7
 302 01a4 1733     		add	r3, r3, #23
 303 01a6 0122     		mov	r2, #1
 304 01a8 1A70     		strb	r2, [r3]
 305 01aa 1EE0     		b	.L20
 306              	.L21:
 155:../Sources/mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 307              		.loc 1 155 0 is_stmt 1
 308 01ac 7A68     		ldr	r2, [r7, #4]
 309 01ae 684B     		ldr	r3, .L61+44
 310 01b0 9A42     		cmp	r2, r3
 311 01b2 04DC     		bgt	.L22
 312              		.loc 1 155 0 is_stmt 0 discriminator 1
 313 01b4 3B1C     		mov	r3, r7
 314 01b6 1733     		add	r3, r3, #23
 315 01b8 0222     		mov	r2, #2
 316 01ba 1A70     		strb	r2, [r3]
 317 01bc 15E0     		b	.L20
 318              	.L22:
 156:../Sources/mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 319              		.loc 1 156 0 is_stmt 1
 320 01be 7A68     		ldr	r2, [r7, #4]
 321 01c0 644B     		ldr	r3, .L61+48
 322 01c2 9A42     		cmp	r2, r3
 323 01c4 04DC     		bgt	.L23
 324              		.loc 1 156 0 is_stmt 0 discriminator 1
 325 01c6 3B1C     		mov	r3, r7
 326 01c8 1733     		add	r3, r3, #23
 327 01ca 0322     		mov	r2, #3
 328 01cc 1A70     		strb	r2, [r3]
 329 01ce 0CE0     		b	.L20
 330              	.L23:
 157:../Sources/mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 331              		.loc 1 157 0 is_stmt 1
 332 01d0 7A68     		ldr	r2, [r7, #4]
 333 01d2 614B     		ldr	r3, .L61+52
 334 01d4 9A42     		cmp	r2, r3
 335 01d6 04DC     		bgt	.L24
 336              		.loc 1 157 0 is_stmt 0 discriminator 1
 337 01d8 3B1C     		mov	r3, r7
 338 01da 1733     		add	r3, r3, #23
 339 01dc 0422     		mov	r2, #4
 340 01de 1A70     		strb	r2, [r3]
 341 01e0 03E0     		b	.L20
 342              	.L24:
 158:../Sources/mcg.c ****   else {frdiv_val = 5;}
 343              		.loc 1 158 0 is_stmt 1
 344 01e2 3B1C     		mov	r3, r7
 345 01e4 1733     		add	r3, r3, #23
 346 01e6 0522     		mov	r2, #5
 347 01e8 1A70     		strb	r2, [r3]
 348              	.L20:
 159:../Sources/mcg.c **** 
 160:../Sources/mcg.c ****   // Select external oscillator and Reference Divider and clear IREFS to start ext osc
 161:../Sources/mcg.c ****   // If IRCLK is required it must be enabled outside of this driver, existing state will be maintai
 162:../Sources/mcg.c ****   // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 163:../Sources/mcg.c ****   temp_reg = MCG_C1;
 349              		.loc 1 163 0
 350 01ea 4E4A     		ldr	r2, .L61
 351 01ec 3B1C     		mov	r3, r7
 352 01ee 1633     		add	r3, r3, #22
 353 01f0 1278     		ldrb	r2, [r2]
 354 01f2 1A70     		strb	r2, [r3]
 164:../Sources/mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 355              		.loc 1 164 0
 356 01f4 3B1C     		mov	r3, r7
 357 01f6 1633     		add	r3, r3, #22
 358 01f8 3A1C     		mov	r2, r7
 359 01fa 1632     		add	r2, r2, #22
 360 01fc 1178     		ldrb	r1, [r2]
 361 01fe 0322     		mov	r2, #3
 362 0200 0A40     		and	r2, r1
 363 0202 1A70     		strb	r2, [r3]
 165:../Sources/mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 364              		.loc 1 165 0
 365 0204 3B1C     		mov	r3, r7
 366 0206 1733     		add	r3, r3, #23
 367 0208 1B78     		ldrb	r3, [r3]
 368 020a DB00     		lsl	r3, r3, #3
 369 020c DAB2     		uxtb	r2, r3
 370 020e 3823     		mov	r3, #56
 371 0210 1340     		and	r3, r2
 372 0212 DAB2     		uxtb	r2, r3
 373 0214 3B1C     		mov	r3, r7
 374 0216 1633     		add	r3, r3, #22
 375 0218 1B78     		ldrb	r3, [r3]
 376 021a 1343     		orr	r3, r2
 377 021c DAB2     		uxtb	r2, r3
 378 021e 3B1C     		mov	r3, r7
 379 0220 1633     		add	r3, r3, #22
 380 0222 8021     		mov	r1, #128
 381 0224 4942     		neg	r1, r1
 382 0226 0A43     		orr	r2, r1
 383 0228 1A70     		strb	r2, [r3]
 166:../Sources/mcg.c ****   MCG_C1 = temp_reg;
 384              		.loc 1 166 0
 385 022a 3E4B     		ldr	r3, .L61
 386 022c 3A1C     		mov	r2, r7
 387 022e 1632     		add	r2, r2, #22
 388 0230 1278     		ldrb	r2, [r2]
 389 0232 1A70     		strb	r2, [r3]
 167:../Sources/mcg.c **** 
 168:../Sources/mcg.c ****   // if the external oscillator is used need to wait for OSCINIT to set
 169:../Sources/mcg.c ****   if (erefs_val)
 390              		.loc 1 169 0
 391 0234 BB1C     		add	r3, r7, #2
 392 0236 1B78     		ldrb	r3, [r3]
 393 0238 002B     		cmp	r3, #0
 394 023a 24D0     		beq	.L25
 170:../Sources/mcg.c ****   {
 171:../Sources/mcg.c ****     for (i = 0 ; i < 20000 ; i++)
 395              		.loc 1 171 0
 396 023c 3B1C     		mov	r3, r7
 397 023e 1433     		add	r3, r3, #20
 398 0240 0022     		mov	r2, #0
 399 0242 1A80     		strh	r2, [r3]
 400 0244 0DE0     		b	.L26
 401              	.L29:
 172:../Sources/mcg.c ****     {
 173:../Sources/mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 402              		.loc 1 173 0
 403 0246 374B     		ldr	r3, .L61
 404 0248 9B79     		ldrb	r3, [r3, #6]
 405 024a DBB2     		uxtb	r3, r3
 406 024c 1A1C     		mov	r2, r3
 407 024e 0223     		mov	r3, #2
 408 0250 1340     		and	r3, r2
 409 0252 0ED1     		bne	.L55
 410              	.L27:
 171:../Sources/mcg.c ****     for (i = 0 ; i < 20000 ; i++)
 411              		.loc 1 171 0
 412 0254 3B1C     		mov	r3, r7
 413 0256 1433     		add	r3, r3, #20
 414 0258 3A1C     		mov	r2, r7
 415 025a 1432     		add	r2, r2, #20
 416 025c 1288     		ldrh	r2, [r2]
 417 025e 0132     		add	r2, r2, #1
 418 0260 1A80     		strh	r2, [r3]
 419              	.L26:
 171:../Sources/mcg.c ****     for (i = 0 ; i < 20000 ; i++)
 420              		.loc 1 171 0 is_stmt 0 discriminator 1
 421 0262 3B1C     		mov	r3, r7
 422 0264 1433     		add	r3, r3, #20
 423 0266 0021     		mov	r1, #0
 424 0268 5A5E     		ldrsh	r2, [r3, r1]
 425 026a 3C4B     		ldr	r3, .L61+56
 426 026c 9A42     		cmp	r2, r3
 427 026e EADD     		ble	.L29
 428 0270 00E0     		b	.L28
 429              	.L55:
 430              		.loc 1 173 0 is_stmt 1
 431 0272 C046     		mov	r8, r8
 432              	.L28:
 174:../Sources/mcg.c ****     }
 175:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error
 433              		.loc 1 175 0
 434 0274 2B4B     		ldr	r3, .L61
 435 0276 9B79     		ldrb	r3, [r3, #6]
 436 0278 DBB2     		uxtb	r3, r3
 437 027a 1A1C     		mov	r2, r3
 438 027c 0223     		mov	r3, #2
 439 027e 1340     		and	r3, r2
 440 0280 01D1     		bne	.L25
 441              		.loc 1 175 0 is_stmt 0 discriminator 1
 442 0282 2323     		mov	r3, #35
 443 0284 55E1     		b	.L4
 444              	.L25:
 176:../Sources/mcg.c ****   }
 177:../Sources/mcg.c **** 
 178:../Sources/mcg.c ****   // wait for Reference clock Status bit to clear
 179:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 445              		.loc 1 179 0 is_stmt 1
 446 0286 3B1C     		mov	r3, r7
 447 0288 1433     		add	r3, r3, #20
 448 028a 0022     		mov	r2, #0
 449 028c 1A80     		strh	r2, [r3]
 450 028e 0DE0     		b	.L30
 451              	.L33:
 180:../Sources/mcg.c ****   {
 181:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 452              		.loc 1 181 0
 453 0290 244B     		ldr	r3, .L61
 454 0292 9B79     		ldrb	r3, [r3, #6]
 455 0294 DBB2     		uxtb	r3, r3
 456 0296 1A1C     		mov	r2, r3
 457 0298 1023     		mov	r3, #16
 458 029a 1340     		and	r3, r2
 459 029c 0ED0     		beq	.L56
 460              	.L31:
 179:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 461              		.loc 1 179 0
 462 029e 3B1C     		mov	r3, r7
 463 02a0 1433     		add	r3, r3, #20
 464 02a2 3A1C     		mov	r2, r7
 465 02a4 1432     		add	r2, r2, #20
 466 02a6 1288     		ldrh	r2, [r2]
 467 02a8 0132     		add	r2, r2, #1
 468 02aa 1A80     		strh	r2, [r3]
 469              	.L30:
 179:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 470              		.loc 1 179 0 is_stmt 0 discriminator 1
 471 02ac 3B1C     		mov	r3, r7
 472 02ae 1433     		add	r3, r3, #20
 473 02b0 0021     		mov	r1, #0
 474 02b2 5A5E     		ldrsh	r2, [r3, r1]
 475 02b4 2A4B     		ldr	r3, .L61+60
 476 02b6 9A42     		cmp	r2, r3
 477 02b8 EADD     		ble	.L33
 478 02ba 00E0     		b	.L32
 479              	.L56:
 480              		.loc 1 181 0 is_stmt 1
 481 02bc C046     		mov	r8, r8
 482              	.L32:
 182:../Sources/mcg.c ****   }
 183:../Sources/mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 483              		.loc 1 183 0
 484 02be 194B     		ldr	r3, .L61
 485 02c0 9B79     		ldrb	r3, [r3, #6]
 486 02c2 DBB2     		uxtb	r3, r3
 487 02c4 1A1C     		mov	r2, r3
 488 02c6 1023     		mov	r3, #16
 489 02c8 1340     		and	r3, r2
 490 02ca 01D0     		beq	.L34
 491              		.loc 1 183 0 is_stmt 0 discriminator 1
 492 02cc 1123     		mov	r3, #17
 493 02ce 30E1     		b	.L4
 494              	.L34:
 184:../Sources/mcg.c **** 
 185:../Sources/mcg.c ****   // Wait for clock status bits to show clock source is ext ref clk
 186:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 495              		.loc 1 186 0 is_stmt 1
 496 02d0 3B1C     		mov	r3, r7
 497 02d2 1433     		add	r3, r3, #20
 498 02d4 0022     		mov	r2, #0
 499 02d6 1A80     		strh	r2, [r3]
 500 02d8 0FE0     		b	.L35
 501              	.L38:
 187:../Sources/mcg.c ****   {
 188:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 502              		.loc 1 188 0
 503 02da 124B     		ldr	r3, .L61
 504 02dc 9B79     		ldrb	r3, [r3, #6]
 505 02de DBB2     		uxtb	r3, r3
 506 02e0 1A1C     		mov	r2, r3
 507 02e2 0C23     		mov	r3, #12
 508 02e4 1340     		and	r3, r2
 509 02e6 9B08     		lsr	r3, r3, #2
 510 02e8 022B     		cmp	r3, #2
 511 02ea 0ED0     		beq	.L57
 512              	.L36:
 186:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 513              		.loc 1 186 0
 514 02ec 3B1C     		mov	r3, r7
 515 02ee 1433     		add	r3, r3, #20
 516 02f0 3A1C     		mov	r2, r7
 517 02f2 1432     		add	r2, r2, #20
 518 02f4 1288     		ldrh	r2, [r2]
 519 02f6 0132     		add	r2, r2, #1
 520 02f8 1A80     		strh	r2, [r3]
 521              	.L35:
 186:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 522              		.loc 1 186 0 is_stmt 0 discriminator 1
 523 02fa 3B1C     		mov	r3, r7
 524 02fc 1433     		add	r3, r3, #20
 525 02fe 0021     		mov	r1, #0
 526 0300 5A5E     		ldrsh	r2, [r3, r1]
 527 0302 174B     		ldr	r3, .L61+60
 528 0304 9A42     		cmp	r2, r3
 529 0306 E8DD     		ble	.L38
 530 0308 00E0     		b	.L37
 531              	.L57:
 532              		.loc 1 188 0 is_stmt 1
 533 030a C046     		mov	r8, r8
 534              	.L37:
 189:../Sources/mcg.c ****   }
 190:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 535              		.loc 1 190 0
 536 030c 054B     		ldr	r3, .L61
 537 030e 9B79     		ldrb	r3, [r3, #6]
 538 0310 DBB2     		uxtb	r3, r3
 539 0312 1A1C     		mov	r2, r3
 540 0314 0C23     		mov	r3, #12
 541 0316 1340     		and	r3, r2
 542 0318 9B08     		lsr	r3, r3, #2
 543 031a 022B     		cmp	r3, #2
 544 031c 22D0     		beq	.L39
 545              		.loc 1 190 0 is_stmt 0 discriminator 1
 546 031e 1A23     		mov	r3, #26
 547 0320 07E1     		b	.L4
 548              	.L62:
 549 0322 C046     		.align	2
 550              	.L61:
 551 0324 00400640 		.word	1074151424
 552 0328 80F0FA02 		.word	50000000
 553 032c BFC62D00 		.word	2999999
 554 0330 0048E801 		.word	32000000
 555 0334 7F841E00 		.word	1999999
 556 0338 00093D00 		.word	4000000
 557 033c FF6BDC02 		.word	47999999
 558 0340 00E1F505 		.word	100000000
 559 0344 00127A00 		.word	8000000
 560 0348 D0121300 		.word	1250000
 561 034c A0252600 		.word	2500000
 562 0350 404B4C00 		.word	5000000
 563 0354 80969800 		.word	10000000
 564 0358 002D3101 		.word	20000000
 565 035c 1F4E0000 		.word	19999
 566 0360 CF070000 		.word	1999
 567              	.L39:
 191:../Sources/mcg.c **** 
 192:../Sources/mcg.c ****   // Now in FBE
 193:../Sources/mcg.c ****   // It is recommended that the clock monitor is enabled when using an external clock as the clock 
 194:../Sources/mcg.c ****   // It is enabled here but can be removed if this is not required.
 195:../Sources/mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 568              		.loc 1 195 0 is_stmt 1
 569 0364 754B     		ldr	r3, .L63
 570 0366 754A     		ldr	r2, .L63
 571 0368 5279     		ldrb	r2, [r2, #5]
 572 036a D2B2     		uxtb	r2, r2
 573 036c 2021     		mov	r1, #32
 574 036e 0A43     		orr	r2, r1
 575 0370 D2B2     		uxtb	r2, r2
 576 0372 5A71     		strb	r2, [r3, #5]
 196:../Sources/mcg.c ****   
 197:../Sources/mcg.c ****   // Configure PLL
 198:../Sources/mcg.c ****   // Configure MCG_C5
 199:../Sources/mcg.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 200:../Sources/mcg.c ****   temp_reg = MCG_C5;
 577              		.loc 1 200 0
 578 0374 714A     		ldr	r2, .L63
 579 0376 3B1C     		mov	r3, r7
 580 0378 1633     		add	r3, r3, #22
 581 037a 1279     		ldrb	r2, [r2, #4]
 582 037c 1A70     		strb	r2, [r3]
 201:../Sources/mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 583              		.loc 1 201 0
 584 037e 3B1C     		mov	r3, r7
 585 0380 1633     		add	r3, r3, #22
 586 0382 3A1C     		mov	r2, r7
 587 0384 1632     		add	r2, r2, #22
 588 0386 1278     		ldrb	r2, [r2]
 589 0388 1F21     		mov	r1, #31
 590 038a 8A43     		bic	r2, r1
 591 038c 1A70     		strb	r2, [r3]
 202:../Sources/mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 592              		.loc 1 202 0
 593 038e 7B1C     		add	r3, r7, #1
 594 0390 1B78     		ldrb	r3, [r3]
 595 0392 013B     		sub	r3, r3, #1
 596 0394 DAB2     		uxtb	r2, r3
 597 0396 1F23     		mov	r3, #31
 598 0398 1340     		and	r3, r2
 599 039a D9B2     		uxtb	r1, r3
 600 039c 3B1C     		mov	r3, r7
 601 039e 1633     		add	r3, r3, #22
 602 03a0 3A1C     		mov	r2, r7
 603 03a2 1632     		add	r2, r2, #22
 604 03a4 1278     		ldrb	r2, [r2]
 605 03a6 0A43     		orr	r2, r1
 606 03a8 1A70     		strb	r2, [r3]
 203:../Sources/mcg.c ****   MCG_C5 = temp_reg;
 607              		.loc 1 203 0
 608 03aa 644B     		ldr	r3, .L63
 609 03ac 3A1C     		mov	r2, r7
 610 03ae 1632     		add	r2, r2, #22
 611 03b0 1278     		ldrb	r2, [r2]
 612 03b2 1A71     		strb	r2, [r3, #4]
 204:../Sources/mcg.c **** 
 205:../Sources/mcg.c ****   // Configure MCG_C6
 206:../Sources/mcg.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 207:../Sources/mcg.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 208:../Sources/mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 613              		.loc 1 208 0
 614 03b4 614A     		ldr	r2, .L63
 615 03b6 3B1C     		mov	r3, r7
 616 03b8 1633     		add	r3, r3, #22
 617 03ba 5279     		ldrb	r2, [r2, #5]
 618 03bc 1A70     		strb	r2, [r3]
 209:../Sources/mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 619              		.loc 1 209 0
 620 03be 3B1C     		mov	r3, r7
 621 03c0 1633     		add	r3, r3, #22
 622 03c2 3A1C     		mov	r2, r7
 623 03c4 1632     		add	r2, r2, #22
 624 03c6 1278     		ldrb	r2, [r2]
 625 03c8 1F21     		mov	r1, #31
 626 03ca 8A43     		bic	r2, r1
 627 03cc 1A70     		strb	r2, [r3]
 210:../Sources/mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 628              		.loc 1 210 0
 629 03ce 3B1C     		mov	r3, r7
 630 03d0 2033     		add	r3, r3, #32
 631 03d2 1B78     		ldrb	r3, [r3]
 632 03d4 183B     		sub	r3, r3, #24
 633 03d6 DAB2     		uxtb	r2, r3
 634 03d8 1F23     		mov	r3, #31
 635 03da 1340     		and	r3, r2
 636 03dc DAB2     		uxtb	r2, r3
 637 03de 3B1C     		mov	r3, r7
 638 03e0 1633     		add	r3, r3, #22
 639 03e2 1B78     		ldrb	r3, [r3]
 640 03e4 1343     		orr	r3, r2
 641 03e6 DAB2     		uxtb	r2, r3
 642 03e8 3B1C     		mov	r3, r7
 643 03ea 1633     		add	r3, r3, #22
 644 03ec 4021     		mov	r1, #64
 645 03ee 0A43     		orr	r2, r1
 646 03f0 1A70     		strb	r2, [r3]
 211:../Sources/mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 647              		.loc 1 211 0
 648 03f2 524B     		ldr	r3, .L63
 649 03f4 3A1C     		mov	r2, r7
 650 03f6 1632     		add	r2, r2, #22
 651 03f8 1278     		ldrb	r2, [r2]
 652 03fa 5A71     		strb	r2, [r3, #5]
 212:../Sources/mcg.c **** 
 213:../Sources/mcg.c ****   // wait for PLLST status bit to set
 214:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 653              		.loc 1 214 0
 654 03fc 3B1C     		mov	r3, r7
 655 03fe 1433     		add	r3, r3, #20
 656 0400 0022     		mov	r2, #0
 657 0402 1A80     		strh	r2, [r3]
 658 0404 0DE0     		b	.L40
 659              	.L43:
 215:../Sources/mcg.c ****   {
 216:../Sources/mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 660              		.loc 1 216 0
 661 0406 4D4B     		ldr	r3, .L63
 662 0408 9B79     		ldrb	r3, [r3, #6]
 663 040a DBB2     		uxtb	r3, r3
 664 040c 1A1C     		mov	r2, r3
 665 040e 2023     		mov	r3, #32
 666 0410 1340     		and	r3, r2
 667 0412 0ED1     		bne	.L58
 668              	.L41:
 214:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 669              		.loc 1 214 0
 670 0414 3B1C     		mov	r3, r7
 671 0416 1433     		add	r3, r3, #20
 672 0418 3A1C     		mov	r2, r7
 673 041a 1432     		add	r2, r2, #20
 674 041c 1288     		ldrh	r2, [r2]
 675 041e 0132     		add	r2, r2, #1
 676 0420 1A80     		strh	r2, [r3]
 677              	.L40:
 214:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 678              		.loc 1 214 0 is_stmt 0 discriminator 1
 679 0422 3B1C     		mov	r3, r7
 680 0424 1433     		add	r3, r3, #20
 681 0426 0021     		mov	r1, #0
 682 0428 5A5E     		ldrsh	r2, [r3, r1]
 683 042a 454B     		ldr	r3, .L63+4
 684 042c 9A42     		cmp	r2, r3
 685 042e EADD     		ble	.L43
 686 0430 00E0     		b	.L42
 687              	.L58:
 688              		.loc 1 216 0 is_stmt 1
 689 0432 C046     		mov	r8, r8
 690              	.L42:
 217:../Sources/mcg.c ****   }
 218:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 691              		.loc 1 218 0
 692 0434 414B     		ldr	r3, .L63
 693 0436 9B79     		ldrb	r3, [r3, #6]
 694 0438 DBB2     		uxtb	r3, r3
 695 043a 1A1C     		mov	r2, r3
 696 043c 2023     		mov	r3, #32
 697 043e 1340     		and	r3, r2
 698 0440 01D1     		bne	.L44
 699              		.loc 1 218 0 is_stmt 0 discriminator 1
 700 0442 1623     		mov	r3, #22
 701 0444 75E0     		b	.L4
 702              	.L44:
 219:../Sources/mcg.c **** 
 220:../Sources/mcg.c ****   // Wait for LOCK bit to set
 221:../Sources/mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 703              		.loc 1 221 0 is_stmt 1
 704 0446 3B1C     		mov	r3, r7
 705 0448 1433     		add	r3, r3, #20
 706 044a 0022     		mov	r2, #0
 707 044c 1A80     		strh	r2, [r3]
 708 044e 0DE0     		b	.L45
 709              	.L48:
 222:../Sources/mcg.c ****   {
 223:../Sources/mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 710              		.loc 1 223 0
 711 0450 3A4B     		ldr	r3, .L63
 712 0452 9B79     		ldrb	r3, [r3, #6]
 713 0454 DBB2     		uxtb	r3, r3
 714 0456 1A1C     		mov	r2, r3
 715 0458 4023     		mov	r3, #64
 716 045a 1340     		and	r3, r2
 717 045c 0ED1     		bne	.L59
 718              	.L46:
 221:../Sources/mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 719              		.loc 1 221 0
 720 045e 3B1C     		mov	r3, r7
 721 0460 1433     		add	r3, r3, #20
 722 0462 3A1C     		mov	r2, r7
 723 0464 1432     		add	r2, r2, #20
 724 0466 1288     		ldrh	r2, [r2]
 725 0468 0132     		add	r2, r2, #1
 726 046a 1A80     		strh	r2, [r3]
 727              	.L45:
 221:../Sources/mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 728              		.loc 1 221 0 is_stmt 0 discriminator 1
 729 046c 3B1C     		mov	r3, r7
 730 046e 1433     		add	r3, r3, #20
 731 0470 0021     		mov	r1, #0
 732 0472 5A5E     		ldrsh	r2, [r3, r1]
 733 0474 334B     		ldr	r3, .L63+8
 734 0476 9A42     		cmp	r2, r3
 735 0478 EADD     		ble	.L48
 736 047a 00E0     		b	.L47
 737              	.L59:
 738              		.loc 1 223 0 is_stmt 1
 739 047c C046     		mov	r8, r8
 740              	.L47:
 224:../Sources/mcg.c ****   }
 225:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 741              		.loc 1 225 0
 742 047e 2F4B     		ldr	r3, .L63
 743 0480 9B79     		ldrb	r3, [r3, #6]
 744 0482 DBB2     		uxtb	r3, r3
 745 0484 1A1C     		mov	r2, r3
 746 0486 4023     		mov	r3, #64
 747 0488 1340     		and	r3, r2
 748 048a 01D1     		bne	.L49
 749              		.loc 1 225 0 is_stmt 0 discriminator 1
 750 048c 4423     		mov	r3, #68
 751 048e 50E0     		b	.L4
 752              	.L49:
 226:../Sources/mcg.c **** 
 227:../Sources/mcg.c ****   // Use actual PLL settings to calculate PLL frequency
 228:../Sources/mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 753              		.loc 1 228 0 is_stmt 1
 754 0490 2A4B     		ldr	r3, .L63
 755 0492 1B79     		ldrb	r3, [r3, #4]
 756 0494 DAB2     		uxtb	r2, r3
 757 0496 1F23     		mov	r3, #31
 758 0498 1340     		and	r3, r2
 759 049a DAB2     		uxtb	r2, r3
 760 049c 3B1C     		mov	r3, r7
 761 049e 0B33     		add	r3, r3, #11
 762 04a0 0132     		add	r2, r2, #1
 763 04a2 1A70     		strb	r2, [r3]
 229:../Sources/mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 764              		.loc 1 229 0
 765 04a4 254B     		ldr	r3, .L63
 766 04a6 5B79     		ldrb	r3, [r3, #5]
 767 04a8 DAB2     		uxtb	r2, r3
 768 04aa 1F23     		mov	r3, #31
 769 04ac 1340     		and	r3, r2
 770 04ae DAB2     		uxtb	r2, r3
 771 04b0 3B1C     		mov	r3, r7
 772 04b2 0A33     		add	r3, r3, #10
 773 04b4 1832     		add	r2, r2, #24
 774 04b6 1A70     		strb	r2, [r3]
 230:../Sources/mcg.c **** 
 231:../Sources/mcg.c ****   // now in PBE
 232:../Sources/mcg.c **** 
 233:../Sources/mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 775              		.loc 1 233 0
 776 04b8 204B     		ldr	r3, .L63
 777 04ba 204A     		ldr	r2, .L63
 778 04bc 1278     		ldrb	r2, [r2]
 779 04be D1B2     		uxtb	r1, r2
 780 04c0 3F22     		mov	r2, #63
 781 04c2 0A40     		and	r2, r1
 782 04c4 D2B2     		uxtb	r2, r2
 783 04c6 1A70     		strb	r2, [r3]
 234:../Sources/mcg.c **** 
 235:../Sources/mcg.c ****   // Wait for clock status bits to update
 236:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 784              		.loc 1 236 0
 785 04c8 3B1C     		mov	r3, r7
 786 04ca 1433     		add	r3, r3, #20
 787 04cc 0022     		mov	r2, #0
 788 04ce 1A80     		strh	r2, [r3]
 789 04d0 0FE0     		b	.L50
 790              	.L53:
 237:../Sources/mcg.c ****   {
 238:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 791              		.loc 1 238 0
 792 04d2 1A4B     		ldr	r3, .L63
 793 04d4 9B79     		ldrb	r3, [r3, #6]
 794 04d6 DBB2     		uxtb	r3, r3
 795 04d8 1A1C     		mov	r2, r3
 796 04da 0C23     		mov	r3, #12
 797 04dc 1340     		and	r3, r2
 798 04de 9B08     		lsr	r3, r3, #2
 799 04e0 032B     		cmp	r3, #3
 800 04e2 0ED0     		beq	.L60
 801              	.L51:
 236:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 802              		.loc 1 236 0
 803 04e4 3B1C     		mov	r3, r7
 804 04e6 1433     		add	r3, r3, #20
 805 04e8 3A1C     		mov	r2, r7
 806 04ea 1432     		add	r2, r2, #20
 807 04ec 1288     		ldrh	r2, [r2]
 808 04ee 0132     		add	r2, r2, #1
 809 04f0 1A80     		strh	r2, [r3]
 810              	.L50:
 236:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 811              		.loc 1 236 0 is_stmt 0 discriminator 1
 812 04f2 3B1C     		mov	r3, r7
 813 04f4 1433     		add	r3, r3, #20
 814 04f6 0021     		mov	r1, #0
 815 04f8 5A5E     		ldrsh	r2, [r3, r1]
 816 04fa 114B     		ldr	r3, .L63+4
 817 04fc 9A42     		cmp	r2, r3
 818 04fe E8DD     		ble	.L53
 819 0500 00E0     		b	.L52
 820              	.L60:
 821              		.loc 1 238 0 is_stmt 1
 822 0502 C046     		mov	r8, r8
 823              	.L52:
 239:../Sources/mcg.c ****   }
 240:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 824              		.loc 1 240 0
 825 0504 0D4B     		ldr	r3, .L63
 826 0506 9B79     		ldrb	r3, [r3, #6]
 827 0508 DBB2     		uxtb	r3, r3
 828 050a 1A1C     		mov	r2, r3
 829 050c 0C23     		mov	r3, #12
 830 050e 1340     		and	r3, r2
 831 0510 9B08     		lsr	r3, r3, #2
 832 0512 032B     		cmp	r3, #3
 833 0514 01D0     		beq	.L54
 834              		.loc 1 240 0 is_stmt 0 discriminator 1
 835 0516 1B23     		mov	r3, #27
 836 0518 0BE0     		b	.L4
 837              	.L54:
 241:../Sources/mcg.c **** 
 242:../Sources/mcg.c ****   // Now in PEE
 243:../Sources/mcg.c ****   
 244:../Sources/mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 838              		.loc 1 244 0 is_stmt 1
 839 051a 3B1C     		mov	r3, r7
 840 051c 0B33     		add	r3, r3, #11
 841 051e 1B78     		ldrb	r3, [r3]
 842 0520 7868     		ldr	r0, [r7, #4]
 843 0522 191C     		mov	r1, r3
 844 0524 FFF7FEFF 		bl	__aeabi_idiv
 845 0528 031C     		mov	r3, r0
 846 052a 3A1C     		mov	r2, r7
 847 052c 0A32     		add	r2, r2, #10
 848 052e 1278     		ldrb	r2, [r2]
 849 0530 5343     		mul	r3, r2
 850              	.L4:
 245:../Sources/mcg.c **** } // pll_init
 851              		.loc 1 245 0
 852 0532 181C     		mov	r0, r3
 853 0534 BD46     		mov	sp, r7
 854 0536 06B0     		add	sp, sp, #24
 855              		@ sp needed for prologue
 856 0538 80BD     		pop	{r7, pc}
 857              	.L64:
 858 053a C046     		.align	2
 859              	.L63:
 860 053c 00400640 		.word	1074151424
 861 0540 CF070000 		.word	1999
 862 0544 9F0F0000 		.word	3999
 863              		.cfi_endproc
 864              	.LFE0:
 866              		.section	.text.new_pll_freq,"ax",%progbits
 867              		.align	2
 868              		.global	new_pll_freq
 869              		.code	16
 870              		.thumb_func
 872              	new_pll_freq:
 873              	.LFB1:
 246:../Sources/mcg.c **** 
 247:../Sources/mcg.c **** 
 248:../Sources/mcg.c **** /*********************************************************************************************/
 249:../Sources/mcg.c **** /* Functon name : new_pll_freq
 250:../Sources/mcg.c ****  *
 251:../Sources/mcg.c ****  * Mode transition: Moves from PEE to PBE mode before changing PLL settings and moves back to PEE m
 252:../Sources/mcg.c ****  *
 253:../Sources/mcg.c ****  * This function provides a safe means of updating the PLL configurations to ensure the system
 254:../Sources/mcg.c ****  * does not lose the clock source or is over-clocked as the PLL frequency changes.
 255:../Sources/mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
 256:../Sources/mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
 257:../Sources/mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
 258:../Sources/mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
 259:../Sources/mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
 260:../Sources/mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
 261:../Sources/mcg.c ****  * This function first moves the MCG to PBE mode to use the external reference clock to provide the
 262:../Sources/mcg.c ****  * system clock. The PLL settings are then updated. Once the PLL has re-locked the MCG is moved bac
 263:../Sources/mcg.c ****  * to PEE to use the PLL as the system clock.
 264:../Sources/mcg.c ****  * Only the PLL PRDIV0 and VDIV0 fields are changed.
 265:../Sources/mcg.c ****  * 
 266:../Sources/mcg.c ****  * Prerequisistes : The MCG must be in PEE mode before calling this routine. It is the responsibili
 267:../Sources/mcg.c ****  * of the calling routine to ensure the SIM_CLKDIV1 system clock dividers and any peripheral clock
 268:../Sources/mcg.c ****  * dividers are set correctly before or after calling this function to ensure the appropriate clock
 269:../Sources/mcg.c ****  * are kept within specification. You would typically change the divider values before calling this
 270:../Sources/mcg.c ****  * routine.
 271:../Sources/mcg.c ****  * 
 272:../Sources/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
 273:../Sources/mcg.c ****  *                           wave clock source
 274:../Sources/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 275:../Sources/mcg.c ****  *                           PLL reference clock frequency
 276:../Sources/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 277:../Sources/mcg.c ****  *
 278:../Sources/mcg.c ****  * Return value : PLL frequency (Hz) or error code
 279:../Sources/mcg.c ****  */
 280:../Sources/mcg.c **** int new_pll_freq(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 281:../Sources/mcg.c **** {
 874              		.loc 1 281 0
 875              		.cfi_startproc
 876 0000 80B5     		push	{r7, lr}
 877              	.LCFI3:
 878              		.cfi_def_cfa_offset 8
 879              		.cfi_offset 7, -8
 880              		.cfi_offset 14, -4
 881 0002 86B0     		sub	sp, sp, #24
 882              	.LCFI4:
 883              		.cfi_def_cfa_offset 32
 884 0004 00AF     		add	r7, sp, #0
 885              	.LCFI5:
 886              		.cfi_def_cfa_register 7
 887 0006 7860     		str	r0, [r7, #4]
 888 0008 FB1C     		add	r3, r7, #3
 889 000a 1970     		strb	r1, [r3]
 890 000c BB1C     		add	r3, r7, #2
 891 000e 1A70     		strb	r2, [r3]
 282:../Sources/mcg.c ****   unsigned char temp_reg;
 283:../Sources/mcg.c ****   unsigned char prdiv, vdiv;
 284:../Sources/mcg.c ****   short i;
 285:../Sources/mcg.c ****   int ref_freq;
 286:../Sources/mcg.c ****   int pll_freq;
 287:../Sources/mcg.c **** 
 288:../Sources/mcg.c ****   
 289:../Sources/mcg.c ****   // Check MCG is in PEE mode
 290:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 892              		.loc 1 290 0
 893 0010 B74B     		ldr	r3, .L101
 894 0012 9B79     		ldrb	r3, [r3, #6]
 895 0014 DBB2     		uxtb	r3, r3
 896 0016 1A1C     		mov	r2, r3
 897 0018 0C23     		mov	r3, #12
 898 001a 1340     		and	r3, r2
 899 001c 9B08     		lsr	r3, r3, #2
 900 001e 032B     		cmp	r3, #3
 901 0020 0DD1     		bne	.L66
 291:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 902              		.loc 1 291 0 discriminator 1
 903 0022 B34B     		ldr	r3, .L101
 904 0024 9B79     		ldrb	r3, [r3, #6]
 905 0026 DBB2     		uxtb	r3, r3
 906 0028 1A1C     		mov	r2, r3
 907 002a 1023     		mov	r3, #16
 908 002c 1340     		and	r3, r2
 290:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 909              		.loc 1 290 0 discriminator 1
 910 002e 06D1     		bne	.L66
 292:../Sources/mcg.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 911              		.loc 1 292 0 discriminator 1
 912 0030 AF4B     		ldr	r3, .L101
 913 0032 9B79     		ldrb	r3, [r3, #6]
 914 0034 DBB2     		uxtb	r3, r3
 915 0036 1A1C     		mov	r2, r3
 916 0038 2023     		mov	r3, #32
 917 003a 1340     		and	r3, r2
 290:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 918              		.loc 1 290 0 discriminator 1
 919 003c 01D1     		bne	.L67
 920              	.L66:
 293:../Sources/mcg.c ****   {
 294:../Sources/mcg.c ****     return 0x8;                                                       // return error code
 921              		.loc 1 294 0
 922 003e 0823     		mov	r3, #8
 923 0040 51E1     		b	.L68
 924              	.L67:
 295:../Sources/mcg.c ****   } 
 296:../Sources/mcg.c ****   
 297:../Sources/mcg.c ****   // Check PLL divider settings are within spec.
 298:../Sources/mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 925              		.loc 1 298 0
 926 0042 FB1C     		add	r3, r7, #3
 927 0044 1B78     		ldrb	r3, [r3]
 928 0046 5BB2     		sxtb	r3, r3
 929 0048 002B     		cmp	r3, #0
 930 004a 04DD     		ble	.L69
 931              		.loc 1 298 0 is_stmt 0 discriminator 2
 932 004c FB1C     		add	r3, r7, #3
 933 004e 1B78     		ldrb	r3, [r3]
 934 0050 5BB2     		sxtb	r3, r3
 935 0052 192B     		cmp	r3, #25
 936 0054 01DD     		ble	.L70
 937              	.L69:
 938              		.loc 1 298 0 discriminator 1
 939 0056 4123     		mov	r3, #65
 940 0058 45E1     		b	.L68
 941              	.L70:
 299:../Sources/mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 942              		.loc 1 299 0 is_stmt 1
 943 005a BB1C     		add	r3, r7, #2
 944 005c 1B78     		ldrb	r3, [r3]
 945 005e 5BB2     		sxtb	r3, r3
 946 0060 172B     		cmp	r3, #23
 947 0062 04DD     		ble	.L71
 948              		.loc 1 299 0 is_stmt 0 discriminator 2
 949 0064 BB1C     		add	r3, r7, #2
 950 0066 1B78     		ldrb	r3, [r3]
 951 0068 5BB2     		sxtb	r3, r3
 952 006a 322B     		cmp	r3, #50
 953 006c 01DD     		ble	.L72
 954              	.L71:
 955              		.loc 1 299 0 discriminator 1
 956 006e 4223     		mov	r3, #66
 957 0070 39E1     		b	.L68
 958              	.L72:
 300:../Sources/mcg.c **** 
 301:../Sources/mcg.c ****   // Check PLL reference clock frequency is within spec.
 302:../Sources/mcg.c ****   ref_freq = crystal_val / prdiv_val;
 959              		.loc 1 302 0 is_stmt 1
 960 0072 FB1C     		add	r3, r7, #3
 961 0074 1B78     		ldrb	r3, [r3]
 962 0076 5BB2     		sxtb	r3, r3
 963 0078 7868     		ldr	r0, [r7, #4]
 964 007a 191C     		mov	r1, r3
 965 007c FFF7FEFF 		bl	__aeabi_idiv
 966 0080 031C     		mov	r3, r0
 967 0082 3B61     		str	r3, [r7, #16]
 303:../Sources/mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 968              		.loc 1 303 0
 969 0084 3A69     		ldr	r2, [r7, #16]
 970 0086 9B4B     		ldr	r3, .L101+4
 971 0088 9A42     		cmp	r2, r3
 972 008a 03DD     		ble	.L73
 973              		.loc 1 303 0 is_stmt 0 discriminator 2
 974 008c 3A69     		ldr	r2, [r7, #16]
 975 008e 9A4B     		ldr	r3, .L101+8
 976 0090 9A42     		cmp	r2, r3
 977 0092 01DD     		ble	.L74
 978              	.L73:
 979              		.loc 1 303 0 discriminator 1
 980 0094 4323     		mov	r3, #67
 981 0096 26E1     		b	.L68
 982              	.L74:
 304:../Sources/mcg.c **** 
 305:../Sources/mcg.c ****   // Check PLL output frequency is within spec.
 306:../Sources/mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 983              		.loc 1 306 0 is_stmt 1
 984 0098 FB1C     		add	r3, r7, #3
 985 009a 1B78     		ldrb	r3, [r3]
 986 009c 5BB2     		sxtb	r3, r3
 987 009e 7868     		ldr	r0, [r7, #4]
 988 00a0 191C     		mov	r1, r3
 989 00a2 FFF7FEFF 		bl	__aeabi_idiv
 990 00a6 031C     		mov	r3, r0
 991 00a8 BA1C     		add	r2, r7, #2
 992 00aa 1278     		ldrb	r2, [r2]
 993 00ac 52B2     		sxtb	r2, r2
 994 00ae 5343     		mul	r3, r2
 995 00b0 FB60     		str	r3, [r7, #12]
 307:../Sources/mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 996              		.loc 1 307 0
 997 00b2 FA68     		ldr	r2, [r7, #12]
 998 00b4 914B     		ldr	r3, .L101+12
 999 00b6 9A42     		cmp	r2, r3
 1000 00b8 03DD     		ble	.L75
 1001              		.loc 1 307 0 is_stmt 0 discriminator 2
 1002 00ba FA68     		ldr	r2, [r7, #12]
 1003 00bc 904B     		ldr	r3, .L101+16
 1004 00be 9A42     		cmp	r2, r3
 1005 00c0 01DD     		ble	.L76
 1006              	.L75:
 1007              		.loc 1 307 0 discriminator 1
 1008 00c2 4523     		mov	r3, #69
 1009 00c4 0FE1     		b	.L68
 1010              	.L76:
 308:../Sources/mcg.c ****   
 309:../Sources/mcg.c ****   // First move to PBE mode so that the PLL frequency can be safely changed.
 310:../Sources/mcg.c ****   // As we are running from the PLL by default the PLL and external clock settings are valid
 311:../Sources/mcg.c ****   // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext clock 
 312:../Sources/mcg.c ****   // As CLKS is already 0 the CLKS value can simply be OR'ed into the register 
 313:../Sources/mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 1011              		.loc 1 313 0 is_stmt 1
 1012 00c6 8A4B     		ldr	r3, .L101
 1013 00c8 894A     		ldr	r2, .L101
 1014 00ca 1278     		ldrb	r2, [r2]
 1015 00cc D2B2     		uxtb	r2, r2
 1016 00ce 8021     		mov	r1, #128
 1017 00d0 4942     		neg	r1, r1
 1018 00d2 0A43     		orr	r2, r1
 1019 00d4 D2B2     		uxtb	r2, r2
 1020 00d6 1A70     		strb	r2, [r3]
 314:../Sources/mcg.c ****   
 315:../Sources/mcg.c ****   // Wait for clock status bits to update 
 316:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1021              		.loc 1 316 0
 1022 00d8 3B1C     		mov	r3, r7
 1023 00da 1633     		add	r3, r3, #22
 1024 00dc 0022     		mov	r2, #0
 1025 00de 1A80     		strh	r2, [r3]
 1026 00e0 0FE0     		b	.L77
 1027              	.L80:
 317:../Sources/mcg.c ****   {
 318:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 1028              		.loc 1 318 0
 1029 00e2 834B     		ldr	r3, .L101
 1030 00e4 9B79     		ldrb	r3, [r3, #6]
 1031 00e6 DBB2     		uxtb	r3, r3
 1032 00e8 1A1C     		mov	r2, r3
 1033 00ea 0C23     		mov	r3, #12
 1034 00ec 1340     		and	r3, r2
 1035 00ee 9B08     		lsr	r3, r3, #2
 1036 00f0 022B     		cmp	r3, #2
 1037 00f2 0ED0     		beq	.L97
 1038              	.L78:
 316:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1039              		.loc 1 316 0
 1040 00f4 3B1C     		mov	r3, r7
 1041 00f6 1633     		add	r3, r3, #22
 1042 00f8 3A1C     		mov	r2, r7
 1043 00fa 1632     		add	r2, r2, #22
 1044 00fc 1288     		ldrh	r2, [r2]
 1045 00fe 0132     		add	r2, r2, #1
 1046 0100 1A80     		strh	r2, [r3]
 1047              	.L77:
 316:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1048              		.loc 1 316 0 is_stmt 0 discriminator 1
 1049 0102 3B1C     		mov	r3, r7
 1050 0104 1633     		add	r3, r3, #22
 1051 0106 0021     		mov	r1, #0
 1052 0108 5A5E     		ldrsh	r2, [r3, r1]
 1053 010a 7E4B     		ldr	r3, .L101+20
 1054 010c 9A42     		cmp	r2, r3
 1055 010e E8DD     		ble	.L80
 1056 0110 00E0     		b	.L79
 1057              	.L97:
 1058              		.loc 1 318 0 is_stmt 1
 1059 0112 C046     		mov	r8, r8
 1060              	.L79:
 319:../Sources/mcg.c ****   }
 320:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 1061              		.loc 1 320 0
 1062 0114 764B     		ldr	r3, .L101
 1063 0116 9B79     		ldrb	r3, [r3, #6]
 1064 0118 DBB2     		uxtb	r3, r3
 1065 011a 1A1C     		mov	r2, r3
 1066 011c 0C23     		mov	r3, #12
 1067 011e 1340     		and	r3, r2
 1068 0120 9B08     		lsr	r3, r3, #2
 1069 0122 022B     		cmp	r3, #2
 1070 0124 01D0     		beq	.L81
 1071              		.loc 1 320 0 is_stmt 0 discriminator 1
 1072 0126 1A23     		mov	r3, #26
 1073 0128 DDE0     		b	.L68
 1074              	.L81:
 321:../Sources/mcg.c **** 
 322:../Sources/mcg.c ****   // Now in PBE mode 
 323:../Sources/mcg.c ****   // System is clocked off the external clock. 
 324:../Sources/mcg.c ****   // Now update the PLL settings and wait for the PLL to re-lock
 325:../Sources/mcg.c ****   // Configure MCG_C5
 326:../Sources/mcg.c ****   temp_reg = MCG_C5;
 1075              		.loc 1 326 0 is_stmt 1
 1076 012a 714A     		ldr	r2, .L101
 1077 012c 3B1C     		mov	r3, r7
 1078 012e 0B33     		add	r3, r3, #11
 1079 0130 1279     		ldrb	r2, [r2, #4]
 1080 0132 1A70     		strb	r2, [r3]
 327:../Sources/mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1081              		.loc 1 327 0
 1082 0134 3B1C     		mov	r3, r7
 1083 0136 0B33     		add	r3, r3, #11
 1084 0138 3A1C     		mov	r2, r7
 1085 013a 0B32     		add	r2, r2, #11
 1086 013c 1278     		ldrb	r2, [r2]
 1087 013e 1F21     		mov	r1, #31
 1088 0140 8A43     		bic	r2, r1
 1089 0142 1A70     		strb	r2, [r3]
 328:../Sources/mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 1090              		.loc 1 328 0
 1091 0144 FB1C     		add	r3, r7, #3
 1092 0146 1B78     		ldrb	r3, [r3]
 1093 0148 013B     		sub	r3, r3, #1
 1094 014a DAB2     		uxtb	r2, r3
 1095 014c 1F23     		mov	r3, #31
 1096 014e 1340     		and	r3, r2
 1097 0150 D9B2     		uxtb	r1, r3
 1098 0152 3B1C     		mov	r3, r7
 1099 0154 0B33     		add	r3, r3, #11
 1100 0156 3A1C     		mov	r2, r7
 1101 0158 0B32     		add	r2, r2, #11
 1102 015a 1278     		ldrb	r2, [r2]
 1103 015c 0A43     		orr	r2, r1
 1104 015e 1A70     		strb	r2, [r3]
 329:../Sources/mcg.c ****   MCG_C5 = temp_reg;
 1105              		.loc 1 329 0
 1106 0160 634B     		ldr	r3, .L101
 1107 0162 3A1C     		mov	r2, r7
 1108 0164 0B32     		add	r2, r2, #11
 1109 0166 1278     		ldrb	r2, [r2]
 1110 0168 1A71     		strb	r2, [r3, #4]
 330:../Sources/mcg.c **** 
 331:../Sources/mcg.c ****   // Configure MCG_C6
 332:../Sources/mcg.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 333:../Sources/mcg.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 334:../Sources/mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 1111              		.loc 1 334 0
 1112 016a 614A     		ldr	r2, .L101
 1113 016c 3B1C     		mov	r3, r7
 1114 016e 0B33     		add	r3, r3, #11
 1115 0170 5279     		ldrb	r2, [r2, #5]
 1116 0172 1A70     		strb	r2, [r3]
 335:../Sources/mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1117              		.loc 1 335 0
 1118 0174 3B1C     		mov	r3, r7
 1119 0176 0B33     		add	r3, r3, #11
 1120 0178 3A1C     		mov	r2, r7
 1121 017a 0B32     		add	r2, r2, #11
 1122 017c 1278     		ldrb	r2, [r2]
 1123 017e 1F21     		mov	r1, #31
 1124 0180 8A43     		bic	r2, r1
 1125 0182 1A70     		strb	r2, [r3]
 336:../Sources/mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1126              		.loc 1 336 0
 1127 0184 BB1C     		add	r3, r7, #2
 1128 0186 1B78     		ldrb	r3, [r3]
 1129 0188 183B     		sub	r3, r3, #24
 1130 018a DAB2     		uxtb	r2, r3
 1131 018c 1F23     		mov	r3, #31
 1132 018e 1340     		and	r3, r2
 1133 0190 DAB2     		uxtb	r2, r3
 1134 0192 3B1C     		mov	r3, r7
 1135 0194 0B33     		add	r3, r3, #11
 1136 0196 1B78     		ldrb	r3, [r3]
 1137 0198 1343     		orr	r3, r2
 1138 019a DAB2     		uxtb	r2, r3
 1139 019c 3B1C     		mov	r3, r7
 1140 019e 0B33     		add	r3, r3, #11
 1141 01a0 4021     		mov	r1, #64
 1142 01a2 0A43     		orr	r2, r1
 1143 01a4 1A70     		strb	r2, [r3]
 337:../Sources/mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 1144              		.loc 1 337 0
 1145 01a6 524B     		ldr	r3, .L101
 1146 01a8 3A1C     		mov	r2, r7
 1147 01aa 0B32     		add	r2, r2, #11
 1148 01ac 1278     		ldrb	r2, [r2]
 1149 01ae 5A71     		strb	r2, [r3, #5]
 338:../Sources/mcg.c **** 
 339:../Sources/mcg.c ****   // wait for PLLST status bit to set
 340:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1150              		.loc 1 340 0
 1151 01b0 3B1C     		mov	r3, r7
 1152 01b2 1633     		add	r3, r3, #22
 1153 01b4 0022     		mov	r2, #0
 1154 01b6 1A80     		strh	r2, [r3]
 1155 01b8 0DE0     		b	.L82
 1156              	.L85:
 341:../Sources/mcg.c ****   {
 342:../Sources/mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1157              		.loc 1 342 0
 1158 01ba 4D4B     		ldr	r3, .L101
 1159 01bc 9B79     		ldrb	r3, [r3, #6]
 1160 01be DBB2     		uxtb	r3, r3
 1161 01c0 1A1C     		mov	r2, r3
 1162 01c2 2023     		mov	r3, #32
 1163 01c4 1340     		and	r3, r2
 1164 01c6 0ED1     		bne	.L98
 1165              	.L83:
 340:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1166              		.loc 1 340 0
 1167 01c8 3B1C     		mov	r3, r7
 1168 01ca 1633     		add	r3, r3, #22
 1169 01cc 3A1C     		mov	r2, r7
 1170 01ce 1632     		add	r2, r2, #22
 1171 01d0 1288     		ldrh	r2, [r2]
 1172 01d2 0132     		add	r2, r2, #1
 1173 01d4 1A80     		strh	r2, [r3]
 1174              	.L82:
 340:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1175              		.loc 1 340 0 is_stmt 0 discriminator 1
 1176 01d6 3B1C     		mov	r3, r7
 1177 01d8 1633     		add	r3, r3, #22
 1178 01da 0021     		mov	r1, #0
 1179 01dc 5A5E     		ldrsh	r2, [r3, r1]
 1180 01de 494B     		ldr	r3, .L101+20
 1181 01e0 9A42     		cmp	r2, r3
 1182 01e2 EADD     		ble	.L85
 1183 01e4 00E0     		b	.L84
 1184              	.L98:
 1185              		.loc 1 342 0 is_stmt 1
 1186 01e6 C046     		mov	r8, r8
 1187              	.L84:
 343:../Sources/mcg.c ****   }
 344:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 1188              		.loc 1 344 0
 1189 01e8 414B     		ldr	r3, .L101
 1190 01ea 9B79     		ldrb	r3, [r3, #6]
 1191 01ec DBB2     		uxtb	r3, r3
 1192 01ee 1A1C     		mov	r2, r3
 1193 01f0 2023     		mov	r3, #32
 1194 01f2 1340     		and	r3, r2
 1195 01f4 01D1     		bne	.L86
 1196              		.loc 1 344 0 is_stmt 0 discriminator 1
 1197 01f6 1623     		mov	r3, #22
 1198 01f8 75E0     		b	.L68
 1199              	.L86:
 345:../Sources/mcg.c **** 
 346:../Sources/mcg.c ****   // Wait for LOCK bit to set
 347:../Sources/mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 1200              		.loc 1 347 0 is_stmt 1
 1201 01fa 3B1C     		mov	r3, r7
 1202 01fc 1633     		add	r3, r3, #22
 1203 01fe 0022     		mov	r2, #0
 1204 0200 1A80     		strh	r2, [r3]
 1205 0202 0DE0     		b	.L87
 1206              	.L90:
 348:../Sources/mcg.c ****   {
 349:../Sources/mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1207              		.loc 1 349 0
 1208 0204 3A4B     		ldr	r3, .L101
 1209 0206 9B79     		ldrb	r3, [r3, #6]
 1210 0208 DBB2     		uxtb	r3, r3
 1211 020a 1A1C     		mov	r2, r3
 1212 020c 4023     		mov	r3, #64
 1213 020e 1340     		and	r3, r2
 1214 0210 0ED1     		bne	.L99
 1215              	.L88:
 347:../Sources/mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 1216              		.loc 1 347 0
 1217 0212 3B1C     		mov	r3, r7
 1218 0214 1633     		add	r3, r3, #22
 1219 0216 3A1C     		mov	r2, r7
 1220 0218 1632     		add	r2, r2, #22
 1221 021a 1288     		ldrh	r2, [r2]
 1222 021c 0132     		add	r2, r2, #1
 1223 021e 1A80     		strh	r2, [r3]
 1224              	.L87:
 347:../Sources/mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 1225              		.loc 1 347 0 is_stmt 0 discriminator 1
 1226 0220 3B1C     		mov	r3, r7
 1227 0222 1633     		add	r3, r3, #22
 1228 0224 0021     		mov	r1, #0
 1229 0226 5A5E     		ldrsh	r2, [r3, r1]
 1230 0228 374B     		ldr	r3, .L101+24
 1231 022a 9A42     		cmp	r2, r3
 1232 022c EADD     		ble	.L90
 1233 022e 00E0     		b	.L89
 1234              	.L99:
 1235              		.loc 1 349 0 is_stmt 1
 1236 0230 C046     		mov	r8, r8
 1237              	.L89:
 350:../Sources/mcg.c ****   }
 351:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1238              		.loc 1 351 0
 1239 0232 2F4B     		ldr	r3, .L101
 1240 0234 9B79     		ldrb	r3, [r3, #6]
 1241 0236 DBB2     		uxtb	r3, r3
 1242 0238 1A1C     		mov	r2, r3
 1243 023a 4023     		mov	r3, #64
 1244 023c 1340     		and	r3, r2
 1245 023e 01D1     		bne	.L91
 1246              		.loc 1 351 0 is_stmt 0 discriminator 1
 1247 0240 4423     		mov	r3, #68
 1248 0242 50E0     		b	.L68
 1249              	.L91:
 352:../Sources/mcg.c **** 
 353:../Sources/mcg.c ****   // Change CLKS mux to now select the PLL output
 354:../Sources/mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 1250              		.loc 1 354 0 is_stmt 1
 1251 0244 2A4B     		ldr	r3, .L101
 1252 0246 2A4A     		ldr	r2, .L101
 1253 0248 1278     		ldrb	r2, [r2]
 1254 024a D1B2     		uxtb	r1, r2
 1255 024c 3F22     		mov	r2, #63
 1256 024e 0A40     		and	r2, r1
 1257 0250 D2B2     		uxtb	r2, r2
 1258 0252 1A70     		strb	r2, [r3]
 355:../Sources/mcg.c **** 
 356:../Sources/mcg.c ****   // Wait for clock status bits to update
 357:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1259              		.loc 1 357 0
 1260 0254 3B1C     		mov	r3, r7
 1261 0256 1633     		add	r3, r3, #22
 1262 0258 0022     		mov	r2, #0
 1263 025a 1A80     		strh	r2, [r3]
 1264 025c 0FE0     		b	.L92
 1265              	.L95:
 358:../Sources/mcg.c ****   {
 359:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 1266              		.loc 1 359 0
 1267 025e 244B     		ldr	r3, .L101
 1268 0260 9B79     		ldrb	r3, [r3, #6]
 1269 0262 DBB2     		uxtb	r3, r3
 1270 0264 1A1C     		mov	r2, r3
 1271 0266 0C23     		mov	r3, #12
 1272 0268 1340     		and	r3, r2
 1273 026a 9B08     		lsr	r3, r3, #2
 1274 026c 032B     		cmp	r3, #3
 1275 026e 0ED0     		beq	.L100
 1276              	.L93:
 357:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1277              		.loc 1 357 0
 1278 0270 3B1C     		mov	r3, r7
 1279 0272 1633     		add	r3, r3, #22
 1280 0274 3A1C     		mov	r2, r7
 1281 0276 1632     		add	r2, r2, #22
 1282 0278 1288     		ldrh	r2, [r2]
 1283 027a 0132     		add	r2, r2, #1
 1284 027c 1A80     		strh	r2, [r3]
 1285              	.L92:
 357:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1286              		.loc 1 357 0 is_stmt 0 discriminator 1
 1287 027e 3B1C     		mov	r3, r7
 1288 0280 1633     		add	r3, r3, #22
 1289 0282 0021     		mov	r1, #0
 1290 0284 5A5E     		ldrsh	r2, [r3, r1]
 1291 0286 1F4B     		ldr	r3, .L101+20
 1292 0288 9A42     		cmp	r2, r3
 1293 028a E8DD     		ble	.L95
 1294 028c 00E0     		b	.L94
 1295              	.L100:
 1296              		.loc 1 359 0 is_stmt 1
 1297 028e C046     		mov	r8, r8
 1298              	.L94:
 360:../Sources/mcg.c ****   }
 361:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 1299              		.loc 1 361 0
 1300 0290 174B     		ldr	r3, .L101
 1301 0292 9B79     		ldrb	r3, [r3, #6]
 1302 0294 DBB2     		uxtb	r3, r3
 1303 0296 1A1C     		mov	r2, r3
 1304 0298 0C23     		mov	r3, #12
 1305 029a 1340     		and	r3, r2
 1306 029c 9B08     		lsr	r3, r3, #2
 1307 029e 032B     		cmp	r3, #3
 1308 02a0 01D0     		beq	.L96
 1309              		.loc 1 361 0 is_stmt 0 discriminator 1
 1310 02a2 1B23     		mov	r3, #27
 1311 02a4 1FE0     		b	.L68
 1312              	.L96:
 362:../Sources/mcg.c **** 
 363:../Sources/mcg.c ****   // Now in PEE
 364:../Sources/mcg.c ****   // Use actual PLL settings to calculate PLL frequency
 365:../Sources/mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1313              		.loc 1 365 0 is_stmt 1
 1314 02a6 124B     		ldr	r3, .L101
 1315 02a8 1B79     		ldrb	r3, [r3, #4]
 1316 02aa DAB2     		uxtb	r2, r3
 1317 02ac 1F23     		mov	r3, #31
 1318 02ae 1340     		and	r3, r2
 1319 02b0 DAB2     		uxtb	r2, r3
 1320 02b2 3B1C     		mov	r3, r7
 1321 02b4 0A33     		add	r3, r3, #10
 1322 02b6 0132     		add	r2, r2, #1
 1323 02b8 1A70     		strb	r2, [r3]
 366:../Sources/mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1324              		.loc 1 366 0
 1325 02ba 0D4B     		ldr	r3, .L101
 1326 02bc 5B79     		ldrb	r3, [r3, #5]
 1327 02be DAB2     		uxtb	r2, r3
 1328 02c0 1F23     		mov	r3, #31
 1329 02c2 1340     		and	r3, r2
 1330 02c4 DAB2     		uxtb	r2, r3
 1331 02c6 3B1C     		mov	r3, r7
 1332 02c8 0933     		add	r3, r3, #9
 1333 02ca 1832     		add	r2, r2, #24
 1334 02cc 1A70     		strb	r2, [r3]
 367:../Sources/mcg.c ****   
 368:../Sources/mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 1335              		.loc 1 368 0
 1336 02ce 3B1C     		mov	r3, r7
 1337 02d0 0A33     		add	r3, r3, #10
 1338 02d2 1B78     		ldrb	r3, [r3]
 1339 02d4 7868     		ldr	r0, [r7, #4]
 1340 02d6 191C     		mov	r1, r3
 1341 02d8 FFF7FEFF 		bl	__aeabi_idiv
 1342 02dc 031C     		mov	r3, r0
 1343 02de 3A1C     		mov	r2, r7
 1344 02e0 0932     		add	r2, r2, #9
 1345 02e2 1278     		ldrb	r2, [r2]
 1346 02e4 5343     		mul	r3, r2
 1347              	.L68:
 369:../Sources/mcg.c **** } // new_pll_freq
 1348              		.loc 1 369 0
 1349 02e6 181C     		mov	r0, r3
 1350 02e8 BD46     		mov	sp, r7
 1351 02ea 06B0     		add	sp, sp, #24
 1352              		@ sp needed for prologue
 1353 02ec 80BD     		pop	{r7, pc}
 1354              	.L102:
 1355 02ee C046     		.align	2
 1356              	.L101:
 1357 02f0 00400640 		.word	1074151424
 1358 02f4 7F841E00 		.word	1999999
 1359 02f8 00093D00 		.word	4000000
 1360 02fc FF6BDC02 		.word	47999999
 1361 0300 00E1F505 		.word	100000000
 1362 0304 CF070000 		.word	1999
 1363 0308 9F0F0000 		.word	3999
 1364              		.cfi_endproc
 1365              	.LFE1:
 1367              		.section	.text.pee_pbe,"ax",%progbits
 1368              		.align	2
 1369              		.global	pee_pbe
 1370              		.code	16
 1371              		.thumb_func
 1373              	pee_pbe:
 1374              	.LFB2:
 370:../Sources/mcg.c **** 
 371:../Sources/mcg.c **** 
 372:../Sources/mcg.c **** /********************************************************************/
 373:../Sources/mcg.c **** 
 374:../Sources/mcg.c **** int pee_pbe(int crystal_val)
 375:../Sources/mcg.c **** {
 1375              		.loc 1 375 0
 1376              		.cfi_startproc
 1377 0000 80B5     		push	{r7, lr}
 1378              	.LCFI6:
 1379              		.cfi_def_cfa_offset 8
 1380              		.cfi_offset 7, -8
 1381              		.cfi_offset 14, -4
 1382 0002 84B0     		sub	sp, sp, #16
 1383              	.LCFI7:
 1384              		.cfi_def_cfa_offset 24
 1385 0004 00AF     		add	r7, sp, #0
 1386              	.LCFI8:
 1387              		.cfi_def_cfa_register 7
 1388 0006 7860     		str	r0, [r7, #4]
 376:../Sources/mcg.c ****   short i;
 377:../Sources/mcg.c ****   
 378:../Sources/mcg.c **** // Check MCG is in PEE mode
 379:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 1389              		.loc 1 379 0
 1390 0008 274B     		ldr	r3, .L113
 1391 000a 9B79     		ldrb	r3, [r3, #6]
 1392 000c DBB2     		uxtb	r3, r3
 1393 000e 1A1C     		mov	r2, r3
 1394 0010 0C23     		mov	r3, #12
 1395 0012 1340     		and	r3, r2
 1396 0014 9B08     		lsr	r3, r3, #2
 1397 0016 032B     		cmp	r3, #3
 1398 0018 0DD1     		bne	.L104
 380:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1399              		.loc 1 380 0 discriminator 1
 1400 001a 234B     		ldr	r3, .L113
 1401 001c 9B79     		ldrb	r3, [r3, #6]
 1402 001e DBB2     		uxtb	r3, r3
 1403 0020 1A1C     		mov	r2, r3
 1404 0022 1023     		mov	r3, #16
 1405 0024 1340     		and	r3, r2
 379:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 1406              		.loc 1 379 0 discriminator 1
 1407 0026 06D1     		bne	.L104
 381:../Sources/mcg.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 1408              		.loc 1 381 0 discriminator 1
 1409 0028 1F4B     		ldr	r3, .L113
 1410 002a 9B79     		ldrb	r3, [r3, #6]
 1411 002c DBB2     		uxtb	r3, r3
 1412 002e 1A1C     		mov	r2, r3
 1413 0030 2023     		mov	r3, #32
 1414 0032 1340     		and	r3, r2
 379:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 1415              		.loc 1 379 0 discriminator 1
 1416 0034 01D1     		bne	.L105
 1417              	.L104:
 382:../Sources/mcg.c ****   {
 383:../Sources/mcg.c ****     return 0x8;                                                       // return error code
 1418              		.loc 1 383 0
 1419 0036 0823     		mov	r3, #8
 1420 0038 32E0     		b	.L106
 1421              	.L105:
 384:../Sources/mcg.c ****   } 
 385:../Sources/mcg.c ****   
 386:../Sources/mcg.c **** // As we are running from the PLL by default the PLL and external clock settings are valid
 387:../Sources/mcg.c **** // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext clock 
 388:../Sources/mcg.c **** // As CLKS is already 0 the CLKS value can simply be OR'ed into the register 
 389:../Sources/mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 1422              		.loc 1 389 0
 1423 003a 1B4B     		ldr	r3, .L113
 1424 003c 1A4A     		ldr	r2, .L113
 1425 003e 1278     		ldrb	r2, [r2]
 1426 0040 D2B2     		uxtb	r2, r2
 1427 0042 8021     		mov	r1, #128
 1428 0044 4942     		neg	r1, r1
 1429 0046 0A43     		orr	r2, r1
 1430 0048 D2B2     		uxtb	r2, r2
 1431 004a 1A70     		strb	r2, [r3]
 390:../Sources/mcg.c ****   
 391:../Sources/mcg.c **** // Wait for clock status bits to update 
 392:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1432              		.loc 1 392 0
 1433 004c 3B1C     		mov	r3, r7
 1434 004e 0E33     		add	r3, r3, #14
 1435 0050 0022     		mov	r2, #0
 1436 0052 1A80     		strh	r2, [r3]
 1437 0054 0FE0     		b	.L107
 1438              	.L110:
 393:../Sources/mcg.c ****   {
 394:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 1439              		.loc 1 394 0
 1440 0056 144B     		ldr	r3, .L113
 1441 0058 9B79     		ldrb	r3, [r3, #6]
 1442 005a DBB2     		uxtb	r3, r3
 1443 005c 1A1C     		mov	r2, r3
 1444 005e 0C23     		mov	r3, #12
 1445 0060 1340     		and	r3, r2
 1446 0062 9B08     		lsr	r3, r3, #2
 1447 0064 022B     		cmp	r3, #2
 1448 0066 0ED0     		beq	.L112
 1449              	.L108:
 392:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1450              		.loc 1 392 0
 1451 0068 3B1C     		mov	r3, r7
 1452 006a 0E33     		add	r3, r3, #14
 1453 006c 3A1C     		mov	r2, r7
 1454 006e 0E32     		add	r2, r2, #14
 1455 0070 1288     		ldrh	r2, [r2]
 1456 0072 0132     		add	r2, r2, #1
 1457 0074 1A80     		strh	r2, [r3]
 1458              	.L107:
 392:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1459              		.loc 1 392 0 is_stmt 0 discriminator 1
 1460 0076 3B1C     		mov	r3, r7
 1461 0078 0E33     		add	r3, r3, #14
 1462 007a 0021     		mov	r1, #0
 1463 007c 5A5E     		ldrsh	r2, [r3, r1]
 1464 007e 0B4B     		ldr	r3, .L113+4
 1465 0080 9A42     		cmp	r2, r3
 1466 0082 E8DD     		ble	.L110
 1467 0084 00E0     		b	.L109
 1468              	.L112:
 1469              		.loc 1 394 0 is_stmt 1
 1470 0086 C046     		mov	r8, r8
 1471              	.L109:
 395:../Sources/mcg.c ****   }
 396:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 1472              		.loc 1 396 0
 1473 0088 074B     		ldr	r3, .L113
 1474 008a 9B79     		ldrb	r3, [r3, #6]
 1475 008c DBB2     		uxtb	r3, r3
 1476 008e 1A1C     		mov	r2, r3
 1477 0090 0C23     		mov	r3, #12
 1478 0092 1340     		and	r3, r2
 1479 0094 9B08     		lsr	r3, r3, #2
 1480 0096 022B     		cmp	r3, #2
 1481 0098 01D0     		beq	.L111
 1482              		.loc 1 396 0 is_stmt 0 discriminator 1
 1483 009a 1A23     		mov	r3, #26
 1484 009c 00E0     		b	.L106
 1485              	.L111:
 397:../Sources/mcg.c **** 
 398:../Sources/mcg.c **** // Now in PBE mode  
 399:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 1486              		.loc 1 399 0 is_stmt 1
 1487 009e 7B68     		ldr	r3, [r7, #4]
 1488              	.L106:
 400:../Sources/mcg.c **** } // pee_pbe
 1489              		.loc 1 400 0
 1490 00a0 181C     		mov	r0, r3
 1491 00a2 BD46     		mov	sp, r7
 1492 00a4 04B0     		add	sp, sp, #16
 1493              		@ sp needed for prologue
 1494 00a6 80BD     		pop	{r7, pc}
 1495              	.L114:
 1496              		.align	2
 1497              	.L113:
 1498 00a8 00400640 		.word	1074151424
 1499 00ac CF070000 		.word	1999
 1500              		.cfi_endproc
 1501              	.LFE2:
 1503              		.section	.text.pbe_pee,"ax",%progbits
 1504              		.align	2
 1505              		.global	pbe_pee
 1506              		.code	16
 1507              		.thumb_func
 1509              	pbe_pee:
 1510              	.LFB3:
 401:../Sources/mcg.c **** 
 402:../Sources/mcg.c **** 
 403:../Sources/mcg.c **** int pbe_pee(int crystal_val)
 404:../Sources/mcg.c **** {
 1511              		.loc 1 404 0
 1512              		.cfi_startproc
 1513 0000 80B5     		push	{r7, lr}
 1514              	.LCFI9:
 1515              		.cfi_def_cfa_offset 8
 1516              		.cfi_offset 7, -8
 1517              		.cfi_offset 14, -4
 1518 0002 84B0     		sub	sp, sp, #16
 1519              	.LCFI10:
 1520              		.cfi_def_cfa_offset 24
 1521 0004 00AF     		add	r7, sp, #0
 1522              	.LCFI11:
 1523              		.cfi_def_cfa_register 7
 1524 0006 7860     		str	r0, [r7, #4]
 405:../Sources/mcg.c ****   unsigned char prdiv, vdiv;
 406:../Sources/mcg.c ****   short i;
 407:../Sources/mcg.c **** 
 408:../Sources/mcg.c ****   // Check MCG is in PBE mode
 409:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1525              		.loc 1 409 0
 1526 0008 4C4B     		ldr	r3, .L131
 1527 000a 9B79     		ldrb	r3, [r3, #6]
 1528 000c DBB2     		uxtb	r3, r3
 1529 000e 1A1C     		mov	r2, r3
 1530 0010 0C23     		mov	r3, #12
 1531 0012 1340     		and	r3, r2
 1532 0014 9B08     		lsr	r3, r3, #2
 1533 0016 022B     		cmp	r3, #2
 1534 0018 14D1     		bne	.L116
 410:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1535              		.loc 1 410 0 discriminator 1
 1536 001a 484B     		ldr	r3, .L131
 1537 001c 9B79     		ldrb	r3, [r3, #6]
 1538 001e DBB2     		uxtb	r3, r3
 1539 0020 1A1C     		mov	r2, r3
 1540 0022 1023     		mov	r3, #16
 1541 0024 1340     		and	r3, r2
 409:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1542              		.loc 1 409 0 discriminator 1
 1543 0026 0DD1     		bne	.L116
 411:../Sources/mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1544              		.loc 1 411 0
 1545 0028 444B     		ldr	r3, .L131
 1546 002a 9B79     		ldrb	r3, [r3, #6]
 1547 002c DBB2     		uxtb	r3, r3
 1548 002e 1A1C     		mov	r2, r3
 1549 0030 2023     		mov	r3, #32
 1550 0032 1340     		and	r3, r2
 410:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1551              		.loc 1 410 0
 1552 0034 06D0     		beq	.L116
 412:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1553              		.loc 1 412 0
 1554 0036 414B     		ldr	r3, .L131
 1555 0038 5B78     		ldrb	r3, [r3, #1]
 1556 003a DBB2     		uxtb	r3, r3
 1557 003c 1A1C     		mov	r2, r3
 1558 003e 0223     		mov	r3, #2
 1559 0040 1340     		and	r3, r2
 409:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1560              		.loc 1 409 0
 1561 0042 01D0     		beq	.L117
 1562              	.L116:
 413:../Sources/mcg.c ****   {
 414:../Sources/mcg.c ****     return 0x7;                                                       // return error code
 1563              		.loc 1 414 0
 1564 0044 0723     		mov	r3, #7
 1565 0046 75E0     		b	.L118
 1566              	.L117:
 415:../Sources/mcg.c ****   }
 416:../Sources/mcg.c **** 
 417:../Sources/mcg.c ****   // As the PLL settings have already been checked when PBE mode was enterred they are not checked 
 418:../Sources/mcg.c **** 
 419:../Sources/mcg.c ****   // Check the PLL state before transitioning to PEE mode
 420:../Sources/mcg.c ****   
 421:../Sources/mcg.c ****   // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but g
 422:../Sources/mcg.c ****   // to re-check before switch to use PLL)
 423:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1567              		.loc 1 423 0
 1568 0048 3B1C     		mov	r3, r7
 1569 004a 0E33     		add	r3, r3, #14
 1570 004c 0022     		mov	r2, #0
 1571 004e 1A80     		strh	r2, [r3]
 1572 0050 0DE0     		b	.L119
 1573              	.L122:
 424:../Sources/mcg.c ****   {
 425:../Sources/mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1574              		.loc 1 425 0
 1575 0052 3A4B     		ldr	r3, .L131
 1576 0054 9B79     		ldrb	r3, [r3, #6]
 1577 0056 DBB2     		uxtb	r3, r3
 1578 0058 1A1C     		mov	r2, r3
 1579 005a 4023     		mov	r3, #64
 1580 005c 1340     		and	r3, r2
 1581 005e 0ED1     		bne	.L129
 1582              	.L120:
 423:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1583              		.loc 1 423 0
 1584 0060 3B1C     		mov	r3, r7
 1585 0062 0E33     		add	r3, r3, #14
 1586 0064 3A1C     		mov	r2, r7
 1587 0066 0E32     		add	r2, r2, #14
 1588 0068 1288     		ldrh	r2, [r2]
 1589 006a 0132     		add	r2, r2, #1
 1590 006c 1A80     		strh	r2, [r3]
 1591              	.L119:
 423:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1592              		.loc 1 423 0 is_stmt 0 discriminator 1
 1593 006e 3B1C     		mov	r3, r7
 1594 0070 0E33     		add	r3, r3, #14
 1595 0072 0021     		mov	r1, #0
 1596 0074 5A5E     		ldrsh	r2, [r3, r1]
 1597 0076 324B     		ldr	r3, .L131+4
 1598 0078 9A42     		cmp	r2, r3
 1599 007a EADD     		ble	.L122
 1600 007c 00E0     		b	.L121
 1601              	.L129:
 1602              		.loc 1 425 0 is_stmt 1
 1603 007e C046     		mov	r8, r8
 1604              	.L121:
 426:../Sources/mcg.c ****   }
 427:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1605              		.loc 1 427 0
 1606 0080 2E4B     		ldr	r3, .L131
 1607 0082 9B79     		ldrb	r3, [r3, #6]
 1608 0084 DBB2     		uxtb	r3, r3
 1609 0086 1A1C     		mov	r2, r3
 1610 0088 4023     		mov	r3, #64
 1611 008a 1340     		and	r3, r2
 1612 008c 01D1     		bne	.L123
 1613              		.loc 1 427 0 is_stmt 0 discriminator 1
 1614 008e 4423     		mov	r3, #68
 1615 0090 50E0     		b	.L118
 1616              	.L123:
 428:../Sources/mcg.c ****   // Use actual PLL settings to calculate PLL frequency
 429:../Sources/mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1617              		.loc 1 429 0 is_stmt 1
 1618 0092 2A4B     		ldr	r3, .L131
 1619 0094 1B79     		ldrb	r3, [r3, #4]
 1620 0096 DAB2     		uxtb	r2, r3
 1621 0098 1F23     		mov	r3, #31
 1622 009a 1340     		and	r3, r2
 1623 009c DAB2     		uxtb	r2, r3
 1624 009e 3B1C     		mov	r3, r7
 1625 00a0 0D33     		add	r3, r3, #13
 1626 00a2 0132     		add	r2, r2, #1
 1627 00a4 1A70     		strb	r2, [r3]
 430:../Sources/mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1628              		.loc 1 430 0
 1629 00a6 254B     		ldr	r3, .L131
 1630 00a8 5B79     		ldrb	r3, [r3, #5]
 1631 00aa DAB2     		uxtb	r2, r3
 1632 00ac 1F23     		mov	r3, #31
 1633 00ae 1340     		and	r3, r2
 1634 00b0 DAB2     		uxtb	r2, r3
 1635 00b2 3B1C     		mov	r3, r7
 1636 00b4 0C33     		add	r3, r3, #12
 1637 00b6 1832     		add	r2, r2, #24
 1638 00b8 1A70     		strb	r2, [r3]
 431:../Sources/mcg.c ****   
 432:../Sources/mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 1639              		.loc 1 432 0
 1640 00ba 204B     		ldr	r3, .L131
 1641 00bc 1F4A     		ldr	r2, .L131
 1642 00be 1278     		ldrb	r2, [r2]
 1643 00c0 D1B2     		uxtb	r1, r2
 1644 00c2 3F22     		mov	r2, #63
 1645 00c4 0A40     		and	r2, r1
 1646 00c6 D2B2     		uxtb	r2, r2
 1647 00c8 1A70     		strb	r2, [r3]
 433:../Sources/mcg.c **** 
 434:../Sources/mcg.c ****   // Wait for clock status bits to update
 435:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1648              		.loc 1 435 0
 1649 00ca 3B1C     		mov	r3, r7
 1650 00cc 0E33     		add	r3, r3, #14
 1651 00ce 0022     		mov	r2, #0
 1652 00d0 1A80     		strh	r2, [r3]
 1653 00d2 0FE0     		b	.L124
 1654              	.L127:
 436:../Sources/mcg.c ****   {
 437:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 1655              		.loc 1 437 0
 1656 00d4 194B     		ldr	r3, .L131
 1657 00d6 9B79     		ldrb	r3, [r3, #6]
 1658 00d8 DBB2     		uxtb	r3, r3
 1659 00da 1A1C     		mov	r2, r3
 1660 00dc 0C23     		mov	r3, #12
 1661 00de 1340     		and	r3, r2
 1662 00e0 9B08     		lsr	r3, r3, #2
 1663 00e2 032B     		cmp	r3, #3
 1664 00e4 0ED0     		beq	.L130
 1665              	.L125:
 435:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1666              		.loc 1 435 0
 1667 00e6 3B1C     		mov	r3, r7
 1668 00e8 0E33     		add	r3, r3, #14
 1669 00ea 3A1C     		mov	r2, r7
 1670 00ec 0E32     		add	r2, r2, #14
 1671 00ee 1288     		ldrh	r2, [r2]
 1672 00f0 0132     		add	r2, r2, #1
 1673 00f2 1A80     		strh	r2, [r3]
 1674              	.L124:
 435:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1675              		.loc 1 435 0 is_stmt 0 discriminator 1
 1676 00f4 3B1C     		mov	r3, r7
 1677 00f6 0E33     		add	r3, r3, #14
 1678 00f8 0021     		mov	r1, #0
 1679 00fa 5A5E     		ldrsh	r2, [r3, r1]
 1680 00fc 104B     		ldr	r3, .L131+4
 1681 00fe 9A42     		cmp	r2, r3
 1682 0100 E8DD     		ble	.L127
 1683 0102 00E0     		b	.L126
 1684              	.L130:
 1685              		.loc 1 437 0 is_stmt 1
 1686 0104 C046     		mov	r8, r8
 1687              	.L126:
 438:../Sources/mcg.c ****   }
 439:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 1688              		.loc 1 439 0
 1689 0106 0D4B     		ldr	r3, .L131
 1690 0108 9B79     		ldrb	r3, [r3, #6]
 1691 010a DBB2     		uxtb	r3, r3
 1692 010c 1A1C     		mov	r2, r3
 1693 010e 0C23     		mov	r3, #12
 1694 0110 1340     		and	r3, r2
 1695 0112 9B08     		lsr	r3, r3, #2
 1696 0114 032B     		cmp	r3, #3
 1697 0116 01D0     		beq	.L128
 1698              		.loc 1 439 0 is_stmt 0 discriminator 1
 1699 0118 1B23     		mov	r3, #27
 1700 011a 0BE0     		b	.L118
 1701              	.L128:
 440:../Sources/mcg.c **** 
 441:../Sources/mcg.c ****   // Now in PEE
 442:../Sources/mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 1702              		.loc 1 442 0 is_stmt 1
 1703 011c 3B1C     		mov	r3, r7
 1704 011e 0D33     		add	r3, r3, #13
 1705 0120 1B78     		ldrb	r3, [r3]
 1706 0122 7868     		ldr	r0, [r7, #4]
 1707 0124 191C     		mov	r1, r3
 1708 0126 FFF7FEFF 		bl	__aeabi_idiv
 1709 012a 031C     		mov	r3, r0
 1710 012c 3A1C     		mov	r2, r7
 1711 012e 0C32     		add	r2, r2, #12
 1712 0130 1278     		ldrb	r2, [r2]
 1713 0132 5343     		mul	r3, r2
 1714              	.L118:
 443:../Sources/mcg.c ****   
 444:../Sources/mcg.c **** }  // pbe_pee
 1715              		.loc 1 444 0
 1716 0134 181C     		mov	r0, r3
 1717 0136 BD46     		mov	sp, r7
 1718 0138 04B0     		add	sp, sp, #16
 1719              		@ sp needed for prologue
 1720 013a 80BD     		pop	{r7, pc}
 1721              	.L132:
 1722              		.align	2
 1723              	.L131:
 1724 013c 00400640 		.word	1074151424
 1725 0140 CF070000 		.word	1999
 1726              		.cfi_endproc
 1727              	.LFE3:
 1729              		.section	.text.pbe_fbe,"ax",%progbits
 1730              		.align	2
 1731              		.global	pbe_fbe
 1732              		.code	16
 1733              		.thumb_func
 1735              	pbe_fbe:
 1736              	.LFB4:
 445:../Sources/mcg.c **** 
 446:../Sources/mcg.c **** 
 447:../Sources/mcg.c **** int pbe_fbe(int crystal_val)
 448:../Sources/mcg.c **** {
 1737              		.loc 1 448 0
 1738              		.cfi_startproc
 1739 0000 80B5     		push	{r7, lr}
 1740              	.LCFI12:
 1741              		.cfi_def_cfa_offset 8
 1742              		.cfi_offset 7, -8
 1743              		.cfi_offset 14, -4
 1744 0002 84B0     		sub	sp, sp, #16
 1745              	.LCFI13:
 1746              		.cfi_def_cfa_offset 24
 1747 0004 00AF     		add	r7, sp, #0
 1748              	.LCFI14:
 1749              		.cfi_def_cfa_register 7
 1750 0006 7860     		str	r0, [r7, #4]
 449:../Sources/mcg.c ****   short i;
 450:../Sources/mcg.c ****   
 451:../Sources/mcg.c **** // Check MCG is in PBE mode
 452:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1751              		.loc 1 452 0
 1752 0008 284B     		ldr	r3, .L143
 1753 000a 9B79     		ldrb	r3, [r3, #6]
 1754 000c DBB2     		uxtb	r3, r3
 1755 000e 1A1C     		mov	r2, r3
 1756 0010 0C23     		mov	r3, #12
 1757 0012 1340     		and	r3, r2
 1758 0014 9B08     		lsr	r3, r3, #2
 1759 0016 022B     		cmp	r3, #2
 1760 0018 14D1     		bne	.L134
 453:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1761              		.loc 1 453 0 discriminator 1
 1762 001a 244B     		ldr	r3, .L143
 1763 001c 9B79     		ldrb	r3, [r3, #6]
 1764 001e DBB2     		uxtb	r3, r3
 1765 0020 1A1C     		mov	r2, r3
 1766 0022 1023     		mov	r3, #16
 1767 0024 1340     		and	r3, r2
 452:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1768              		.loc 1 452 0 discriminator 1
 1769 0026 0DD1     		bne	.L134
 454:../Sources/mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1770              		.loc 1 454 0
 1771 0028 204B     		ldr	r3, .L143
 1772 002a 9B79     		ldrb	r3, [r3, #6]
 1773 002c DBB2     		uxtb	r3, r3
 1774 002e 1A1C     		mov	r2, r3
 1775 0030 2023     		mov	r3, #32
 1776 0032 1340     		and	r3, r2
 453:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1777              		.loc 1 453 0
 1778 0034 06D0     		beq	.L134
 455:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1779              		.loc 1 455 0
 1780 0036 1D4B     		ldr	r3, .L143
 1781 0038 5B78     		ldrb	r3, [r3, #1]
 1782 003a DBB2     		uxtb	r3, r3
 1783 003c 1A1C     		mov	r2, r3
 1784 003e 0223     		mov	r3, #2
 1785 0040 1340     		and	r3, r2
 452:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1786              		.loc 1 452 0
 1787 0042 01D0     		beq	.L135
 1788              	.L134:
 456:../Sources/mcg.c ****   {
 457:../Sources/mcg.c ****     return 0x7;                                                       // return error code
 1789              		.loc 1 457 0
 1790 0044 0723     		mov	r3, #7
 1791 0046 2DE0     		b	.L136
 1792              	.L135:
 458:../Sources/mcg.c ****   }
 459:../Sources/mcg.c **** 
 460:../Sources/mcg.c **** // As we are running from the ext clock, by default the external clock settings are valid
 461:../Sources/mcg.c **** // To move to FBE from PBE simply requires the switching of the PLLS mux to disable the PLL 
 462:../Sources/mcg.c ****   
 463:../Sources/mcg.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 1793              		.loc 1 463 0
 1794 0048 184B     		ldr	r3, .L143
 1795 004a 184A     		ldr	r2, .L143
 1796 004c 5279     		ldrb	r2, [r2, #5]
 1797 004e D2B2     		uxtb	r2, r2
 1798 0050 4021     		mov	r1, #64
 1799 0052 8A43     		bic	r2, r1
 1800 0054 D2B2     		uxtb	r2, r2
 1801 0056 5A71     		strb	r2, [r3, #5]
 464:../Sources/mcg.c ****   
 465:../Sources/mcg.c **** // wait for PLLST status bit to set
 466:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1802              		.loc 1 466 0
 1803 0058 3B1C     		mov	r3, r7
 1804 005a 0E33     		add	r3, r3, #14
 1805 005c 0022     		mov	r2, #0
 1806 005e 1A80     		strh	r2, [r3]
 1807 0060 0DE0     		b	.L137
 1808              	.L140:
 467:../Sources/mcg.c ****   {
 468:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1809              		.loc 1 468 0
 1810 0062 124B     		ldr	r3, .L143
 1811 0064 9B79     		ldrb	r3, [r3, #6]
 1812 0066 DBB2     		uxtb	r3, r3
 1813 0068 1A1C     		mov	r2, r3
 1814 006a 2023     		mov	r3, #32
 1815 006c 1340     		and	r3, r2
 1816 006e 0ED0     		beq	.L142
 1817              	.L138:
 466:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1818              		.loc 1 466 0
 1819 0070 3B1C     		mov	r3, r7
 1820 0072 0E33     		add	r3, r3, #14
 1821 0074 3A1C     		mov	r2, r7
 1822 0076 0E32     		add	r2, r2, #14
 1823 0078 1288     		ldrh	r2, [r2]
 1824 007a 0132     		add	r2, r2, #1
 1825 007c 1A80     		strh	r2, [r3]
 1826              	.L137:
 466:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1827              		.loc 1 466 0 is_stmt 0 discriminator 1
 1828 007e 3B1C     		mov	r3, r7
 1829 0080 0E33     		add	r3, r3, #14
 1830 0082 0021     		mov	r1, #0
 1831 0084 5A5E     		ldrsh	r2, [r3, r1]
 1832 0086 0A4B     		ldr	r3, .L143+4
 1833 0088 9A42     		cmp	r2, r3
 1834 008a EADD     		ble	.L140
 1835 008c 00E0     		b	.L139
 1836              	.L142:
 1837              		.loc 1 468 0 is_stmt 1
 1838 008e C046     		mov	r8, r8
 1839              	.L139:
 469:../Sources/mcg.c ****   }
 470:../Sources/mcg.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 1840              		.loc 1 470 0
 1841 0090 064B     		ldr	r3, .L143
 1842 0092 9B79     		ldrb	r3, [r3, #6]
 1843 0094 DBB2     		uxtb	r3, r3
 1844 0096 1A1C     		mov	r2, r3
 1845 0098 2023     		mov	r3, #32
 1846 009a 1340     		and	r3, r2
 1847 009c 01D0     		beq	.L141
 1848              		.loc 1 470 0 is_stmt 0 discriminator 1
 1849 009e 1523     		mov	r3, #21
 1850 00a0 00E0     		b	.L136
 1851              	.L141:
 471:../Sources/mcg.c **** 
 472:../Sources/mcg.c **** // Now in FBE mode  
 473:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency 
 1852              		.loc 1 473 0 is_stmt 1
 1853 00a2 7B68     		ldr	r3, [r7, #4]
 1854              	.L136:
 474:../Sources/mcg.c **** } // pbe_fbe
 1855              		.loc 1 474 0
 1856 00a4 181C     		mov	r0, r3
 1857 00a6 BD46     		mov	sp, r7
 1858 00a8 04B0     		add	sp, sp, #16
 1859              		@ sp needed for prologue
 1860 00aa 80BD     		pop	{r7, pc}
 1861              	.L144:
 1862              		.align	2
 1863              	.L143:
 1864 00ac 00400640 		.word	1074151424
 1865 00b0 CF070000 		.word	1999
 1866              		.cfi_endproc
 1867              	.LFE4:
 1869              		.section	.text.fbe_pbe,"ax",%progbits
 1870              		.align	2
 1871              		.global	fbe_pbe
 1872              		.code	16
 1873              		.thumb_func
 1875              	fbe_pbe:
 1876              	.LFB5:
 475:../Sources/mcg.c **** 
 476:../Sources/mcg.c **** 
 477:../Sources/mcg.c **** /********************************************************************/
 478:../Sources/mcg.c **** /* Functon name : fbe_pbe
 479:../Sources/mcg.c ****  *
 480:../Sources/mcg.c ****  * Mode transition: FBE to PBE mode
 481:../Sources/mcg.c ****  *
 482:../Sources/mcg.c ****  * This function transitions the MCG from FBE mode to PBE mode. 
 483:../Sources/mcg.c ****  * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soo
 484:../Sources/mcg.c ****  * The function requires the desired OSC and PLL be passed in to it for compatibility with the
 485:../Sources/mcg.c ****  * future support of OSC/PLL selection
 486:../Sources/mcg.c ****  *
 487:../Sources/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
 488:../Sources/mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 489:../Sources/mcg.c ****  *                           PLL reference clock frequency
 490:../Sources/mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 491:../Sources/mcg.c ****  *
 492:../Sources/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 493:../Sources/mcg.c ****  */
 494:../Sources/mcg.c **** int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 495:../Sources/mcg.c **** {
 1877              		.loc 1 495 0
 1878              		.cfi_startproc
 1879 0000 80B5     		push	{r7, lr}
 1880              	.LCFI15:
 1881              		.cfi_def_cfa_offset 8
 1882              		.cfi_offset 7, -8
 1883              		.cfi_offset 14, -4
 1884 0002 86B0     		sub	sp, sp, #24
 1885              	.LCFI16:
 1886              		.cfi_def_cfa_offset 32
 1887 0004 00AF     		add	r7, sp, #0
 1888              	.LCFI17:
 1889              		.cfi_def_cfa_register 7
 1890 0006 7860     		str	r0, [r7, #4]
 1891 0008 FB1C     		add	r3, r7, #3
 1892 000a 1970     		strb	r1, [r3]
 1893 000c BB1C     		add	r3, r7, #2
 1894 000e 1A70     		strb	r2, [r3]
 496:../Sources/mcg.c ****   unsigned char temp_reg;
 497:../Sources/mcg.c ****   short i;
 498:../Sources/mcg.c ****   int pll_freq;
 499:../Sources/mcg.c ****   
 500:../Sources/mcg.c **** // Check MCG is in FBE mode
 501:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1895              		.loc 1 501 0
 1896 0010 7D4B     		ldr	r3, .L169
 1897 0012 9B79     		ldrb	r3, [r3, #6]
 1898 0014 DBB2     		uxtb	r3, r3
 1899 0016 1A1C     		mov	r2, r3
 1900 0018 0C23     		mov	r3, #12
 1901 001a 1340     		and	r3, r2
 1902 001c 9B08     		lsr	r3, r3, #2
 1903 001e 022B     		cmp	r3, #2
 1904 0020 14D1     		bne	.L146
 502:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1905              		.loc 1 502 0 discriminator 1
 1906 0022 794B     		ldr	r3, .L169
 1907 0024 9B79     		ldrb	r3, [r3, #6]
 1908 0026 DBB2     		uxtb	r3, r3
 1909 0028 1A1C     		mov	r2, r3
 1910 002a 1023     		mov	r3, #16
 1911 002c 1340     		and	r3, r2
 501:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1912              		.loc 1 501 0 discriminator 1
 1913 002e 0DD1     		bne	.L146
 503:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 1914              		.loc 1 503 0
 1915 0030 754B     		ldr	r3, .L169
 1916 0032 9B79     		ldrb	r3, [r3, #6]
 1917 0034 DBB2     		uxtb	r3, r3
 1918 0036 1A1C     		mov	r2, r3
 1919 0038 2023     		mov	r3, #32
 1920 003a 1340     		and	r3, r2
 502:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1921              		.loc 1 502 0
 1922 003c 06D1     		bne	.L146
 504:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1923              		.loc 1 504 0
 1924 003e 724B     		ldr	r3, .L169
 1925 0040 5B78     		ldrb	r3, [r3, #1]
 1926 0042 DBB2     		uxtb	r3, r3
 1927 0044 1A1C     		mov	r2, r3
 1928 0046 0223     		mov	r3, #2
 1929 0048 1340     		and	r3, r2
 501:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1930              		.loc 1 501 0
 1931 004a 01D0     		beq	.L147
 1932              	.L146:
 505:../Sources/mcg.c ****   {
 506:../Sources/mcg.c ****     return 0x4;                                                       // return error code
 1933              		.loc 1 506 0
 1934 004c 0423     		mov	r3, #4
 1935 004e D6E0     		b	.L148
 1936              	.L147:
 507:../Sources/mcg.c ****   }
 508:../Sources/mcg.c ****   
 509:../Sources/mcg.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 510:../Sources/mcg.c **** 
 511:../Sources/mcg.c **** // Check PLL divider settings are within spec.
 512:../Sources/mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 1937              		.loc 1 512 0
 1938 0050 FB1C     		add	r3, r7, #3
 1939 0052 1B78     		ldrb	r3, [r3]
 1940 0054 5BB2     		sxtb	r3, r3
 1941 0056 002B     		cmp	r3, #0
 1942 0058 04DD     		ble	.L149
 1943              		.loc 1 512 0 is_stmt 0 discriminator 2
 1944 005a FB1C     		add	r3, r7, #3
 1945 005c 1B78     		ldrb	r3, [r3]
 1946 005e 5BB2     		sxtb	r3, r3
 1947 0060 192B     		cmp	r3, #25
 1948 0062 01DD     		ble	.L150
 1949              	.L149:
 1950              		.loc 1 512 0 discriminator 1
 1951 0064 4123     		mov	r3, #65
 1952 0066 CAE0     		b	.L148
 1953              	.L150:
 513:../Sources/mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 1954              		.loc 1 513 0 is_stmt 1
 1955 0068 BB1C     		add	r3, r7, #2
 1956 006a 1B78     		ldrb	r3, [r3]
 1957 006c 5BB2     		sxtb	r3, r3
 1958 006e 172B     		cmp	r3, #23
 1959 0070 04DD     		ble	.L151
 1960              		.loc 1 513 0 is_stmt 0 discriminator 2
 1961 0072 BB1C     		add	r3, r7, #2
 1962 0074 1B78     		ldrb	r3, [r3]
 1963 0076 5BB2     		sxtb	r3, r3
 1964 0078 322B     		cmp	r3, #50
 1965 007a 01DD     		ble	.L152
 1966              	.L151:
 1967              		.loc 1 513 0 discriminator 1
 1968 007c 4223     		mov	r3, #66
 1969 007e BEE0     		b	.L148
 1970              	.L152:
 514:../Sources/mcg.c ****   
 515:../Sources/mcg.c **** // Check PLL reference clock frequency is within spec.
 516:../Sources/mcg.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 1971              		.loc 1 516 0 is_stmt 1
 1972 0080 FB1C     		add	r3, r7, #3
 1973 0082 1B78     		ldrb	r3, [r3]
 1974 0084 5BB2     		sxtb	r3, r3
 1975 0086 7868     		ldr	r0, [r7, #4]
 1976 0088 191C     		mov	r1, r3
 1977 008a FFF7FEFF 		bl	__aeabi_idiv
 1978 008e 031C     		mov	r3, r0
 1979 0090 1A1C     		mov	r2, r3
 1980 0092 5E4B     		ldr	r3, .L169+4
 1981 0094 9A42     		cmp	r2, r3
 1982 0096 0BDD     		ble	.L153
 1983              		.loc 1 516 0 is_stmt 0 discriminator 2
 1984 0098 FB1C     		add	r3, r7, #3
 1985 009a 1B78     		ldrb	r3, [r3]
 1986 009c 5BB2     		sxtb	r3, r3
 1987 009e 7868     		ldr	r0, [r7, #4]
 1988 00a0 191C     		mov	r1, r3
 1989 00a2 FFF7FEFF 		bl	__aeabi_idiv
 1990 00a6 031C     		mov	r3, r0
 1991 00a8 1A1C     		mov	r2, r3
 1992 00aa 594B     		ldr	r3, .L169+8
 1993 00ac 9A42     		cmp	r2, r3
 1994 00ae 01DD     		ble	.L154
 1995              	.L153:
 1996              		.loc 1 516 0 discriminator 1
 1997 00b0 4323     		mov	r3, #67
 1998 00b2 A4E0     		b	.L148
 1999              	.L154:
 517:../Sources/mcg.c ****        
 518:../Sources/mcg.c **** // Check PLL output frequency is within spec.
 519:../Sources/mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 2000              		.loc 1 519 0 is_stmt 1
 2001 00b4 FB1C     		add	r3, r7, #3
 2002 00b6 1B78     		ldrb	r3, [r3]
 2003 00b8 5BB2     		sxtb	r3, r3
 2004 00ba 7868     		ldr	r0, [r7, #4]
 2005 00bc 191C     		mov	r1, r3
 2006 00be FFF7FEFF 		bl	__aeabi_idiv
 2007 00c2 031C     		mov	r3, r0
 2008 00c4 BA1C     		add	r2, r7, #2
 2009 00c6 1278     		ldrb	r2, [r2]
 2010 00c8 52B2     		sxtb	r2, r2
 2011 00ca 5343     		mul	r3, r2
 2012 00cc 3B61     		str	r3, [r7, #16]
 520:../Sources/mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 2013              		.loc 1 520 0
 2014 00ce 3A69     		ldr	r2, [r7, #16]
 2015 00d0 504B     		ldr	r3, .L169+12
 2016 00d2 9A42     		cmp	r2, r3
 2017 00d4 03DD     		ble	.L155
 2018              		.loc 1 520 0 is_stmt 0 discriminator 2
 2019 00d6 3A69     		ldr	r2, [r7, #16]
 2020 00d8 4F4B     		ldr	r3, .L169+16
 2021 00da 9A42     		cmp	r2, r3
 2022 00dc 01DD     		ble	.L156
 2023              	.L155:
 2024              		.loc 1 520 0 discriminator 1
 2025 00de 4523     		mov	r3, #69
 2026 00e0 8DE0     		b	.L148
 2027              	.L156:
 521:../Sources/mcg.c **** 
 522:../Sources/mcg.c ****   // Configure MCG_C5
 523:../Sources/mcg.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 524:../Sources/mcg.c ****   temp_reg = MCG_C5;
 2028              		.loc 1 524 0 is_stmt 1
 2029 00e2 494A     		ldr	r2, .L169
 2030 00e4 3B1C     		mov	r3, r7
 2031 00e6 0F33     		add	r3, r3, #15
 2032 00e8 1279     		ldrb	r2, [r2, #4]
 2033 00ea 1A70     		strb	r2, [r3]
 525:../Sources/mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 2034              		.loc 1 525 0
 2035 00ec 3B1C     		mov	r3, r7
 2036 00ee 0F33     		add	r3, r3, #15
 2037 00f0 3A1C     		mov	r2, r7
 2038 00f2 0F32     		add	r2, r2, #15
 2039 00f4 1278     		ldrb	r2, [r2]
 2040 00f6 1F21     		mov	r1, #31
 2041 00f8 8A43     		bic	r2, r1
 2042 00fa 1A70     		strb	r2, [r3]
 526:../Sources/mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 2043              		.loc 1 526 0
 2044 00fc FB1C     		add	r3, r7, #3
 2045 00fe 1B78     		ldrb	r3, [r3]
 2046 0100 013B     		sub	r3, r3, #1
 2047 0102 DAB2     		uxtb	r2, r3
 2048 0104 1F23     		mov	r3, #31
 2049 0106 1340     		and	r3, r2
 2050 0108 D9B2     		uxtb	r1, r3
 2051 010a 3B1C     		mov	r3, r7
 2052 010c 0F33     		add	r3, r3, #15
 2053 010e 3A1C     		mov	r2, r7
 2054 0110 0F32     		add	r2, r2, #15
 2055 0112 1278     		ldrb	r2, [r2]
 2056 0114 0A43     		orr	r2, r1
 2057 0116 1A70     		strb	r2, [r3]
 527:../Sources/mcg.c ****   MCG_C5 = temp_reg;
 2058              		.loc 1 527 0
 2059 0118 3B4B     		ldr	r3, .L169
 2060 011a 3A1C     		mov	r2, r7
 2061 011c 0F32     		add	r2, r2, #15
 2062 011e 1278     		ldrb	r2, [r2]
 2063 0120 1A71     		strb	r2, [r3, #4]
 528:../Sources/mcg.c **** 
 529:../Sources/mcg.c ****   // Configure MCG_C6
 530:../Sources/mcg.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 531:../Sources/mcg.c ****   // The clock monitor is not enabled here as it has likely been enabled previously and so the valu
 532:../Sources/mcg.c ****   // is not altered here.
 533:../Sources/mcg.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 534:../Sources/mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 2064              		.loc 1 534 0
 2065 0122 394A     		ldr	r2, .L169
 2066 0124 3B1C     		mov	r3, r7
 2067 0126 0F33     		add	r3, r3, #15
 2068 0128 5279     		ldrb	r2, [r2, #5]
 2069 012a 1A70     		strb	r2, [r3]
 535:../Sources/mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 2070              		.loc 1 535 0
 2071 012c 3B1C     		mov	r3, r7
 2072 012e 0F33     		add	r3, r3, #15
 2073 0130 3A1C     		mov	r2, r7
 2074 0132 0F32     		add	r2, r2, #15
 2075 0134 1278     		ldrb	r2, [r2]
 2076 0136 1F21     		mov	r1, #31
 2077 0138 8A43     		bic	r2, r1
 2078 013a 1A70     		strb	r2, [r3]
 536:../Sources/mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 2079              		.loc 1 536 0
 2080 013c BB1C     		add	r3, r7, #2
 2081 013e 1B78     		ldrb	r3, [r3]
 2082 0140 183B     		sub	r3, r3, #24
 2083 0142 DAB2     		uxtb	r2, r3
 2084 0144 1F23     		mov	r3, #31
 2085 0146 1340     		and	r3, r2
 2086 0148 DAB2     		uxtb	r2, r3
 2087 014a 3B1C     		mov	r3, r7
 2088 014c 0F33     		add	r3, r3, #15
 2089 014e 1B78     		ldrb	r3, [r3]
 2090 0150 1343     		orr	r3, r2
 2091 0152 DAB2     		uxtb	r2, r3
 2092 0154 3B1C     		mov	r3, r7
 2093 0156 0F33     		add	r3, r3, #15
 2094 0158 4021     		mov	r1, #64
 2095 015a 0A43     		orr	r2, r1
 2096 015c 1A70     		strb	r2, [r3]
 537:../Sources/mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 2097              		.loc 1 537 0
 2098 015e 2A4B     		ldr	r3, .L169
 2099 0160 3A1C     		mov	r2, r7
 2100 0162 0F32     		add	r2, r2, #15
 2101 0164 1278     		ldrb	r2, [r2]
 2102 0166 5A71     		strb	r2, [r3, #5]
 538:../Sources/mcg.c ****   
 539:../Sources/mcg.c ****   // wait for PLLST status bit to set
 540:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2103              		.loc 1 540 0
 2104 0168 3B1C     		mov	r3, r7
 2105 016a 1633     		add	r3, r3, #22
 2106 016c 0022     		mov	r2, #0
 2107 016e 1A80     		strh	r2, [r3]
 2108 0170 0DE0     		b	.L157
 2109              	.L160:
 541:../Sources/mcg.c ****   {
 542:../Sources/mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 2110              		.loc 1 542 0
 2111 0172 254B     		ldr	r3, .L169
 2112 0174 9B79     		ldrb	r3, [r3, #6]
 2113 0176 DBB2     		uxtb	r3, r3
 2114 0178 1A1C     		mov	r2, r3
 2115 017a 2023     		mov	r3, #32
 2116 017c 1340     		and	r3, r2
 2117 017e 0ED1     		bne	.L167
 2118              	.L158:
 540:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2119              		.loc 1 540 0
 2120 0180 3B1C     		mov	r3, r7
 2121 0182 1633     		add	r3, r3, #22
 2122 0184 3A1C     		mov	r2, r7
 2123 0186 1632     		add	r2, r2, #22
 2124 0188 1288     		ldrh	r2, [r2]
 2125 018a 0132     		add	r2, r2, #1
 2126 018c 1A80     		strh	r2, [r3]
 2127              	.L157:
 540:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2128              		.loc 1 540 0 is_stmt 0 discriminator 1
 2129 018e 3B1C     		mov	r3, r7
 2130 0190 1633     		add	r3, r3, #22
 2131 0192 0021     		mov	r1, #0
 2132 0194 5A5E     		ldrsh	r2, [r3, r1]
 2133 0196 214B     		ldr	r3, .L169+20
 2134 0198 9A42     		cmp	r2, r3
 2135 019a EADD     		ble	.L160
 2136 019c 00E0     		b	.L159
 2137              	.L167:
 2138              		.loc 1 542 0 is_stmt 1
 2139 019e C046     		mov	r8, r8
 2140              	.L159:
 543:../Sources/mcg.c ****   }
 544:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 2141              		.loc 1 544 0
 2142 01a0 194B     		ldr	r3, .L169
 2143 01a2 9B79     		ldrb	r3, [r3, #6]
 2144 01a4 DBB2     		uxtb	r3, r3
 2145 01a6 1A1C     		mov	r2, r3
 2146 01a8 2023     		mov	r3, #32
 2147 01aa 1340     		and	r3, r2
 2148 01ac 01D1     		bne	.L161
 2149              		.loc 1 544 0 is_stmt 0 discriminator 1
 2150 01ae 1623     		mov	r3, #22
 2151 01b0 25E0     		b	.L148
 2152              	.L161:
 545:../Sources/mcg.c **** 
 546:../Sources/mcg.c ****   // Wait for LOCK bit to set
 547:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2153              		.loc 1 547 0 is_stmt 1
 2154 01b2 3B1C     		mov	r3, r7
 2155 01b4 1633     		add	r3, r3, #22
 2156 01b6 0022     		mov	r2, #0
 2157 01b8 1A80     		strh	r2, [r3]
 2158 01ba 0DE0     		b	.L162
 2159              	.L165:
 548:../Sources/mcg.c ****   {
 549:../Sources/mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 2160              		.loc 1 549 0
 2161 01bc 124B     		ldr	r3, .L169
 2162 01be 9B79     		ldrb	r3, [r3, #6]
 2163 01c0 DBB2     		uxtb	r3, r3
 2164 01c2 1A1C     		mov	r2, r3
 2165 01c4 4023     		mov	r3, #64
 2166 01c6 1340     		and	r3, r2
 2167 01c8 0ED1     		bne	.L168
 2168              	.L163:
 547:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2169              		.loc 1 547 0
 2170 01ca 3B1C     		mov	r3, r7
 2171 01cc 1633     		add	r3, r3, #22
 2172 01ce 3A1C     		mov	r2, r7
 2173 01d0 1632     		add	r2, r2, #22
 2174 01d2 1288     		ldrh	r2, [r2]
 2175 01d4 0132     		add	r2, r2, #1
 2176 01d6 1A80     		strh	r2, [r3]
 2177              	.L162:
 547:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2178              		.loc 1 547 0 is_stmt 0 discriminator 1
 2179 01d8 3B1C     		mov	r3, r7
 2180 01da 1633     		add	r3, r3, #22
 2181 01dc 0021     		mov	r1, #0
 2182 01de 5A5E     		ldrsh	r2, [r3, r1]
 2183 01e0 0E4B     		ldr	r3, .L169+20
 2184 01e2 9A42     		cmp	r2, r3
 2185 01e4 EADD     		ble	.L165
 2186 01e6 00E0     		b	.L164
 2187              	.L168:
 2188              		.loc 1 549 0 is_stmt 1
 2189 01e8 C046     		mov	r8, r8
 2190              	.L164:
 550:../Sources/mcg.c ****   }
 551:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 2191              		.loc 1 551 0
 2192 01ea 074B     		ldr	r3, .L169
 2193 01ec 9B79     		ldrb	r3, [r3, #6]
 2194 01ee DBB2     		uxtb	r3, r3
 2195 01f0 1A1C     		mov	r2, r3
 2196 01f2 4023     		mov	r3, #64
 2197 01f4 1340     		and	r3, r2
 2198 01f6 01D1     		bne	.L166
 2199              		.loc 1 551 0 is_stmt 0 discriminator 1
 2200 01f8 4423     		mov	r3, #68
 2201 01fa 00E0     		b	.L148
 2202              	.L166:
 552:../Sources/mcg.c ****     
 553:../Sources/mcg.c **** // now in PBE 
 554:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 2203              		.loc 1 554 0 is_stmt 1
 2204 01fc 7B68     		ldr	r3, [r7, #4]
 2205              	.L148:
 555:../Sources/mcg.c **** } // fbe_pbe
 2206              		.loc 1 555 0
 2207 01fe 181C     		mov	r0, r3
 2208 0200 BD46     		mov	sp, r7
 2209 0202 06B0     		add	sp, sp, #24
 2210              		@ sp needed for prologue
 2211 0204 80BD     		pop	{r7, pc}
 2212              	.L170:
 2213 0206 C046     		.align	2
 2214              	.L169:
 2215 0208 00400640 		.word	1074151424
 2216 020c 7F841E00 		.word	1999999
 2217 0210 00093D00 		.word	4000000
 2218 0214 FF6BDC02 		.word	47999999
 2219 0218 00E1F505 		.word	100000000
 2220 021c CF070000 		.word	1999
 2221              		.cfi_endproc
 2222              	.LFE5:
 2224              		.section	.text.pbe_blpe,"ax",%progbits
 2225              		.align	2
 2226              		.global	pbe_blpe
 2227              		.code	16
 2228              		.thumb_func
 2230              	pbe_blpe:
 2231              	.LFB6:
 556:../Sources/mcg.c **** 
 557:../Sources/mcg.c **** 
 558:../Sources/mcg.c **** int pbe_blpe(int crystal_val)
 559:../Sources/mcg.c **** {
 2232              		.loc 1 559 0
 2233              		.cfi_startproc
 2234 0000 80B5     		push	{r7, lr}
 2235              	.LCFI18:
 2236              		.cfi_def_cfa_offset 8
 2237              		.cfi_offset 7, -8
 2238              		.cfi_offset 14, -4
 2239 0002 82B0     		sub	sp, sp, #8
 2240              	.LCFI19:
 2241              		.cfi_def_cfa_offset 16
 2242 0004 00AF     		add	r7, sp, #0
 2243              	.LCFI20:
 2244              		.cfi_def_cfa_register 7
 2245 0006 7860     		str	r0, [r7, #4]
 560:../Sources/mcg.c **** // Check MCG is in PBE mode
 561:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2246              		.loc 1 561 0
 2247 0008 164B     		ldr	r3, .L175
 2248 000a 9B79     		ldrb	r3, [r3, #6]
 2249 000c DBB2     		uxtb	r3, r3
 2250 000e 1A1C     		mov	r2, r3
 2251 0010 0C23     		mov	r3, #12
 2252 0012 1340     		and	r3, r2
 2253 0014 9B08     		lsr	r3, r3, #2
 2254 0016 022B     		cmp	r3, #2
 2255 0018 14D1     		bne	.L172
 562:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2256              		.loc 1 562 0 discriminator 1
 2257 001a 124B     		ldr	r3, .L175
 2258 001c 9B79     		ldrb	r3, [r3, #6]
 2259 001e DBB2     		uxtb	r3, r3
 2260 0020 1A1C     		mov	r2, r3
 2261 0022 1023     		mov	r3, #16
 2262 0024 1340     		and	r3, r2
 561:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2263              		.loc 1 561 0 discriminator 1
 2264 0026 0DD1     		bne	.L172
 563:../Sources/mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 2265              		.loc 1 563 0
 2266 0028 0E4B     		ldr	r3, .L175
 2267 002a 9B79     		ldrb	r3, [r3, #6]
 2268 002c DBB2     		uxtb	r3, r3
 2269 002e 1A1C     		mov	r2, r3
 2270 0030 2023     		mov	r3, #32
 2271 0032 1340     		and	r3, r2
 562:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2272              		.loc 1 562 0
 2273 0034 06D0     		beq	.L172
 564:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2274              		.loc 1 564 0
 2275 0036 0B4B     		ldr	r3, .L175
 2276 0038 5B78     		ldrb	r3, [r3, #1]
 2277 003a DBB2     		uxtb	r3, r3
 2278 003c 1A1C     		mov	r2, r3
 2279 003e 0223     		mov	r3, #2
 2280 0040 1340     		and	r3, r2
 561:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2281              		.loc 1 561 0
 2282 0042 01D0     		beq	.L173
 2283              	.L172:
 565:../Sources/mcg.c ****   {
 566:../Sources/mcg.c ****     return 0x7;                                                       // return error code
 2284              		.loc 1 566 0
 2285 0044 0723     		mov	r3, #7
 2286 0046 08E0     		b	.L174
 2287              	.L173:
 567:../Sources/mcg.c ****   }
 568:../Sources/mcg.c ****   
 569:../Sources/mcg.c **** // To enter BLPE mode the LP bit must be set, disabling the PLL  
 570:../Sources/mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 2288              		.loc 1 570 0
 2289 0048 064B     		ldr	r3, .L175
 2290 004a 064A     		ldr	r2, .L175
 2291 004c 5278     		ldrb	r2, [r2, #1]
 2292 004e D2B2     		uxtb	r2, r2
 2293 0050 0221     		mov	r1, #2
 2294 0052 0A43     		orr	r2, r1
 2295 0054 D2B2     		uxtb	r2, r2
 2296 0056 5A70     		strb	r2, [r3, #1]
 571:../Sources/mcg.c ****   
 572:../Sources/mcg.c **** // Now in BLPE mode
 573:../Sources/mcg.c ****   return crystal_val;  
 2297              		.loc 1 573 0
 2298 0058 7B68     		ldr	r3, [r7, #4]
 2299              	.L174:
 574:../Sources/mcg.c **** } // pbe_blpe
 2300              		.loc 1 574 0
 2301 005a 181C     		mov	r0, r3
 2302 005c BD46     		mov	sp, r7
 2303 005e 02B0     		add	sp, sp, #8
 2304              		@ sp needed for prologue
 2305 0060 80BD     		pop	{r7, pc}
 2306              	.L176:
 2307 0062 C046     		.align	2
 2308              	.L175:
 2309 0064 00400640 		.word	1074151424
 2310              		.cfi_endproc
 2311              	.LFE6:
 2313              		.section	.text.blpe_pbe,"ax",%progbits
 2314              		.align	2
 2315              		.global	blpe_pbe
 2316              		.code	16
 2317              		.thumb_func
 2319              	blpe_pbe:
 2320              	.LFB7:
 575:../Sources/mcg.c **** 
 576:../Sources/mcg.c **** 
 577:../Sources/mcg.c **** // ************************************************************************************************
 578:../Sources/mcg.c **** // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been
 579:../Sources/mcg.c **** // previously configured correctly. That is why this general purpose driver has the PLL settings as
 580:../Sources/mcg.c **** // passed parameters.
 581:../Sources/mcg.c **** // ************************************************************************************************
 582:../Sources/mcg.c **** int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 583:../Sources/mcg.c **** {
 2321              		.loc 1 583 0
 2322              		.cfi_startproc
 2323 0000 80B5     		push	{r7, lr}
 2324              	.LCFI21:
 2325              		.cfi_def_cfa_offset 8
 2326              		.cfi_offset 7, -8
 2327              		.cfi_offset 14, -4
 2328 0002 84B0     		sub	sp, sp, #16
 2329              	.LCFI22:
 2330              		.cfi_def_cfa_offset 24
 2331 0004 00AF     		add	r7, sp, #0
 2332              	.LCFI23:
 2333              		.cfi_def_cfa_register 7
 2334 0006 7860     		str	r0, [r7, #4]
 2335 0008 FB1C     		add	r3, r7, #3
 2336 000a 1970     		strb	r1, [r3]
 2337 000c BB1C     		add	r3, r7, #2
 2338 000e 1A70     		strb	r2, [r3]
 584:../Sources/mcg.c ****   unsigned char temp_reg;
 585:../Sources/mcg.c ****   short i;
 586:../Sources/mcg.c ****   
 587:../Sources/mcg.c **** // Check MCG is in BLPE mode
 588:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2339              		.loc 1 588 0
 2340 0010 724B     		ldr	r3, .L199
 2341 0012 9B79     		ldrb	r3, [r3, #6]
 2342 0014 DBB2     		uxtb	r3, r3
 2343 0016 1A1C     		mov	r2, r3
 2344 0018 0C23     		mov	r3, #12
 2345 001a 1340     		and	r3, r2
 2346 001c 9B08     		lsr	r3, r3, #2
 2347 001e 022B     		cmp	r3, #2
 2348 0020 0DD1     		bne	.L178
 589:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2349              		.loc 1 589 0 discriminator 1
 2350 0022 6E4B     		ldr	r3, .L199
 2351 0024 9B79     		ldrb	r3, [r3, #6]
 2352 0026 DBB2     		uxtb	r3, r3
 2353 0028 1A1C     		mov	r2, r3
 2354 002a 1023     		mov	r3, #16
 2355 002c 1340     		and	r3, r2
 588:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2356              		.loc 1 588 0 discriminator 1
 2357 002e 06D1     		bne	.L178
 590:../Sources/mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 2358              		.loc 1 590 0 discriminator 1
 2359 0030 6A4B     		ldr	r3, .L199
 2360 0032 5B78     		ldrb	r3, [r3, #1]
 2361 0034 DBB2     		uxtb	r3, r3
 2362 0036 1A1C     		mov	r2, r3
 2363 0038 0223     		mov	r3, #2
 2364 003a 1340     		and	r3, r2
 588:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2365              		.loc 1 588 0 discriminator 1
 2366 003c 01D1     		bne	.L179
 2367              	.L178:
 591:../Sources/mcg.c ****   {
 592:../Sources/mcg.c ****     return 0x6;                                                       // return error code
 2368              		.loc 1 592 0
 2369 003e 0623     		mov	r3, #6
 2370 0040 C7E0     		b	.L180
 2371              	.L179:
 593:../Sources/mcg.c ****   }
 594:../Sources/mcg.c ****   
 595:../Sources/mcg.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 596:../Sources/mcg.c **** 
 597:../Sources/mcg.c **** // Check PLL divider settings are within spec.
 598:../Sources/mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 2372              		.loc 1 598 0
 2373 0042 FB1C     		add	r3, r7, #3
 2374 0044 1B78     		ldrb	r3, [r3]
 2375 0046 5BB2     		sxtb	r3, r3
 2376 0048 002B     		cmp	r3, #0
 2377 004a 04DD     		ble	.L181
 2378              		.loc 1 598 0 is_stmt 0 discriminator 2
 2379 004c FB1C     		add	r3, r7, #3
 2380 004e 1B78     		ldrb	r3, [r3]
 2381 0050 5BB2     		sxtb	r3, r3
 2382 0052 192B     		cmp	r3, #25
 2383 0054 01DD     		ble	.L182
 2384              	.L181:
 2385              		.loc 1 598 0 discriminator 1
 2386 0056 4123     		mov	r3, #65
 2387 0058 BBE0     		b	.L180
 2388              	.L182:
 599:../Sources/mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 2389              		.loc 1 599 0 is_stmt 1
 2390 005a BB1C     		add	r3, r7, #2
 2391 005c 1B78     		ldrb	r3, [r3]
 2392 005e 5BB2     		sxtb	r3, r3
 2393 0060 172B     		cmp	r3, #23
 2394 0062 04DD     		ble	.L183
 2395              		.loc 1 599 0 is_stmt 0 discriminator 2
 2396 0064 BB1C     		add	r3, r7, #2
 2397 0066 1B78     		ldrb	r3, [r3]
 2398 0068 5BB2     		sxtb	r3, r3
 2399 006a 322B     		cmp	r3, #50
 2400 006c 01DD     		ble	.L184
 2401              	.L183:
 2402              		.loc 1 599 0 discriminator 1
 2403 006e 4223     		mov	r3, #66
 2404 0070 AFE0     		b	.L180
 2405              	.L184:
 600:../Sources/mcg.c ****   
 601:../Sources/mcg.c **** // Check PLL reference clock frequency is within spec.
 602:../Sources/mcg.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 2406              		.loc 1 602 0 is_stmt 1
 2407 0072 FB1C     		add	r3, r7, #3
 2408 0074 1B78     		ldrb	r3, [r3]
 2409 0076 5BB2     		sxtb	r3, r3
 2410 0078 7868     		ldr	r0, [r7, #4]
 2411 007a 191C     		mov	r1, r3
 2412 007c FFF7FEFF 		bl	__aeabi_idiv
 2413 0080 031C     		mov	r3, r0
 2414 0082 1A1C     		mov	r2, r3
 2415 0084 564B     		ldr	r3, .L199+4
 2416 0086 9A42     		cmp	r2, r3
 2417 0088 0BDD     		ble	.L185
 2418              		.loc 1 602 0 is_stmt 0 discriminator 2
 2419 008a FB1C     		add	r3, r7, #3
 2420 008c 1B78     		ldrb	r3, [r3]
 2421 008e 5BB2     		sxtb	r3, r3
 2422 0090 7868     		ldr	r0, [r7, #4]
 2423 0092 191C     		mov	r1, r3
 2424 0094 FFF7FEFF 		bl	__aeabi_idiv
 2425 0098 031C     		mov	r3, r0
 2426 009a 1A1C     		mov	r2, r3
 2427 009c 514B     		ldr	r3, .L199+8
 2428 009e 9A42     		cmp	r2, r3
 2429 00a0 01DD     		ble	.L186
 2430              	.L185:
 2431              		.loc 1 602 0 discriminator 1
 2432 00a2 4323     		mov	r3, #67
 2433 00a4 95E0     		b	.L180
 2434              	.L186:
 603:../Sources/mcg.c ****        
 604:../Sources/mcg.c **** // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
 605:../Sources/mcg.c **** 
 606:../Sources/mcg.c **** // Configure MCG_C5
 607:../Sources/mcg.c **** // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code
 608:../Sources/mcg.c ****   temp_reg = MCG_C5;
 2435              		.loc 1 608 0 is_stmt 1
 2436 00a6 4D4A     		ldr	r2, .L199
 2437 00a8 3B1C     		mov	r3, r7
 2438 00aa 0D33     		add	r3, r3, #13
 2439 00ac 1279     		ldrb	r2, [r2, #4]
 2440 00ae 1A70     		strb	r2, [r3]
 609:../Sources/mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 2441              		.loc 1 609 0
 2442 00b0 3B1C     		mov	r3, r7
 2443 00b2 0D33     		add	r3, r3, #13
 2444 00b4 3A1C     		mov	r2, r7
 2445 00b6 0D32     		add	r2, r2, #13
 2446 00b8 1278     		ldrb	r2, [r2]
 2447 00ba 1F21     		mov	r1, #31
 2448 00bc 8A43     		bic	r2, r1
 2449 00be 1A70     		strb	r2, [r3]
 610:../Sources/mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 2450              		.loc 1 610 0
 2451 00c0 FB1C     		add	r3, r7, #3
 2452 00c2 1B78     		ldrb	r3, [r3]
 2453 00c4 013B     		sub	r3, r3, #1
 2454 00c6 DAB2     		uxtb	r2, r3
 2455 00c8 1F23     		mov	r3, #31
 2456 00ca 1340     		and	r3, r2
 2457 00cc D9B2     		uxtb	r1, r3
 2458 00ce 3B1C     		mov	r3, r7
 2459 00d0 0D33     		add	r3, r3, #13
 2460 00d2 3A1C     		mov	r2, r7
 2461 00d4 0D32     		add	r2, r2, #13
 2462 00d6 1278     		ldrb	r2, [r2]
 2463 00d8 0A43     		orr	r2, r1
 2464 00da 1A70     		strb	r2, [r3]
 611:../Sources/mcg.c ****   MCG_C5 = temp_reg;
 2465              		.loc 1 611 0
 2466 00dc 3F4B     		ldr	r3, .L199
 2467 00de 3A1C     		mov	r2, r7
 2468 00e0 0D32     		add	r2, r2, #13
 2469 00e2 1278     		ldrb	r2, [r2]
 2470 00e4 1A71     		strb	r2, [r3, #4]
 612:../Sources/mcg.c **** 
 613:../Sources/mcg.c **** // Configure MCG_C6
 614:../Sources/mcg.c **** // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 615:../Sources/mcg.c **** // The clock monitor is not enabled here as it has likely been enabled previously and so the value 
 616:../Sources/mcg.c **** // is not altered here.
 617:../Sources/mcg.c **** // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 618:../Sources/mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 2471              		.loc 1 618 0
 2472 00e6 3D4A     		ldr	r2, .L199
 2473 00e8 3B1C     		mov	r3, r7
 2474 00ea 0D33     		add	r3, r3, #13
 2475 00ec 5279     		ldrb	r2, [r2, #5]
 2476 00ee 1A70     		strb	r2, [r3]
 619:../Sources/mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 2477              		.loc 1 619 0
 2478 00f0 3B1C     		mov	r3, r7
 2479 00f2 0D33     		add	r3, r3, #13
 2480 00f4 3A1C     		mov	r2, r7
 2481 00f6 0D32     		add	r2, r2, #13
 2482 00f8 1278     		ldrb	r2, [r2]
 2483 00fa 1F21     		mov	r1, #31
 2484 00fc 8A43     		bic	r2, r1
 2485 00fe 1A70     		strb	r2, [r3]
 620:../Sources/mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 2486              		.loc 1 620 0
 2487 0100 BB1C     		add	r3, r7, #2
 2488 0102 1B78     		ldrb	r3, [r3]
 2489 0104 183B     		sub	r3, r3, #24
 2490 0106 DAB2     		uxtb	r2, r3
 2491 0108 1F23     		mov	r3, #31
 2492 010a 1340     		and	r3, r2
 2493 010c DAB2     		uxtb	r2, r3
 2494 010e 3B1C     		mov	r3, r7
 2495 0110 0D33     		add	r3, r3, #13
 2496 0112 1B78     		ldrb	r3, [r3]
 2497 0114 1343     		orr	r3, r2
 2498 0116 DAB2     		uxtb	r2, r3
 2499 0118 3B1C     		mov	r3, r7
 2500 011a 0D33     		add	r3, r3, #13
 2501 011c 4021     		mov	r1, #64
 2502 011e 0A43     		orr	r2, r1
 2503 0120 1A70     		strb	r2, [r3]
 621:../Sources/mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 2504              		.loc 1 621 0
 2505 0122 2E4B     		ldr	r3, .L199
 2506 0124 3A1C     		mov	r2, r7
 2507 0126 0D32     		add	r2, r2, #13
 2508 0128 1278     		ldrb	r2, [r2]
 2509 012a 5A71     		strb	r2, [r3, #5]
 622:../Sources/mcg.c ****   
 623:../Sources/mcg.c **** // Now that PLL is configured, LP is cleared to enable the PLL
 624:../Sources/mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 2510              		.loc 1 624 0
 2511 012c 2B4B     		ldr	r3, .L199
 2512 012e 2B4A     		ldr	r2, .L199
 2513 0130 5278     		ldrb	r2, [r2, #1]
 2514 0132 D2B2     		uxtb	r2, r2
 2515 0134 0221     		mov	r1, #2
 2516 0136 8A43     		bic	r2, r1
 2517 0138 D2B2     		uxtb	r2, r2
 2518 013a 5A70     		strb	r2, [r3, #1]
 625:../Sources/mcg.c ****   
 626:../Sources/mcg.c **** // wait for PLLST status bit to set
 627:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2519              		.loc 1 627 0
 2520 013c 3B1C     		mov	r3, r7
 2521 013e 0E33     		add	r3, r3, #14
 2522 0140 0022     		mov	r2, #0
 2523 0142 1A80     		strh	r2, [r3]
 2524 0144 0DE0     		b	.L187
 2525              	.L190:
 628:../Sources/mcg.c ****   {
 629:../Sources/mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 2526              		.loc 1 629 0
 2527 0146 254B     		ldr	r3, .L199
 2528 0148 9B79     		ldrb	r3, [r3, #6]
 2529 014a DBB2     		uxtb	r3, r3
 2530 014c 1A1C     		mov	r2, r3
 2531 014e 2023     		mov	r3, #32
 2532 0150 1340     		and	r3, r2
 2533 0152 0ED1     		bne	.L197
 2534              	.L188:
 627:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2535              		.loc 1 627 0
 2536 0154 3B1C     		mov	r3, r7
 2537 0156 0E33     		add	r3, r3, #14
 2538 0158 3A1C     		mov	r2, r7
 2539 015a 0E32     		add	r2, r2, #14
 2540 015c 1288     		ldrh	r2, [r2]
 2541 015e 0132     		add	r2, r2, #1
 2542 0160 1A80     		strh	r2, [r3]
 2543              	.L187:
 627:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2544              		.loc 1 627 0 is_stmt 0 discriminator 1
 2545 0162 3B1C     		mov	r3, r7
 2546 0164 0E33     		add	r3, r3, #14
 2547 0166 0021     		mov	r1, #0
 2548 0168 5A5E     		ldrsh	r2, [r3, r1]
 2549 016a 1F4B     		ldr	r3, .L199+12
 2550 016c 9A42     		cmp	r2, r3
 2551 016e EADD     		ble	.L190
 2552 0170 00E0     		b	.L189
 2553              	.L197:
 2554              		.loc 1 629 0 is_stmt 1
 2555 0172 C046     		mov	r8, r8
 2556              	.L189:
 630:../Sources/mcg.c ****   }
 631:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 2557              		.loc 1 631 0
 2558 0174 194B     		ldr	r3, .L199
 2559 0176 9B79     		ldrb	r3, [r3, #6]
 2560 0178 DBB2     		uxtb	r3, r3
 2561 017a 1A1C     		mov	r2, r3
 2562 017c 2023     		mov	r3, #32
 2563 017e 1340     		and	r3, r2
 2564 0180 01D1     		bne	.L191
 2565              		.loc 1 631 0 is_stmt 0 discriminator 1
 2566 0182 1623     		mov	r3, #22
 2567 0184 25E0     		b	.L180
 2568              	.L191:
 632:../Sources/mcg.c **** 
 633:../Sources/mcg.c **** // Wait for LOCK bit to set
 634:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2569              		.loc 1 634 0 is_stmt 1
 2570 0186 3B1C     		mov	r3, r7
 2571 0188 0E33     		add	r3, r3, #14
 2572 018a 0022     		mov	r2, #0
 2573 018c 1A80     		strh	r2, [r3]
 2574 018e 0DE0     		b	.L192
 2575              	.L195:
 635:../Sources/mcg.c ****   {
 636:../Sources/mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 2576              		.loc 1 636 0
 2577 0190 124B     		ldr	r3, .L199
 2578 0192 9B79     		ldrb	r3, [r3, #6]
 2579 0194 DBB2     		uxtb	r3, r3
 2580 0196 1A1C     		mov	r2, r3
 2581 0198 4023     		mov	r3, #64
 2582 019a 1340     		and	r3, r2
 2583 019c 0ED1     		bne	.L198
 2584              	.L193:
 634:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2585              		.loc 1 634 0
 2586 019e 3B1C     		mov	r3, r7
 2587 01a0 0E33     		add	r3, r3, #14
 2588 01a2 3A1C     		mov	r2, r7
 2589 01a4 0E32     		add	r2, r2, #14
 2590 01a6 1288     		ldrh	r2, [r2]
 2591 01a8 0132     		add	r2, r2, #1
 2592 01aa 1A80     		strh	r2, [r3]
 2593              	.L192:
 634:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2594              		.loc 1 634 0 is_stmt 0 discriminator 1
 2595 01ac 3B1C     		mov	r3, r7
 2596 01ae 0E33     		add	r3, r3, #14
 2597 01b0 0021     		mov	r1, #0
 2598 01b2 5A5E     		ldrsh	r2, [r3, r1]
 2599 01b4 0C4B     		ldr	r3, .L199+12
 2600 01b6 9A42     		cmp	r2, r3
 2601 01b8 EADD     		ble	.L195
 2602 01ba 00E0     		b	.L194
 2603              	.L198:
 2604              		.loc 1 636 0 is_stmt 1
 2605 01bc C046     		mov	r8, r8
 2606              	.L194:
 637:../Sources/mcg.c ****   }
 638:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 2607              		.loc 1 638 0
 2608 01be 074B     		ldr	r3, .L199
 2609 01c0 9B79     		ldrb	r3, [r3, #6]
 2610 01c2 DBB2     		uxtb	r3, r3
 2611 01c4 1A1C     		mov	r2, r3
 2612 01c6 4023     		mov	r3, #64
 2613 01c8 1340     		and	r3, r2
 2614 01ca 01D1     		bne	.L196
 2615              		.loc 1 638 0 is_stmt 0 discriminator 1
 2616 01cc 4423     		mov	r3, #68
 2617 01ce 00E0     		b	.L180
 2618              	.L196:
 639:../Sources/mcg.c **** 
 640:../Sources/mcg.c **** // now in PBE 
 641:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 2619              		.loc 1 641 0 is_stmt 1
 2620 01d0 7B68     		ldr	r3, [r7, #4]
 2621              	.L180:
 642:../Sources/mcg.c **** } // blpe_pbe
 2622              		.loc 1 642 0
 2623 01d2 181C     		mov	r0, r3
 2624 01d4 BD46     		mov	sp, r7
 2625 01d6 04B0     		add	sp, sp, #16
 2626              		@ sp needed for prologue
 2627 01d8 80BD     		pop	{r7, pc}
 2628              	.L200:
 2629 01da C046     		.align	2
 2630              	.L199:
 2631 01dc 00400640 		.word	1074151424
 2632 01e0 7F841E00 		.word	1999999
 2633 01e4 00093D00 		.word	4000000
 2634 01e8 CF070000 		.word	1999
 2635              		.cfi_endproc
 2636              	.LFE7:
 2638              		.section	.text.blpe_fbe,"ax",%progbits
 2639              		.align	2
 2640              		.global	blpe_fbe
 2641              		.code	16
 2642              		.thumb_func
 2644              	blpe_fbe:
 2645              	.LFB8:
 643:../Sources/mcg.c **** 
 644:../Sources/mcg.c **** 
 645:../Sources/mcg.c **** int blpe_fbe(int crystal_val)
 646:../Sources/mcg.c **** {
 2646              		.loc 1 646 0
 2647              		.cfi_startproc
 2648 0000 80B5     		push	{r7, lr}
 2649              	.LCFI24:
 2650              		.cfi_def_cfa_offset 8
 2651              		.cfi_offset 7, -8
 2652              		.cfi_offset 14, -4
 2653 0002 84B0     		sub	sp, sp, #16
 2654              	.LCFI25:
 2655              		.cfi_def_cfa_offset 24
 2656 0004 00AF     		add	r7, sp, #0
 2657              	.LCFI26:
 2658              		.cfi_def_cfa_register 7
 2659 0006 7860     		str	r0, [r7, #4]
 647:../Sources/mcg.c ****   short i;
 648:../Sources/mcg.c ****   
 649:../Sources/mcg.c **** // Check MCG is in BLPE mode
 650:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2660              		.loc 1 650 0
 2661 0008 294B     		ldr	r3, .L211
 2662 000a 9B79     		ldrb	r3, [r3, #6]
 2663 000c DBB2     		uxtb	r3, r3
 2664 000e 1A1C     		mov	r2, r3
 2665 0010 0C23     		mov	r3, #12
 2666 0012 1340     		and	r3, r2
 2667 0014 9B08     		lsr	r3, r3, #2
 2668 0016 022B     		cmp	r3, #2
 2669 0018 0DD1     		bne	.L202
 651:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2670              		.loc 1 651 0 discriminator 1
 2671 001a 254B     		ldr	r3, .L211
 2672 001c 9B79     		ldrb	r3, [r3, #6]
 2673 001e DBB2     		uxtb	r3, r3
 2674 0020 1A1C     		mov	r2, r3
 2675 0022 1023     		mov	r3, #16
 2676 0024 1340     		and	r3, r2
 650:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2677              		.loc 1 650 0 discriminator 1
 2678 0026 06D1     		bne	.L202
 652:../Sources/mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 2679              		.loc 1 652 0 discriminator 1
 2680 0028 214B     		ldr	r3, .L211
 2681 002a 5B78     		ldrb	r3, [r3, #1]
 2682 002c DBB2     		uxtb	r3, r3
 2683 002e 1A1C     		mov	r2, r3
 2684 0030 0223     		mov	r3, #2
 2685 0032 1340     		and	r3, r2
 650:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2686              		.loc 1 650 0 discriminator 1
 2687 0034 01D1     		bne	.L203
 2688              	.L202:
 653:../Sources/mcg.c ****   {
 654:../Sources/mcg.c ****     return 0x6;                                                       // return error code
 2689              		.loc 1 654 0
 2690 0036 0623     		mov	r3, #6
 2691 0038 35E0     		b	.L204
 2692              	.L203:
 655:../Sources/mcg.c ****   }
 656:../Sources/mcg.c ****  
 657:../Sources/mcg.c **** // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be cle
 658:../Sources/mcg.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
 2693              		.loc 1 658 0
 2694 003a 1D4B     		ldr	r3, .L211
 2695 003c 1C4A     		ldr	r2, .L211
 2696 003e 5279     		ldrb	r2, [r2, #5]
 2697 0040 D2B2     		uxtb	r2, r2
 2698 0042 4021     		mov	r1, #64
 2699 0044 8A43     		bic	r2, r1
 2700 0046 D2B2     		uxtb	r2, r2
 2701 0048 5A71     		strb	r2, [r3, #5]
 659:../Sources/mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
 2702              		.loc 1 659 0
 2703 004a 194B     		ldr	r3, .L211
 2704 004c 184A     		ldr	r2, .L211
 2705 004e 5278     		ldrb	r2, [r2, #1]
 2706 0050 D2B2     		uxtb	r2, r2
 2707 0052 0221     		mov	r1, #2
 2708 0054 8A43     		bic	r2, r1
 2709 0056 D2B2     		uxtb	r2, r2
 2710 0058 5A70     		strb	r2, [r3, #1]
 660:../Sources/mcg.c **** 
 661:../Sources/mcg.c **** // wait for PLLST status bit to clear
 662:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2711              		.loc 1 662 0
 2712 005a 3B1C     		mov	r3, r7
 2713 005c 0E33     		add	r3, r3, #14
 2714 005e 0022     		mov	r2, #0
 2715 0060 1A80     		strh	r2, [r3]
 2716 0062 0DE0     		b	.L205
 2717              	.L208:
 663:../Sources/mcg.c ****   {
 664:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 2718              		.loc 1 664 0
 2719 0064 124B     		ldr	r3, .L211
 2720 0066 9B79     		ldrb	r3, [r3, #6]
 2721 0068 DBB2     		uxtb	r3, r3
 2722 006a 1A1C     		mov	r2, r3
 2723 006c 2023     		mov	r3, #32
 2724 006e 1340     		and	r3, r2
 2725 0070 0ED0     		beq	.L210
 2726              	.L206:
 662:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2727              		.loc 1 662 0
 2728 0072 3B1C     		mov	r3, r7
 2729 0074 0E33     		add	r3, r3, #14
 2730 0076 3A1C     		mov	r2, r7
 2731 0078 0E32     		add	r2, r2, #14
 2732 007a 1288     		ldrh	r2, [r2]
 2733 007c 0132     		add	r2, r2, #1
 2734 007e 1A80     		strh	r2, [r3]
 2735              	.L205:
 662:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2736              		.loc 1 662 0 is_stmt 0 discriminator 1
 2737 0080 3B1C     		mov	r3, r7
 2738 0082 0E33     		add	r3, r3, #14
 2739 0084 0021     		mov	r1, #0
 2740 0086 5A5E     		ldrsh	r2, [r3, r1]
 2741 0088 0A4B     		ldr	r3, .L211+4
 2742 008a 9A42     		cmp	r2, r3
 2743 008c EADD     		ble	.L208
 2744 008e 00E0     		b	.L207
 2745              	.L210:
 2746              		.loc 1 664 0 is_stmt 1
 2747 0090 C046     		mov	r8, r8
 2748              	.L207:
 665:../Sources/mcg.c ****   }
 666:../Sources/mcg.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 2749              		.loc 1 666 0
 2750 0092 074B     		ldr	r3, .L211
 2751 0094 9B79     		ldrb	r3, [r3, #6]
 2752 0096 DBB2     		uxtb	r3, r3
 2753 0098 1A1C     		mov	r2, r3
 2754 009a 2023     		mov	r3, #32
 2755 009c 1340     		and	r3, r2
 2756 009e 01D0     		beq	.L209
 2757              		.loc 1 666 0 is_stmt 0 discriminator 1
 2758 00a0 1523     		mov	r3, #21
 2759 00a2 00E0     		b	.L204
 2760              	.L209:
 667:../Sources/mcg.c ****   
 668:../Sources/mcg.c **** // now in FBE mode
 669:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 2761              		.loc 1 669 0 is_stmt 1
 2762 00a4 7B68     		ldr	r3, [r7, #4]
 2763              	.L204:
 670:../Sources/mcg.c **** } // blpe_fbe
 2764              		.loc 1 670 0
 2765 00a6 181C     		mov	r0, r3
 2766 00a8 BD46     		mov	sp, r7
 2767 00aa 04B0     		add	sp, sp, #16
 2768              		@ sp needed for prologue
 2769 00ac 80BD     		pop	{r7, pc}
 2770              	.L212:
 2771 00ae C046     		.align	2
 2772              	.L211:
 2773 00b0 00400640 		.word	1074151424
 2774 00b4 CF070000 		.word	1999
 2775              		.cfi_endproc
 2776              	.LFE8:
 2778              		.section	.text.fbe_blpe,"ax",%progbits
 2779              		.align	2
 2780              		.global	fbe_blpe
 2781              		.code	16
 2782              		.thumb_func
 2784              	fbe_blpe:
 2785              	.LFB9:
 671:../Sources/mcg.c **** 
 672:../Sources/mcg.c **** 
 673:../Sources/mcg.c **** int fbe_blpe(int crystal_val)
 674:../Sources/mcg.c **** {
 2786              		.loc 1 674 0
 2787              		.cfi_startproc
 2788 0000 80B5     		push	{r7, lr}
 2789              	.LCFI27:
 2790              		.cfi_def_cfa_offset 8
 2791              		.cfi_offset 7, -8
 2792              		.cfi_offset 14, -4
 2793 0002 82B0     		sub	sp, sp, #8
 2794              	.LCFI28:
 2795              		.cfi_def_cfa_offset 16
 2796 0004 00AF     		add	r7, sp, #0
 2797              	.LCFI29:
 2798              		.cfi_def_cfa_register 7
 2799 0006 7860     		str	r0, [r7, #4]
 675:../Sources/mcg.c **** // Check MCG is in FBE mode
 676:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2800              		.loc 1 676 0
 2801 0008 164B     		ldr	r3, .L217
 2802 000a 9B79     		ldrb	r3, [r3, #6]
 2803 000c DBB2     		uxtb	r3, r3
 2804 000e 1A1C     		mov	r2, r3
 2805 0010 0C23     		mov	r3, #12
 2806 0012 1340     		and	r3, r2
 2807 0014 9B08     		lsr	r3, r3, #2
 2808 0016 022B     		cmp	r3, #2
 2809 0018 14D1     		bne	.L214
 677:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2810              		.loc 1 677 0 discriminator 1
 2811 001a 124B     		ldr	r3, .L217
 2812 001c 9B79     		ldrb	r3, [r3, #6]
 2813 001e DBB2     		uxtb	r3, r3
 2814 0020 1A1C     		mov	r2, r3
 2815 0022 1023     		mov	r3, #16
 2816 0024 1340     		and	r3, r2
 676:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2817              		.loc 1 676 0 discriminator 1
 2818 0026 0DD1     		bne	.L214
 678:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2819              		.loc 1 678 0
 2820 0028 0E4B     		ldr	r3, .L217
 2821 002a 9B79     		ldrb	r3, [r3, #6]
 2822 002c DBB2     		uxtb	r3, r3
 2823 002e 1A1C     		mov	r2, r3
 2824 0030 2023     		mov	r3, #32
 2825 0032 1340     		and	r3, r2
 677:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2826              		.loc 1 677 0
 2827 0034 06D1     		bne	.L214
 679:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2828              		.loc 1 679 0
 2829 0036 0B4B     		ldr	r3, .L217
 2830 0038 5B78     		ldrb	r3, [r3, #1]
 2831 003a DBB2     		uxtb	r3, r3
 2832 003c 1A1C     		mov	r2, r3
 2833 003e 0223     		mov	r3, #2
 2834 0040 1340     		and	r3, r2
 676:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2835              		.loc 1 676 0
 2836 0042 01D0     		beq	.L215
 2837              	.L214:
 680:../Sources/mcg.c ****   {
 681:../Sources/mcg.c ****     return 0x4;                                                       // return error code
 2838              		.loc 1 681 0
 2839 0044 0423     		mov	r3, #4
 2840 0046 08E0     		b	.L216
 2841              	.L215:
 682:../Sources/mcg.c ****   }
 683:../Sources/mcg.c ****  
 684:../Sources/mcg.c **** // To move from FBE to BLPE the LP bit must be set
 685:../Sources/mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
 2842              		.loc 1 685 0
 2843 0048 064B     		ldr	r3, .L217
 2844 004a 064A     		ldr	r2, .L217
 2845 004c 5278     		ldrb	r2, [r2, #1]
 2846 004e D2B2     		uxtb	r2, r2
 2847 0050 0221     		mov	r1, #2
 2848 0052 0A43     		orr	r2, r1
 2849 0054 D2B2     		uxtb	r2, r2
 2850 0056 5A70     		strb	r2, [r3, #1]
 686:../Sources/mcg.c ****  
 687:../Sources/mcg.c **** // now in FBE mode
 688:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 2851              		.loc 1 688 0
 2852 0058 7B68     		ldr	r3, [r7, #4]
 2853              	.L216:
 689:../Sources/mcg.c **** } // fbe_blpe
 2854              		.loc 1 689 0
 2855 005a 181C     		mov	r0, r3
 2856 005c BD46     		mov	sp, r7
 2857 005e 02B0     		add	sp, sp, #8
 2858              		@ sp needed for prologue
 2859 0060 80BD     		pop	{r7, pc}
 2860              	.L218:
 2861 0062 C046     		.align	2
 2862              	.L217:
 2863 0064 00400640 		.word	1074151424
 2864              		.cfi_endproc
 2865              	.LFE9:
 2867              		.section	.text.fbe_fei,"ax",%progbits
 2868              		.align	2
 2869              		.global	fbe_fei
 2870              		.code	16
 2871              		.thumb_func
 2873              	fbe_fei:
 2874              	.LFB10:
 690:../Sources/mcg.c **** 
 691:../Sources/mcg.c **** 
 692:../Sources/mcg.c **** int fbe_fei(int slow_irc_freq)
 693:../Sources/mcg.c **** {
 2875              		.loc 1 693 0
 2876              		.cfi_startproc
 2877 0000 80B5     		push	{r7, lr}
 2878              	.LCFI30:
 2879              		.cfi_def_cfa_offset 8
 2880              		.cfi_offset 7, -8
 2881              		.cfi_offset 14, -4
 2882 0002 86B0     		sub	sp, sp, #24
 2883              	.LCFI31:
 2884              		.cfi_def_cfa_offset 32
 2885 0004 00AF     		add	r7, sp, #0
 2886              	.LCFI32:
 2887              		.cfi_def_cfa_register 7
 2888 0006 7860     		str	r0, [r7, #4]
 694:../Sources/mcg.c ****   unsigned char temp_reg;
 695:../Sources/mcg.c ****   short i;
 696:../Sources/mcg.c ****   int mcg_out;
 697:../Sources/mcg.c ****   
 698:../Sources/mcg.c **** // Check MCG is in FBE mode
 699:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2889              		.loc 1 699 0
 2890 0008 534B     		ldr	r3, .L238
 2891 000a 9B79     		ldrb	r3, [r3, #6]
 2892 000c DBB2     		uxtb	r3, r3
 2893 000e 1A1C     		mov	r2, r3
 2894 0010 0C23     		mov	r3, #12
 2895 0012 1340     		and	r3, r2
 2896 0014 9B08     		lsr	r3, r3, #2
 2897 0016 022B     		cmp	r3, #2
 2898 0018 14D1     		bne	.L220
 700:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2899              		.loc 1 700 0 discriminator 1
 2900 001a 4F4B     		ldr	r3, .L238
 2901 001c 9B79     		ldrb	r3, [r3, #6]
 2902 001e DBB2     		uxtb	r3, r3
 2903 0020 1A1C     		mov	r2, r3
 2904 0022 1023     		mov	r3, #16
 2905 0024 1340     		and	r3, r2
 699:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2906              		.loc 1 699 0 discriminator 1
 2907 0026 0DD1     		bne	.L220
 701:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2908              		.loc 1 701 0
 2909 0028 4B4B     		ldr	r3, .L238
 2910 002a 9B79     		ldrb	r3, [r3, #6]
 2911 002c DBB2     		uxtb	r3, r3
 2912 002e 1A1C     		mov	r2, r3
 2913 0030 2023     		mov	r3, #32
 2914 0032 1340     		and	r3, r2
 700:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2915              		.loc 1 700 0
 2916 0034 06D1     		bne	.L220
 702:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2917              		.loc 1 702 0
 2918 0036 484B     		ldr	r3, .L238
 2919 0038 5B78     		ldrb	r3, [r3, #1]
 2920 003a DBB2     		uxtb	r3, r3
 2921 003c 1A1C     		mov	r2, r3
 2922 003e 0223     		mov	r3, #2
 2923 0040 1340     		and	r3, r2
 699:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2924              		.loc 1 699 0
 2925 0042 01D0     		beq	.L221
 2926              	.L220:
 703:../Sources/mcg.c ****   {
 704:../Sources/mcg.c ****     return 0x4;                                                       // return error code
 2927              		.loc 1 704 0
 2928 0044 0423     		mov	r3, #4
 2929 0046 83E0     		b	.L222
 2930              	.L221:
 705:../Sources/mcg.c ****   }
 706:../Sources/mcg.c **** 
 707:../Sources/mcg.c **** // Check IRC frequency is within spec.
 708:../Sources/mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 2931              		.loc 1 708 0
 2932 0048 7A68     		ldr	r2, [r7, #4]
 2933 004a 444B     		ldr	r3, .L238+4
 2934 004c 9A42     		cmp	r2, r3
 2935 004e 03DD     		ble	.L223
 2936              		.loc 1 708 0 is_stmt 0 discriminator 1
 2937 0050 7A68     		ldr	r2, [r7, #4]
 2938 0052 434B     		ldr	r3, .L238+8
 2939 0054 9A42     		cmp	r2, r3
 2940 0056 01DD     		ble	.L224
 2941              	.L223:
 709:../Sources/mcg.c ****   {
 710:../Sources/mcg.c ****     return 0x31;
 2942              		.loc 1 710 0 is_stmt 1
 2943 0058 3123     		mov	r3, #49
 2944 005a 79E0     		b	.L222
 2945              	.L224:
 711:../Sources/mcg.c ****   }
 712:../Sources/mcg.c ****   
 713:../Sources/mcg.c **** // Check resulting FLL frequency 
 714:../Sources/mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
 2946              		.loc 1 714 0
 2947 005c 7B68     		ldr	r3, [r7, #4]
 2948 005e 181C     		mov	r0, r3
 2949 0060 FFF7FEFF 		bl	fll_freq
 2950 0064 031C     		mov	r3, r0
 2951 0066 3B61     		str	r3, [r7, #16]
 715:../Sources/mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 2952              		.loc 1 715 0
 2953 0068 3B69     		ldr	r3, [r7, #16]
 2954 006a 3B2B     		cmp	r3, #59
 2955 006c 01DC     		bgt	.L225
 2956              		.loc 1 715 0 is_stmt 0 discriminator 1
 2957 006e 3B69     		ldr	r3, [r7, #16]
 2958 0070 6EE0     		b	.L222
 2959              	.L225:
 716:../Sources/mcg.c **** 
 717:../Sources/mcg.c **** // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
 718:../Sources/mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 2960              		.loc 1 718 0 is_stmt 1
 2961 0072 394B     		ldr	r3, .L238
 2962 0074 384A     		ldr	r2, .L238
 2963 0076 5279     		ldrb	r2, [r2, #5]
 2964 0078 D2B2     		uxtb	r2, r2
 2965 007a 2021     		mov	r1, #32
 2966 007c 8A43     		bic	r2, r1
 2967 007e D2B2     		uxtb	r2, r2
 2968 0080 5A71     		strb	r2, [r3, #5]
 719:../Sources/mcg.c ****   
 720:../Sources/mcg.c **** // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
 721:../Sources/mcg.c ****   temp_reg = MCG_C1;
 2969              		.loc 1 721 0
 2970 0082 354A     		ldr	r2, .L238
 2971 0084 3B1C     		mov	r3, r7
 2972 0086 0F33     		add	r3, r3, #15
 2973 0088 1278     		ldrb	r2, [r2]
 2974 008a 1A70     		strb	r2, [r3]
 722:../Sources/mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 2975              		.loc 1 722 0
 2976 008c 3B1C     		mov	r3, r7
 2977 008e 0F33     		add	r3, r3, #15
 2978 0090 3A1C     		mov	r2, r7
 2979 0092 0F32     		add	r2, r2, #15
 2980 0094 1178     		ldrb	r1, [r2]
 2981 0096 3F22     		mov	r2, #63
 2982 0098 0A40     		and	r2, r1
 2983 009a 1A70     		strb	r2, [r3]
 723:../Sources/mcg.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 2984              		.loc 1 723 0
 2985 009c 3B1C     		mov	r3, r7
 2986 009e 0F33     		add	r3, r3, #15
 2987 00a0 3A1C     		mov	r2, r7
 2988 00a2 0F32     		add	r2, r2, #15
 2989 00a4 1278     		ldrb	r2, [r2]
 2990 00a6 0421     		mov	r1, #4
 2991 00a8 0A43     		orr	r2, r1
 2992 00aa 1A70     		strb	r2, [r3]
 724:../Sources/mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 2993              		.loc 1 724 0
 2994 00ac 2A4B     		ldr	r3, .L238
 2995 00ae 3A1C     		mov	r2, r7
 2996 00b0 0F32     		add	r2, r2, #15
 2997 00b2 1278     		ldrb	r2, [r2]
 2998 00b4 1A70     		strb	r2, [r3]
 725:../Sources/mcg.c ****   
 726:../Sources/mcg.c **** // wait for Reference clock Status bit to set
 727:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2999              		.loc 1 727 0
 3000 00b6 3B1C     		mov	r3, r7
 3001 00b8 1633     		add	r3, r3, #22
 3002 00ba 0022     		mov	r2, #0
 3003 00bc 1A80     		strh	r2, [r3]
 3004 00be 0DE0     		b	.L226
 3005              	.L229:
 728:../Sources/mcg.c ****   {
 729:../Sources/mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3006              		.loc 1 729 0
 3007 00c0 254B     		ldr	r3, .L238
 3008 00c2 9B79     		ldrb	r3, [r3, #6]
 3009 00c4 DBB2     		uxtb	r3, r3
 3010 00c6 1A1C     		mov	r2, r3
 3011 00c8 1023     		mov	r3, #16
 3012 00ca 1340     		and	r3, r2
 3013 00cc 0ED1     		bne	.L236
 3014              	.L227:
 727:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3015              		.loc 1 727 0
 3016 00ce 3B1C     		mov	r3, r7
 3017 00d0 1633     		add	r3, r3, #22
 3018 00d2 3A1C     		mov	r2, r7
 3019 00d4 1632     		add	r2, r2, #22
 3020 00d6 1288     		ldrh	r2, [r2]
 3021 00d8 0132     		add	r2, r2, #1
 3022 00da 1A80     		strh	r2, [r3]
 3023              	.L226:
 727:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3024              		.loc 1 727 0 is_stmt 0 discriminator 1
 3025 00dc 3B1C     		mov	r3, r7
 3026 00de 1633     		add	r3, r3, #22
 3027 00e0 0021     		mov	r1, #0
 3028 00e2 5A5E     		ldrsh	r2, [r3, r1]
 3029 00e4 1F4B     		ldr	r3, .L238+12
 3030 00e6 9A42     		cmp	r2, r3
 3031 00e8 EADD     		ble	.L229
 3032 00ea 00E0     		b	.L228
 3033              	.L236:
 3034              		.loc 1 729 0 is_stmt 1
 3035 00ec C046     		mov	r8, r8
 3036              	.L228:
 730:../Sources/mcg.c ****   }
 731:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 3037              		.loc 1 731 0
 3038 00ee 1A4B     		ldr	r3, .L238
 3039 00f0 9B79     		ldrb	r3, [r3, #6]
 3040 00f2 DBB2     		uxtb	r3, r3
 3041 00f4 1A1C     		mov	r2, r3
 3042 00f6 1023     		mov	r3, #16
 3043 00f8 1340     		and	r3, r2
 3044 00fa 01D1     		bne	.L230
 3045              		.loc 1 731 0 is_stmt 0 discriminator 1
 3046 00fc 1223     		mov	r3, #18
 3047 00fe 27E0     		b	.L222
 3048              	.L230:
 732:../Sources/mcg.c ****   
 733:../Sources/mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
 734:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3049              		.loc 1 734 0 is_stmt 1
 3050 0100 3B1C     		mov	r3, r7
 3051 0102 1633     		add	r3, r3, #22
 3052 0104 0022     		mov	r2, #0
 3053 0106 1A80     		strh	r2, [r3]
 3054 0108 0EE0     		b	.L231
 3055              	.L234:
 735:../Sources/mcg.c ****   {
 736:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 3056              		.loc 1 736 0
 3057 010a 134B     		ldr	r3, .L238
 3058 010c 9B79     		ldrb	r3, [r3, #6]
 3059 010e DBB2     		uxtb	r3, r3
 3060 0110 1A1C     		mov	r2, r3
 3061 0112 0C23     		mov	r3, #12
 3062 0114 1340     		and	r3, r2
 3063 0116 9B08     		lsr	r3, r3, #2
 3064 0118 0ED0     		beq	.L237
 3065              	.L232:
 734:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3066              		.loc 1 734 0
 3067 011a 3B1C     		mov	r3, r7
 3068 011c 1633     		add	r3, r3, #22
 3069 011e 3A1C     		mov	r2, r7
 3070 0120 1632     		add	r2, r2, #22
 3071 0122 1288     		ldrh	r2, [r2]
 3072 0124 0132     		add	r2, r2, #1
 3073 0126 1A80     		strh	r2, [r3]
 3074              	.L231:
 734:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3075              		.loc 1 734 0 is_stmt 0 discriminator 1
 3076 0128 3B1C     		mov	r3, r7
 3077 012a 1633     		add	r3, r3, #22
 3078 012c 0021     		mov	r1, #0
 3079 012e 5A5E     		ldrsh	r2, [r3, r1]
 3080 0130 0C4B     		ldr	r3, .L238+12
 3081 0132 9A42     		cmp	r2, r3
 3082 0134 E9DD     		ble	.L234
 3083 0136 00E0     		b	.L233
 3084              	.L237:
 3085              		.loc 1 736 0 is_stmt 1
 3086 0138 C046     		mov	r8, r8
 3087              	.L233:
 737:../Sources/mcg.c ****   }
 738:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is re
 3088              		.loc 1 738 0
 3089 013a 074B     		ldr	r3, .L238
 3090 013c 9B79     		ldrb	r3, [r3, #6]
 3091 013e DBB2     		uxtb	r3, r3
 3092 0140 1A1C     		mov	r2, r3
 3093 0142 0C23     		mov	r3, #12
 3094 0144 1340     		and	r3, r2
 3095 0146 9B08     		lsr	r3, r3, #2
 3096 0148 01D0     		beq	.L235
 3097              		.loc 1 738 0 is_stmt 0 discriminator 1
 3098 014a 1823     		mov	r3, #24
 3099 014c 00E0     		b	.L222
 3100              	.L235:
 739:../Sources/mcg.c **** 
 740:../Sources/mcg.c **** // Now in FEI mode
 741:../Sources/mcg.c ****   return mcg_out;
 3101              		.loc 1 741 0 is_stmt 1
 3102 014e 3B69     		ldr	r3, [r7, #16]
 3103              	.L222:
 742:../Sources/mcg.c **** } // fbe_fei
 3104              		.loc 1 742 0
 3105 0150 181C     		mov	r0, r3
 3106 0152 BD46     		mov	sp, r7
 3107 0154 06B0     		add	sp, sp, #24
 3108              		@ sp needed for prologue
 3109 0156 80BD     		pop	{r7, pc}
 3110              	.L239:
 3111              		.align	2
 3112              	.L238:
 3113 0158 00400640 		.word	1074151424
 3114 015c 117A0000 		.word	31249
 3115 0160 97980000 		.word	39063
 3116 0164 CF070000 		.word	1999
 3117              		.cfi_endproc
 3118              	.LFE10:
 3120              		.section	.text.fei_fbe,"ax",%progbits
 3121              		.align	2
 3122              		.global	fei_fbe
 3123              		.code	16
 3124              		.thumb_func
 3126              	fei_fbe:
 3127              	.LFB11:
 743:../Sources/mcg.c **** 
 744:../Sources/mcg.c **** 
 745:../Sources/mcg.c **** /********************************************************************/
 746:../Sources/mcg.c **** /* Functon name : fei_fbe
 747:../Sources/mcg.c ****  *
 748:../Sources/mcg.c ****  * Mode transition: FEI to FBE mode
 749:../Sources/mcg.c ****  *
 750:../Sources/mcg.c ****  * This function transitions the MCG from FEI mode to FBE mode. This is
 751:../Sources/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
 752:../Sources/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
 753:../Sources/mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
 754:../Sources/mcg.c ****  *
 755:../Sources/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
 756:../Sources/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
 757:../Sources/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an 
 758:../Sources/mcg.c ****  *                           external clock is used.
 759:../Sources/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
 760:../Sources/mcg.c ****  *
 761:../Sources/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 762:../Sources/mcg.c ****  */
 763:../Sources/mcg.c **** int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
 764:../Sources/mcg.c **** {
 3128              		.loc 1 764 0
 3129              		.cfi_startproc
 3130 0000 80B5     		push	{r7, lr}
 3131              	.LCFI33:
 3132              		.cfi_def_cfa_offset 8
 3133              		.cfi_offset 7, -8
 3134              		.cfi_offset 14, -4
 3135 0002 84B0     		sub	sp, sp, #16
 3136              	.LCFI34:
 3137              		.cfi_def_cfa_offset 24
 3138 0004 00AF     		add	r7, sp, #0
 3139              	.LCFI35:
 3140              		.cfi_def_cfa_register 7
 3141 0006 7860     		str	r0, [r7, #4]
 3142 0008 FB1C     		add	r3, r7, #3
 3143 000a 1970     		strb	r1, [r3]
 3144 000c BB1C     		add	r3, r7, #2
 3145 000e 1A70     		strb	r2, [r3]
 765:../Sources/mcg.c ****   unsigned char frdiv_val;
 766:../Sources/mcg.c ****   unsigned char temp_reg;
 767:../Sources/mcg.c ****   short i;
 768:../Sources/mcg.c ****   
 769:../Sources/mcg.c **** // check if in FEI mode
 770:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3146              		.loc 1 770 0
 3147 0010 B44B     		ldr	r3, .L276
 3148 0012 9B79     		ldrb	r3, [r3, #6]
 3149 0014 DBB2     		uxtb	r3, r3
 3150 0016 1A1C     		mov	r2, r3
 3151 0018 0C23     		mov	r3, #12
 3152 001a 1340     		and	r3, r2
 3153 001c 9B08     		lsr	r3, r3, #2
 3154 001e 0DD1     		bne	.L241
 771:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3155              		.loc 1 771 0 discriminator 1
 3156 0020 B04B     		ldr	r3, .L276
 3157 0022 9B79     		ldrb	r3, [r3, #6]
 3158 0024 DBB2     		uxtb	r3, r3
 3159 0026 1A1C     		mov	r2, r3
 3160 0028 1023     		mov	r3, #16
 3161 002a 1340     		and	r3, r2
 770:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3162              		.loc 1 770 0 discriminator 1
 3163 002c 06D0     		beq	.L241
 772:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 3164              		.loc 1 772 0 discriminator 1
 3165 002e AD4B     		ldr	r3, .L276
 3166 0030 9B79     		ldrb	r3, [r3, #6]
 3167 0032 DBB2     		uxtb	r3, r3
 3168 0034 1A1C     		mov	r2, r3
 3169 0036 2023     		mov	r3, #32
 3170 0038 1340     		and	r3, r2
 770:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3171              		.loc 1 770 0 discriminator 1
 3172 003a 01D0     		beq	.L242
 3173              	.L241:
 773:../Sources/mcg.c ****   {
 774:../Sources/mcg.c ****     return 0x1;                                                     // return error code
 3174              		.loc 1 774 0
 3175 003c 0123     		mov	r3, #1
 3176 003e 4DE1     		b	.L243
 3177              	.L242:
 775:../Sources/mcg.c ****   }
 776:../Sources/mcg.c **** 
 777:../Sources/mcg.c **** // check external frequency is less than the maximum frequency
 778:../Sources/mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 3178              		.loc 1 778 0
 3179 0040 7A68     		ldr	r2, [r7, #4]
 3180 0042 A94B     		ldr	r3, .L276+4
 3181 0044 9A42     		cmp	r2, r3
 3182 0046 01DD     		ble	.L244
 3183              		.loc 1 778 0 is_stmt 0 discriminator 1
 3184 0048 2123     		mov	r3, #33
 3185 004a 47E1     		b	.L243
 3186              	.L244:
 779:../Sources/mcg.c ****   
 780:../Sources/mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
 781:../Sources/mcg.c ****   if (erefs_val)
 3187              		.loc 1 781 0 is_stmt 1
 3188 004c BB1C     		add	r3, r7, #2
 3189 004e 1B78     		ldrb	r3, [r3]
 3190 0050 002B     		cmp	r3, #0
 3191 0052 11D0     		beq	.L245
 782:../Sources/mcg.c ****   {
 783:../Sources/mcg.c ****     if ((crystal_val < 30000) ||
 3192              		.loc 1 783 0
 3193 0054 7A68     		ldr	r2, [r7, #4]
 3194 0056 A54B     		ldr	r3, .L276+8
 3195 0058 9A42     		cmp	r2, r3
 3196 005a 0BDD     		ble	.L246
 3197              		.loc 1 783 0 is_stmt 0 discriminator 1
 3198 005c 7A68     		ldr	r2, [r7, #4]
 3199 005e A44B     		ldr	r3, .L276+12
 3200 0060 9A42     		cmp	r2, r3
 3201 0062 03DD     		ble	.L247
 784:../Sources/mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 3202              		.loc 1 784 0 is_stmt 1
 3203 0064 7A68     		ldr	r2, [r7, #4]
 3204 0066 A34B     		ldr	r3, .L276+16
 3205 0068 9A42     		cmp	r2, r3
 3206 006a 03DD     		ble	.L246
 3207              	.L247:
 3208              		.loc 1 784 0 is_stmt 0 discriminator 1
 3209 006c 7A68     		ldr	r2, [r7, #4]
 3210 006e A24B     		ldr	r3, .L276+20
 3211 0070 9A42     		cmp	r2, r3
 3212 0072 01DD     		ble	.L245
 3213              	.L246:
 785:../Sources/mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 3214              		.loc 1 785 0 is_stmt 1
 3215 0074 2223     		mov	r3, #34
 3216 0076 31E1     		b	.L243
 3217              	.L245:
 786:../Sources/mcg.c ****   }
 787:../Sources/mcg.c **** 
 788:../Sources/mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
 789:../Sources/mcg.c ****   if (hgo_val > 0)
 3218              		.loc 1 789 0
 3219 0078 FB1C     		add	r3, r7, #3
 3220 007a 1B78     		ldrb	r3, [r3]
 3221 007c 002B     		cmp	r3, #0
 3222 007e 02D0     		beq	.L248
 790:../Sources/mcg.c ****   {
 791:../Sources/mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 3223              		.loc 1 791 0
 3224 0080 FB1C     		add	r3, r7, #3
 3225 0082 0122     		mov	r2, #1
 3226 0084 1A70     		strb	r2, [r3]
 3227              	.L248:
 792:../Sources/mcg.c ****   }
 793:../Sources/mcg.c **** 
 794:../Sources/mcg.c **** // configure the MCG_C2 register
 795:../Sources/mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
 796:../Sources/mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
 797:../Sources/mcg.c ****   temp_reg = MCG_C2;
 3228              		.loc 1 797 0
 3229 0086 974A     		ldr	r2, .L276
 3230 0088 3B1C     		mov	r3, r7
 3231 008a 0E33     		add	r3, r3, #14
 3232 008c 5278     		ldrb	r2, [r2, #1]
 3233 008e 1A70     		strb	r2, [r3]
 798:../Sources/mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 3234              		.loc 1 798 0
 3235 0090 3B1C     		mov	r3, r7
 3236 0092 0E33     		add	r3, r3, #14
 3237 0094 3A1C     		mov	r2, r7
 3238 0096 0E32     		add	r2, r2, #14
 3239 0098 1278     		ldrb	r2, [r2]
 3240 009a 3C21     		mov	r1, #60
 3241 009c 8A43     		bic	r2, r1
 3242 009e 1A70     		strb	r2, [r3]
 799:../Sources/mcg.c ****   if (crystal_val <= 40000)
 3243              		.loc 1 799 0
 3244 00a0 7A68     		ldr	r2, [r7, #4]
 3245 00a2 934B     		ldr	r3, .L276+12
 3246 00a4 9A42     		cmp	r2, r3
 3247 00a6 11DC     		bgt	.L249
 800:../Sources/mcg.c ****   {
 801:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 3248              		.loc 1 801 0
 3249 00a8 FB1C     		add	r3, r7, #3
 3250 00aa 1B78     		ldrb	r3, [r3]
 3251 00ac DB00     		lsl	r3, r3, #3
 3252 00ae DAB2     		uxtb	r2, r3
 3253 00b0 BB1C     		add	r3, r7, #2
 3254 00b2 1B78     		ldrb	r3, [r3]
 3255 00b4 9B00     		lsl	r3, r3, #2
 3256 00b6 DBB2     		uxtb	r3, r3
 3257 00b8 1343     		orr	r3, r2
 3258 00ba D9B2     		uxtb	r1, r3
 3259 00bc 3B1C     		mov	r3, r7
 3260 00be 0E33     		add	r3, r3, #14
 3261 00c0 3A1C     		mov	r2, r7
 3262 00c2 0E32     		add	r2, r2, #14
 3263 00c4 1278     		ldrb	r2, [r2]
 3264 00c6 0A43     		orr	r2, r1
 3265 00c8 1A70     		strb	r2, [r3]
 3266 00ca 2CE0     		b	.L250
 3267              	.L249:
 802:../Sources/mcg.c ****   }
 803:../Sources/mcg.c ****   else if (crystal_val <= 8000000)
 3268              		.loc 1 803 0
 3269 00cc 7A68     		ldr	r2, [r7, #4]
 3270 00ce 8B4B     		ldr	r3, .L276+24
 3271 00d0 9A42     		cmp	r2, r3
 3272 00d2 14DC     		bgt	.L251
 804:../Sources/mcg.c ****   {
 805:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 3273              		.loc 1 805 0
 3274 00d4 FB1C     		add	r3, r7, #3
 3275 00d6 1B78     		ldrb	r3, [r3]
 3276 00d8 DB00     		lsl	r3, r3, #3
 3277 00da DAB2     		uxtb	r2, r3
 3278 00dc BB1C     		add	r3, r7, #2
 3279 00de 1B78     		ldrb	r3, [r3]
 3280 00e0 9B00     		lsl	r3, r3, #2
 3281 00e2 DBB2     		uxtb	r3, r3
 3282 00e4 1343     		orr	r3, r2
 3283 00e6 DAB2     		uxtb	r2, r3
 3284 00e8 3B1C     		mov	r3, r7
 3285 00ea 0E33     		add	r3, r3, #14
 3286 00ec 1B78     		ldrb	r3, [r3]
 3287 00ee 1343     		orr	r3, r2
 3288 00f0 DAB2     		uxtb	r2, r3
 3289 00f2 3B1C     		mov	r3, r7
 3290 00f4 0E33     		add	r3, r3, #14
 3291 00f6 1021     		mov	r1, #16
 3292 00f8 0A43     		orr	r2, r1
 3293 00fa 1A70     		strb	r2, [r3]
 3294 00fc 13E0     		b	.L250
 3295              	.L251:
 806:../Sources/mcg.c ****   }
 807:../Sources/mcg.c ****   else
 808:../Sources/mcg.c ****   {
 809:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 3296              		.loc 1 809 0
 3297 00fe FB1C     		add	r3, r7, #3
 3298 0100 1B78     		ldrb	r3, [r3]
 3299 0102 DB00     		lsl	r3, r3, #3
 3300 0104 DAB2     		uxtb	r2, r3
 3301 0106 BB1C     		add	r3, r7, #2
 3302 0108 1B78     		ldrb	r3, [r3]
 3303 010a 9B00     		lsl	r3, r3, #2
 3304 010c DBB2     		uxtb	r3, r3
 3305 010e 1343     		orr	r3, r2
 3306 0110 DAB2     		uxtb	r2, r3
 3307 0112 3B1C     		mov	r3, r7
 3308 0114 0E33     		add	r3, r3, #14
 3309 0116 1B78     		ldrb	r3, [r3]
 3310 0118 1343     		orr	r3, r2
 3311 011a DAB2     		uxtb	r2, r3
 3312 011c 3B1C     		mov	r3, r7
 3313 011e 0E33     		add	r3, r3, #14
 3314 0120 2021     		mov	r1, #32
 3315 0122 0A43     		orr	r2, r1
 3316 0124 1A70     		strb	r2, [r3]
 3317              	.L250:
 810:../Sources/mcg.c ****   }
 811:../Sources/mcg.c ****   MCG_C2 = temp_reg;
 3318              		.loc 1 811 0
 3319 0126 6F4B     		ldr	r3, .L276
 3320 0128 3A1C     		mov	r2, r7
 3321 012a 0E32     		add	r2, r2, #14
 3322 012c 1278     		ldrb	r2, [r2]
 3323 012e 5A70     		strb	r2, [r3, #1]
 812:../Sources/mcg.c **** // determine FRDIV based on reference clock frequency
 813:../Sources/mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
 814:../Sources/mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 3324              		.loc 1 814 0
 3325 0130 7A68     		ldr	r2, [r7, #4]
 3326 0132 734B     		ldr	r3, .L276+28
 3327 0134 9A42     		cmp	r2, r3
 3328 0136 04DC     		bgt	.L252
 3329              		.loc 1 814 0 is_stmt 0 discriminator 1
 3330 0138 3B1C     		mov	r3, r7
 3331 013a 0F33     		add	r3, r3, #15
 3332 013c 0022     		mov	r2, #0
 3333 013e 1A70     		strb	r2, [r3]
 3334 0140 27E0     		b	.L253
 3335              	.L252:
 815:../Sources/mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 3336              		.loc 1 815 0 is_stmt 1
 3337 0142 7A68     		ldr	r2, [r7, #4]
 3338 0144 6F4B     		ldr	r3, .L276+32
 3339 0146 9A42     		cmp	r2, r3
 3340 0148 04DC     		bgt	.L254
 3341              		.loc 1 815 0 is_stmt 0 discriminator 1
 3342 014a 3B1C     		mov	r3, r7
 3343 014c 0F33     		add	r3, r3, #15
 3344 014e 0122     		mov	r2, #1
 3345 0150 1A70     		strb	r2, [r3]
 3346 0152 1EE0     		b	.L253
 3347              	.L254:
 816:../Sources/mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 3348              		.loc 1 816 0 is_stmt 1
 3349 0154 7A68     		ldr	r2, [r7, #4]
 3350 0156 6C4B     		ldr	r3, .L276+36
 3351 0158 9A42     		cmp	r2, r3
 3352 015a 04DC     		bgt	.L255
 3353              		.loc 1 816 0 is_stmt 0 discriminator 1
 3354 015c 3B1C     		mov	r3, r7
 3355 015e 0F33     		add	r3, r3, #15
 3356 0160 0222     		mov	r2, #2
 3357 0162 1A70     		strb	r2, [r3]
 3358 0164 15E0     		b	.L253
 3359              	.L255:
 817:../Sources/mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 3360              		.loc 1 817 0 is_stmt 1
 3361 0166 7A68     		ldr	r2, [r7, #4]
 3362 0168 684B     		ldr	r3, .L276+40
 3363 016a 9A42     		cmp	r2, r3
 3364 016c 04DC     		bgt	.L256
 3365              		.loc 1 817 0 is_stmt 0 discriminator 1
 3366 016e 3B1C     		mov	r3, r7
 3367 0170 0F33     		add	r3, r3, #15
 3368 0172 0322     		mov	r2, #3
 3369 0174 1A70     		strb	r2, [r3]
 3370 0176 0CE0     		b	.L253
 3371              	.L256:
 818:../Sources/mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 3372              		.loc 1 818 0 is_stmt 1
 3373 0178 7A68     		ldr	r2, [r7, #4]
 3374 017a 654B     		ldr	r3, .L276+44
 3375 017c 9A42     		cmp	r2, r3
 3376 017e 04DC     		bgt	.L257
 3377              		.loc 1 818 0 is_stmt 0 discriminator 1
 3378 0180 3B1C     		mov	r3, r7
 3379 0182 0F33     		add	r3, r3, #15
 3380 0184 0422     		mov	r2, #4
 3381 0186 1A70     		strb	r2, [r3]
 3382 0188 03E0     		b	.L253
 3383              	.L257:
 819:../Sources/mcg.c ****   else {frdiv_val = 5;}
 3384              		.loc 1 819 0 is_stmt 1
 3385 018a 3B1C     		mov	r3, r7
 3386 018c 0F33     		add	r3, r3, #15
 3387 018e 0522     		mov	r2, #5
 3388 0190 1A70     		strb	r2, [r3]
 3389              	.L253:
 820:../Sources/mcg.c ****   
 821:../Sources/mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
 822:../Sources/mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
 823:../Sources/mcg.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 824:../Sources/mcg.c ****   temp_reg = MCG_C1;
 3390              		.loc 1 824 0
 3391 0192 544A     		ldr	r2, .L276
 3392 0194 3B1C     		mov	r3, r7
 3393 0196 0E33     		add	r3, r3, #14
 3394 0198 1278     		ldrb	r2, [r2]
 3395 019a 1A70     		strb	r2, [r3]
 825:../Sources/mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 3396              		.loc 1 825 0
 3397 019c 3B1C     		mov	r3, r7
 3398 019e 0E33     		add	r3, r3, #14
 3399 01a0 3A1C     		mov	r2, r7
 3400 01a2 0E32     		add	r2, r2, #14
 3401 01a4 1178     		ldrb	r1, [r2]
 3402 01a6 0322     		mov	r2, #3
 3403 01a8 0A40     		and	r2, r1
 3404 01aa 1A70     		strb	r2, [r3]
 826:../Sources/mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 3405              		.loc 1 826 0
 3406 01ac 3B1C     		mov	r3, r7
 3407 01ae 0F33     		add	r3, r3, #15
 3408 01b0 1B78     		ldrb	r3, [r3]
 3409 01b2 DB00     		lsl	r3, r3, #3
 3410 01b4 DAB2     		uxtb	r2, r3
 3411 01b6 3823     		mov	r3, #56
 3412 01b8 1340     		and	r3, r2
 3413 01ba DAB2     		uxtb	r2, r3
 3414 01bc 3B1C     		mov	r3, r7
 3415 01be 0E33     		add	r3, r3, #14
 3416 01c0 1B78     		ldrb	r3, [r3]
 3417 01c2 1343     		orr	r3, r2
 3418 01c4 DAB2     		uxtb	r2, r3
 3419 01c6 3B1C     		mov	r3, r7
 3420 01c8 0E33     		add	r3, r3, #14
 3421 01ca 8021     		mov	r1, #128
 3422 01cc 4942     		neg	r1, r1
 3423 01ce 0A43     		orr	r2, r1
 3424 01d0 1A70     		strb	r2, [r3]
 827:../Sources/mcg.c ****   MCG_C1 = temp_reg;
 3425              		.loc 1 827 0
 3426 01d2 444B     		ldr	r3, .L276
 3427 01d4 3A1C     		mov	r2, r7
 3428 01d6 0E32     		add	r2, r2, #14
 3429 01d8 1278     		ldrb	r2, [r2]
 3430 01da 1A70     		strb	r2, [r3]
 828:../Sources/mcg.c **** 
 829:../Sources/mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
 830:../Sources/mcg.c ****   if (erefs_val)
 3431              		.loc 1 830 0
 3432 01dc BB1C     		add	r3, r7, #2
 3433 01de 1B78     		ldrb	r3, [r3]
 3434 01e0 002B     		cmp	r3, #0
 3435 01e2 24D0     		beq	.L258
 831:../Sources/mcg.c ****   {
 832:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 3436              		.loc 1 832 0
 3437 01e4 3B1C     		mov	r3, r7
 3438 01e6 0C33     		add	r3, r3, #12
 3439 01e8 0022     		mov	r2, #0
 3440 01ea 1A80     		strh	r2, [r3]
 3441 01ec 0DE0     		b	.L259
 3442              	.L262:
 833:../Sources/mcg.c ****     {
 834:../Sources/mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 3443              		.loc 1 834 0
 3444 01ee 3D4B     		ldr	r3, .L276
 3445 01f0 9B79     		ldrb	r3, [r3, #6]
 3446 01f2 DBB2     		uxtb	r3, r3
 3447 01f4 1A1C     		mov	r2, r3
 3448 01f6 0223     		mov	r3, #2
 3449 01f8 1340     		and	r3, r2
 3450 01fa 0ED1     		bne	.L273
 3451              	.L260:
 832:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 3452              		.loc 1 832 0
 3453 01fc 3B1C     		mov	r3, r7
 3454 01fe 0C33     		add	r3, r3, #12
 3455 0200 3A1C     		mov	r2, r7
 3456 0202 0C32     		add	r2, r2, #12
 3457 0204 1288     		ldrh	r2, [r2]
 3458 0206 0132     		add	r2, r2, #1
 3459 0208 1A80     		strh	r2, [r3]
 3460              	.L259:
 832:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 3461              		.loc 1 832 0 is_stmt 0 discriminator 1
 3462 020a 3B1C     		mov	r3, r7
 3463 020c 0C33     		add	r3, r3, #12
 3464 020e 0021     		mov	r1, #0
 3465 0210 5A5E     		ldrsh	r2, [r3, r1]
 3466 0212 404B     		ldr	r3, .L276+48
 3467 0214 9A42     		cmp	r2, r3
 3468 0216 EADD     		ble	.L262
 3469 0218 00E0     		b	.L261
 3470              	.L273:
 3471              		.loc 1 834 0 is_stmt 1
 3472 021a C046     		mov	r8, r8
 3473              	.L261:
 835:../Sources/mcg.c ****     }
 836:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 3474              		.loc 1 836 0
 3475 021c 314B     		ldr	r3, .L276
 3476 021e 9B79     		ldrb	r3, [r3, #6]
 3477 0220 DBB2     		uxtb	r3, r3
 3478 0222 1A1C     		mov	r2, r3
 3479 0224 0223     		mov	r3, #2
 3480 0226 1340     		and	r3, r2
 3481 0228 01D1     		bne	.L258
 3482              		.loc 1 836 0 is_stmt 0 discriminator 1
 3483 022a 2323     		mov	r3, #35
 3484 022c 56E0     		b	.L243
 3485              	.L258:
 837:../Sources/mcg.c ****   }
 838:../Sources/mcg.c **** 
 839:../Sources/mcg.c **** // wait for Reference clock Status bit to clear
 840:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3486              		.loc 1 840 0 is_stmt 1
 3487 022e 3B1C     		mov	r3, r7
 3488 0230 0C33     		add	r3, r3, #12
 3489 0232 0022     		mov	r2, #0
 3490 0234 1A80     		strh	r2, [r3]
 3491 0236 0DE0     		b	.L263
 3492              	.L266:
 841:../Sources/mcg.c ****   {
 842:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 3493              		.loc 1 842 0
 3494 0238 2A4B     		ldr	r3, .L276
 3495 023a 9B79     		ldrb	r3, [r3, #6]
 3496 023c DBB2     		uxtb	r3, r3
 3497 023e 1A1C     		mov	r2, r3
 3498 0240 1023     		mov	r3, #16
 3499 0242 1340     		and	r3, r2
 3500 0244 0ED0     		beq	.L274
 3501              	.L264:
 840:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3502              		.loc 1 840 0
 3503 0246 3B1C     		mov	r3, r7
 3504 0248 0C33     		add	r3, r3, #12
 3505 024a 3A1C     		mov	r2, r7
 3506 024c 0C32     		add	r2, r2, #12
 3507 024e 1288     		ldrh	r2, [r2]
 3508 0250 0132     		add	r2, r2, #1
 3509 0252 1A80     		strh	r2, [r3]
 3510              	.L263:
 840:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3511              		.loc 1 840 0 is_stmt 0 discriminator 1
 3512 0254 3B1C     		mov	r3, r7
 3513 0256 0C33     		add	r3, r3, #12
 3514 0258 0021     		mov	r1, #0
 3515 025a 5A5E     		ldrsh	r2, [r3, r1]
 3516 025c 2E4B     		ldr	r3, .L276+52
 3517 025e 9A42     		cmp	r2, r3
 3518 0260 EADD     		ble	.L266
 3519 0262 00E0     		b	.L265
 3520              	.L274:
 3521              		.loc 1 842 0 is_stmt 1
 3522 0264 C046     		mov	r8, r8
 3523              	.L265:
 843:../Sources/mcg.c ****   }
 844:../Sources/mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 3524              		.loc 1 844 0
 3525 0266 1F4B     		ldr	r3, .L276
 3526 0268 9B79     		ldrb	r3, [r3, #6]
 3527 026a DBB2     		uxtb	r3, r3
 3528 026c 1A1C     		mov	r2, r3
 3529 026e 1023     		mov	r3, #16
 3530 0270 1340     		and	r3, r2
 3531 0272 01D0     		beq	.L267
 3532              		.loc 1 844 0 is_stmt 0 discriminator 1
 3533 0274 1123     		mov	r3, #17
 3534 0276 31E0     		b	.L243
 3535              	.L267:
 845:../Sources/mcg.c ****   
 846:../Sources/mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
 847:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3536              		.loc 1 847 0 is_stmt 1
 3537 0278 3B1C     		mov	r3, r7
 3538 027a 0C33     		add	r3, r3, #12
 3539 027c 0022     		mov	r2, #0
 3540 027e 1A80     		strh	r2, [r3]
 3541 0280 0FE0     		b	.L268
 3542              	.L271:
 848:../Sources/mcg.c ****   {
 849:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 3543              		.loc 1 849 0
 3544 0282 184B     		ldr	r3, .L276
 3545 0284 9B79     		ldrb	r3, [r3, #6]
 3546 0286 DBB2     		uxtb	r3, r3
 3547 0288 1A1C     		mov	r2, r3
 3548 028a 0C23     		mov	r3, #12
 3549 028c 1340     		and	r3, r2
 3550 028e 9B08     		lsr	r3, r3, #2
 3551 0290 022B     		cmp	r3, #2
 3552 0292 0ED0     		beq	.L275
 3553              	.L269:
 847:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3554              		.loc 1 847 0
 3555 0294 3B1C     		mov	r3, r7
 3556 0296 0C33     		add	r3, r3, #12
 3557 0298 3A1C     		mov	r2, r7
 3558 029a 0C32     		add	r2, r2, #12
 3559 029c 1288     		ldrh	r2, [r2]
 3560 029e 0132     		add	r2, r2, #1
 3561 02a0 1A80     		strh	r2, [r3]
 3562              	.L268:
 847:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3563              		.loc 1 847 0 is_stmt 0 discriminator 1
 3564 02a2 3B1C     		mov	r3, r7
 3565 02a4 0C33     		add	r3, r3, #12
 3566 02a6 0021     		mov	r1, #0
 3567 02a8 5A5E     		ldrsh	r2, [r3, r1]
 3568 02aa 1B4B     		ldr	r3, .L276+52
 3569 02ac 9A42     		cmp	r2, r3
 3570 02ae E8DD     		ble	.L271
 3571 02b0 00E0     		b	.L270
 3572              	.L275:
 3573              		.loc 1 849 0 is_stmt 1
 3574 02b2 C046     		mov	r8, r8
 3575              	.L270:
 850:../Sources/mcg.c ****   }
 851:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 3576              		.loc 1 851 0
 3577 02b4 0B4B     		ldr	r3, .L276
 3578 02b6 9B79     		ldrb	r3, [r3, #6]
 3579 02b8 DBB2     		uxtb	r3, r3
 3580 02ba 1A1C     		mov	r2, r3
 3581 02bc 0C23     		mov	r3, #12
 3582 02be 1340     		and	r3, r2
 3583 02c0 9B08     		lsr	r3, r3, #2
 3584 02c2 022B     		cmp	r3, #2
 3585 02c4 01D0     		beq	.L272
 3586              		.loc 1 851 0 is_stmt 0 discriminator 1
 3587 02c6 1A23     		mov	r3, #26
 3588 02c8 08E0     		b	.L243
 3589              	.L272:
 852:../Sources/mcg.c ****  
 853:../Sources/mcg.c **** // Now in FBE  
 854:../Sources/mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
 855:../Sources/mcg.c **** // It is enabled here but can be removed if this is not required.
 856:../Sources/mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 3590              		.loc 1 856 0 is_stmt 1
 3591 02ca 064B     		ldr	r3, .L276
 3592 02cc 054A     		ldr	r2, .L276
 3593 02ce 5279     		ldrb	r2, [r2, #5]
 3594 02d0 D2B2     		uxtb	r2, r2
 3595 02d2 2021     		mov	r1, #32
 3596 02d4 0A43     		orr	r2, r1
 3597 02d6 D2B2     		uxtb	r2, r2
 3598 02d8 5A71     		strb	r2, [r3, #5]
 857:../Sources/mcg.c ****   
 858:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 3599              		.loc 1 858 0
 3600 02da 7B68     		ldr	r3, [r7, #4]
 3601              	.L243:
 859:../Sources/mcg.c **** } // fei_fbe
 3602              		.loc 1 859 0
 3603 02dc 181C     		mov	r0, r3
 3604 02de BD46     		mov	sp, r7
 3605 02e0 04B0     		add	sp, sp, #16
 3606              		@ sp needed for prologue
 3607 02e2 80BD     		pop	{r7, pc}
 3608              	.L277:
 3609              		.align	2
 3610              	.L276:
 3611 02e4 00400640 		.word	1074151424
 3612 02e8 80F0FA02 		.word	50000000
 3613 02ec 2F750000 		.word	29999
 3614 02f0 409C0000 		.word	40000
 3615 02f4 BFC62D00 		.word	2999999
 3616 02f8 0048E801 		.word	32000000
 3617 02fc 00127A00 		.word	8000000
 3618 0300 D0121300 		.word	1250000
 3619 0304 A0252600 		.word	2500000
 3620 0308 404B4C00 		.word	5000000
 3621 030c 80969800 		.word	10000000
 3622 0310 002D3101 		.word	20000000
 3623 0314 0F270000 		.word	9999
 3624 0318 CF070000 		.word	1999
 3625              		.cfi_endproc
 3626              	.LFE11:
 3628              		.section	.text.fbe_fee,"ax",%progbits
 3629              		.align	2
 3630              		.global	fbe_fee
 3631              		.code	16
 3632              		.thumb_func
 3634              	fbe_fee:
 3635              	.LFB12:
 860:../Sources/mcg.c **** 
 861:../Sources/mcg.c **** 
 862:../Sources/mcg.c **** int fbe_fee(int crystal_val)
 863:../Sources/mcg.c **** {
 3636              		.loc 1 863 0
 3637              		.cfi_startproc
 3638 0000 80B5     		push	{r7, lr}
 3639              	.LCFI36:
 3640              		.cfi_def_cfa_offset 8
 3641              		.cfi_offset 7, -8
 3642              		.cfi_offset 14, -4
 3643 0002 84B0     		sub	sp, sp, #16
 3644              	.LCFI37:
 3645              		.cfi_def_cfa_offset 24
 3646 0004 00AF     		add	r7, sp, #0
 3647              	.LCFI38:
 3648              		.cfi_def_cfa_register 7
 3649 0006 7860     		str	r0, [r7, #4]
 864:../Sources/mcg.c ****   short i, fll_ref_freq;
 865:../Sources/mcg.c ****   int mcg_out;
 866:../Sources/mcg.c **** 
 867:../Sources/mcg.c **** // Check MCG is in FBE mode
 868:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3650              		.loc 1 868 0
 3651 0008 494B     		ldr	r3, .L291
 3652 000a 9B79     		ldrb	r3, [r3, #6]
 3653 000c DBB2     		uxtb	r3, r3
 3654 000e 1A1C     		mov	r2, r3
 3655 0010 0C23     		mov	r3, #12
 3656 0012 1340     		and	r3, r2
 3657 0014 9B08     		lsr	r3, r3, #2
 3658 0016 022B     		cmp	r3, #2
 3659 0018 14D1     		bne	.L279
 869:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3660              		.loc 1 869 0 discriminator 1
 3661 001a 454B     		ldr	r3, .L291
 3662 001c 9B79     		ldrb	r3, [r3, #6]
 3663 001e DBB2     		uxtb	r3, r3
 3664 0020 1A1C     		mov	r2, r3
 3665 0022 1023     		mov	r3, #16
 3666 0024 1340     		and	r3, r2
 868:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3667              		.loc 1 868 0 discriminator 1
 3668 0026 0DD1     		bne	.L279
 870:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 3669              		.loc 1 870 0
 3670 0028 414B     		ldr	r3, .L291
 3671 002a 9B79     		ldrb	r3, [r3, #6]
 3672 002c DBB2     		uxtb	r3, r3
 3673 002e 1A1C     		mov	r2, r3
 3674 0030 2023     		mov	r3, #32
 3675 0032 1340     		and	r3, r2
 869:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3676              		.loc 1 869 0
 3677 0034 06D1     		bne	.L279
 871:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 3678              		.loc 1 871 0
 3679 0036 3E4B     		ldr	r3, .L291
 3680 0038 5B78     		ldrb	r3, [r3, #1]
 3681 003a DBB2     		uxtb	r3, r3
 3682 003c 1A1C     		mov	r2, r3
 3683 003e 0223     		mov	r3, #2
 3684 0040 1340     		and	r3, r2
 868:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3685              		.loc 1 868 0
 3686 0042 01D0     		beq	.L280
 3687              	.L279:
 872:../Sources/mcg.c ****   {
 873:../Sources/mcg.c ****     return 0x4;                                                       // return error code
 3688              		.loc 1 873 0
 3689 0044 0423     		mov	r3, #4
 3690 0046 6EE0     		b	.L281
 3691              	.L280:
 874:../Sources/mcg.c ****   }
 875:../Sources/mcg.c ****   
 876:../Sources/mcg.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
 877:../Sources/mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 3692              		.loc 1 877 0
 3693 0048 394B     		ldr	r3, .L291
 3694 004a 5B78     		ldrb	r3, [r3, #1]
 3695 004c DBB2     		uxtb	r3, r3
 3696 004e 1A1C     		mov	r2, r3
 3697 0050 3023     		mov	r3, #48
 3698 0052 1340     		and	r3, r2
 3699 0054 1B09     		lsr	r3, r3, #4
 3700 0056 14D0     		beq	.L282
 878:../Sources/mcg.c ****   {
 879:../Sources/mcg.c ****     fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
 3701              		.loc 1 879 0
 3702 0058 354B     		ldr	r3, .L291
 3703 005a 1B78     		ldrb	r3, [r3]
 3704 005c DBB2     		uxtb	r3, r3
 3705 005e 1A1C     		mov	r2, r3
 3706 0060 3823     		mov	r3, #56
 3707 0062 1340     		and	r3, r2
 3708 0064 DB08     		lsr	r3, r3, #3
 3709 0066 2022     		mov	r2, #32
 3710 0068 111C     		mov	r1, r2
 3711 006a 9940     		lsl	r1, r1, r3
 3712 006c 0B1C     		mov	r3, r1
 3713 006e 7868     		ldr	r0, [r7, #4]
 3714 0070 191C     		mov	r1, r3
 3715 0072 FFF7FEFF 		bl	__aeabi_idiv
 3716 0076 031C     		mov	r3, r0
 3717 0078 1A1C     		mov	r2, r3
 3718 007a 3B1C     		mov	r3, r7
 3719 007c 0C33     		add	r3, r3, #12
 3720 007e 1A80     		strh	r2, [r3]
 3721 0080 13E0     		b	.L283
 3722              	.L282:
 880:../Sources/mcg.c ****   }
 881:../Sources/mcg.c ****   else
 882:../Sources/mcg.c ****   {
 883:../Sources/mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)))
 3723              		.loc 1 883 0
 3724 0082 2B4B     		ldr	r3, .L291
 3725 0084 5B78     		ldrb	r3, [r3, #1]
 3726 0086 DBB2     		uxtb	r3, r3
 3727 0088 1A1C     		mov	r2, r3
 3728 008a 3023     		mov	r3, #48
 3729 008c 1340     		and	r3, r2
 3730 008e 1B09     		lsr	r3, r3, #4
 3731 0090 0122     		mov	r2, #1
 3732 0092 111C     		mov	r1, r2
 3733 0094 9940     		lsl	r1, r1, r3
 3734 0096 0B1C     		mov	r3, r1
 3735 0098 7868     		ldr	r0, [r7, #4]
 3736 009a 191C     		mov	r1, r3
 3737 009c FFF7FEFF 		bl	__aeabi_idiv
 3738 00a0 031C     		mov	r3, r0
 3739 00a2 1A1C     		mov	r2, r3
 3740 00a4 3B1C     		mov	r3, r7
 3741 00a6 0C33     		add	r3, r3, #12
 3742 00a8 1A80     		strh	r2, [r3]
 3743              	.L283:
 884:../Sources/mcg.c ****   }
 885:../Sources/mcg.c ****   
 886:../Sources/mcg.c **** // Check resulting FLL frequency 
 887:../Sources/mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 3744              		.loc 1 887 0
 3745 00aa 3B1C     		mov	r3, r7
 3746 00ac 0C33     		add	r3, r3, #12
 3747 00ae 0022     		mov	r2, #0
 3748 00b0 9B5E     		ldrsh	r3, [r3, r2]
 3749 00b2 181C     		mov	r0, r3
 3750 00b4 FFF7FEFF 		bl	fll_freq
 3751 00b8 031C     		mov	r3, r0
 3752 00ba BB60     		str	r3, [r7, #8]
 888:../Sources/mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 3753              		.loc 1 888 0
 3754 00bc BB68     		ldr	r3, [r7, #8]
 3755 00be 3B2B     		cmp	r3, #59
 3756 00c0 01DC     		bgt	.L284
 3757              		.loc 1 888 0 is_stmt 0 discriminator 1
 3758 00c2 BB68     		ldr	r3, [r7, #8]
 3759 00c4 2FE0     		b	.L281
 3760              	.L284:
 889:../Sources/mcg.c ****   
 890:../Sources/mcg.c **** // Clear CLKS field to switch CLKS mux to select FLL output
 891:../Sources/mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 3761              		.loc 1 891 0 is_stmt 1
 3762 00c6 1A4B     		ldr	r3, .L291
 3763 00c8 194A     		ldr	r2, .L291
 3764 00ca 1278     		ldrb	r2, [r2]
 3765 00cc D1B2     		uxtb	r1, r2
 3766 00ce 3F22     		mov	r2, #63
 3767 00d0 0A40     		and	r2, r1
 3768 00d2 D2B2     		uxtb	r2, r2
 3769 00d4 1A70     		strb	r2, [r3]
 892:../Sources/mcg.c **** 
 893:../Sources/mcg.c **** // Wait for clock status bits to show clock source is FLL
 894:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3770              		.loc 1 894 0
 3771 00d6 3B1C     		mov	r3, r7
 3772 00d8 0E33     		add	r3, r3, #14
 3773 00da 0022     		mov	r2, #0
 3774 00dc 1A80     		strh	r2, [r3]
 3775 00de 0EE0     		b	.L285
 3776              	.L288:
 895:../Sources/mcg.c ****   {
 896:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 3777              		.loc 1 896 0
 3778 00e0 134B     		ldr	r3, .L291
 3779 00e2 9B79     		ldrb	r3, [r3, #6]
 3780 00e4 DBB2     		uxtb	r3, r3
 3781 00e6 1A1C     		mov	r2, r3
 3782 00e8 0C23     		mov	r3, #12
 3783 00ea 1340     		and	r3, r2
 3784 00ec 9B08     		lsr	r3, r3, #2
 3785 00ee 0ED0     		beq	.L290
 3786              	.L286:
 894:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3787              		.loc 1 894 0
 3788 00f0 3B1C     		mov	r3, r7
 3789 00f2 0E33     		add	r3, r3, #14
 3790 00f4 3A1C     		mov	r2, r7
 3791 00f6 0E32     		add	r2, r2, #14
 3792 00f8 1288     		ldrh	r2, [r2]
 3793 00fa 0132     		add	r2, r2, #1
 3794 00fc 1A80     		strh	r2, [r3]
 3795              	.L285:
 894:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3796              		.loc 1 894 0 is_stmt 0 discriminator 1
 3797 00fe 3B1C     		mov	r3, r7
 3798 0100 0E33     		add	r3, r3, #14
 3799 0102 0021     		mov	r1, #0
 3800 0104 5A5E     		ldrsh	r2, [r3, r1]
 3801 0106 0B4B     		ldr	r3, .L291+4
 3802 0108 9A42     		cmp	r2, r3
 3803 010a E9DD     		ble	.L288
 3804 010c 00E0     		b	.L287
 3805              	.L290:
 3806              		.loc 1 896 0 is_stmt 1
 3807 010e C046     		mov	r8, r8
 3808              	.L287:
 897:../Sources/mcg.c ****   }
 898:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 3809              		.loc 1 898 0
 3810 0110 074B     		ldr	r3, .L291
 3811 0112 9B79     		ldrb	r3, [r3, #6]
 3812 0114 DBB2     		uxtb	r3, r3
 3813 0116 1A1C     		mov	r2, r3
 3814 0118 0C23     		mov	r3, #12
 3815 011a 1340     		and	r3, r2
 3816 011c 9B08     		lsr	r3, r3, #2
 3817 011e 01D0     		beq	.L289
 3818              		.loc 1 898 0 is_stmt 0 discriminator 1
 3819 0120 1823     		mov	r3, #24
 3820 0122 00E0     		b	.L281
 3821              	.L289:
 899:../Sources/mcg.c ****   
 900:../Sources/mcg.c **** // Now in FEE mode
 901:../Sources/mcg.c ****   return mcg_out;
 3822              		.loc 1 901 0 is_stmt 1
 3823 0124 BB68     		ldr	r3, [r7, #8]
 3824              	.L281:
 902:../Sources/mcg.c **** } // fbe_fee
 3825              		.loc 1 902 0
 3826 0126 181C     		mov	r0, r3
 3827 0128 BD46     		mov	sp, r7
 3828 012a 04B0     		add	sp, sp, #16
 3829              		@ sp needed for prologue
 3830 012c 80BD     		pop	{r7, pc}
 3831              	.L292:
 3832 012e C046     		.align	2
 3833              	.L291:
 3834 0130 00400640 		.word	1074151424
 3835 0134 CF070000 		.word	1999
 3836              		.cfi_endproc
 3837              	.LFE12:
 3839              		.section	.text.fee_fbe,"ax",%progbits
 3840              		.align	2
 3841              		.global	fee_fbe
 3842              		.code	16
 3843              		.thumb_func
 3845              	fee_fbe:
 3846              	.LFB13:
 903:../Sources/mcg.c **** 
 904:../Sources/mcg.c **** 
 905:../Sources/mcg.c **** int fee_fbe(int crystal_val)
 906:../Sources/mcg.c **** { 
 3847              		.loc 1 906 0
 3848              		.cfi_startproc
 3849 0000 80B5     		push	{r7, lr}
 3850              	.LCFI39:
 3851              		.cfi_def_cfa_offset 8
 3852              		.cfi_offset 7, -8
 3853              		.cfi_offset 14, -4
 3854 0002 84B0     		sub	sp, sp, #16
 3855              	.LCFI40:
 3856              		.cfi_def_cfa_offset 24
 3857 0004 00AF     		add	r7, sp, #0
 3858              	.LCFI41:
 3859              		.cfi_def_cfa_register 7
 3860 0006 7860     		str	r0, [r7, #4]
 907:../Sources/mcg.c ****   short i;
 908:../Sources/mcg.c ****   
 909:../Sources/mcg.c **** // Check MCG is in FEE mode
 910:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3861              		.loc 1 910 0
 3862 0008 274B     		ldr	r3, .L303
 3863 000a 9B79     		ldrb	r3, [r3, #6]
 3864 000c DBB2     		uxtb	r3, r3
 3865 000e 1A1C     		mov	r2, r3
 3866 0010 0C23     		mov	r3, #12
 3867 0012 1340     		and	r3, r2
 3868 0014 9B08     		lsr	r3, r3, #2
 3869 0016 0DD1     		bne	.L294
 911:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 3870              		.loc 1 911 0 discriminator 1
 3871 0018 234B     		ldr	r3, .L303
 3872 001a 9B79     		ldrb	r3, [r3, #6]
 3873 001c DBB2     		uxtb	r3, r3
 3874 001e 1A1C     		mov	r2, r3
 3875 0020 1023     		mov	r3, #16
 3876 0022 1340     		and	r3, r2
 910:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3877              		.loc 1 910 0 discriminator 1
 3878 0024 06D1     		bne	.L294
 912:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 3879              		.loc 1 912 0 discriminator 1
 3880 0026 204B     		ldr	r3, .L303
 3881 0028 9B79     		ldrb	r3, [r3, #6]
 3882 002a DBB2     		uxtb	r3, r3
 3883 002c 1A1C     		mov	r2, r3
 3884 002e 2023     		mov	r3, #32
 3885 0030 1340     		and	r3, r2
 910:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3886              		.loc 1 910 0 discriminator 1
 3887 0032 01D0     		beq	.L295
 3888              	.L294:
 913:../Sources/mcg.c ****   {
 914:../Sources/mcg.c ****     return 0x2;                                                       // return error code
 3889              		.loc 1 914 0
 3890 0034 0223     		mov	r3, #2
 3891 0036 32E0     		b	.L296
 3892              	.L295:
 915:../Sources/mcg.c ****   }
 916:../Sources/mcg.c ****   
 917:../Sources/mcg.c **** // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
 918:../Sources/mcg.c **** // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
 919:../Sources/mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
 3893              		.loc 1 919 0
 3894 0038 1B4B     		ldr	r3, .L303
 3895 003a 1B4A     		ldr	r2, .L303
 3896 003c 1278     		ldrb	r2, [r2]
 3897 003e D2B2     		uxtb	r2, r2
 3898 0040 8021     		mov	r1, #128
 3899 0042 4942     		neg	r1, r1
 3900 0044 0A43     		orr	r2, r1
 3901 0046 D2B2     		uxtb	r2, r2
 3902 0048 1A70     		strb	r2, [r3]
 920:../Sources/mcg.c **** 
 921:../Sources/mcg.c **** /// Wait for clock status bits to show clock source is ext ref clk
 922:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3903              		.loc 1 922 0
 3904 004a 3B1C     		mov	r3, r7
 3905 004c 0E33     		add	r3, r3, #14
 3906 004e 0022     		mov	r2, #0
 3907 0050 1A80     		strh	r2, [r3]
 3908 0052 0FE0     		b	.L297
 3909              	.L300:
 923:../Sources/mcg.c ****   {
 924:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 3910              		.loc 1 924 0
 3911 0054 144B     		ldr	r3, .L303
 3912 0056 9B79     		ldrb	r3, [r3, #6]
 3913 0058 DBB2     		uxtb	r3, r3
 3914 005a 1A1C     		mov	r2, r3
 3915 005c 0C23     		mov	r3, #12
 3916 005e 1340     		and	r3, r2
 3917 0060 9B08     		lsr	r3, r3, #2
 3918 0062 022B     		cmp	r3, #2
 3919 0064 0ED0     		beq	.L302
 3920              	.L298:
 922:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3921              		.loc 1 922 0
 3922 0066 3B1C     		mov	r3, r7
 3923 0068 0E33     		add	r3, r3, #14
 3924 006a 3A1C     		mov	r2, r7
 3925 006c 0E32     		add	r2, r2, #14
 3926 006e 1288     		ldrh	r2, [r2]
 3927 0070 0132     		add	r2, r2, #1
 3928 0072 1A80     		strh	r2, [r3]
 3929              	.L297:
 922:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3930              		.loc 1 922 0 is_stmt 0 discriminator 1
 3931 0074 3B1C     		mov	r3, r7
 3932 0076 0E33     		add	r3, r3, #14
 3933 0078 0021     		mov	r1, #0
 3934 007a 5A5E     		ldrsh	r2, [r3, r1]
 3935 007c 0B4B     		ldr	r3, .L303+4
 3936 007e 9A42     		cmp	r2, r3
 3937 0080 E8DD     		ble	.L300
 3938 0082 00E0     		b	.L299
 3939              	.L302:
 3940              		.loc 1 924 0 is_stmt 1
 3941 0084 C046     		mov	r8, r8
 3942              	.L299:
 925:../Sources/mcg.c ****   }
 926:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 3943              		.loc 1 926 0
 3944 0086 084B     		ldr	r3, .L303
 3945 0088 9B79     		ldrb	r3, [r3, #6]
 3946 008a DBB2     		uxtb	r3, r3
 3947 008c 1A1C     		mov	r2, r3
 3948 008e 0C23     		mov	r3, #12
 3949 0090 1340     		and	r3, r2
 3950 0092 9B08     		lsr	r3, r3, #2
 3951 0094 022B     		cmp	r3, #2
 3952 0096 01D0     		beq	.L301
 3953              		.loc 1 926 0 is_stmt 0 discriminator 1
 3954 0098 1A23     		mov	r3, #26
 3955 009a 00E0     		b	.L296
 3956              	.L301:
 927:../Sources/mcg.c ****   
 928:../Sources/mcg.c **** // Now in FBE mode
 929:../Sources/mcg.c ****   return crystal_val;
 3957              		.loc 1 929 0 is_stmt 1
 3958 009c 7B68     		ldr	r3, [r7, #4]
 3959              	.L296:
 930:../Sources/mcg.c **** } // fee_fbe
 3960              		.loc 1 930 0
 3961 009e 181C     		mov	r0, r3
 3962 00a0 BD46     		mov	sp, r7
 3963 00a2 04B0     		add	sp, sp, #16
 3964              		@ sp needed for prologue
 3965 00a4 80BD     		pop	{r7, pc}
 3966              	.L304:
 3967 00a6 C046     		.align	2
 3968              	.L303:
 3969 00a8 00400640 		.word	1074151424
 3970 00ac CF070000 		.word	1999
 3971              		.cfi_endproc
 3972              	.LFE13:
 3974              		.section	.text.fbe_fbi,"ax",%progbits
 3975              		.align	2
 3976              		.global	fbe_fbi
 3977              		.code	16
 3978              		.thumb_func
 3980              	fbe_fbi:
 3981              	.LFB14:
 931:../Sources/mcg.c **** 
 932:../Sources/mcg.c **** 
 933:../Sources/mcg.c **** int fbe_fbi(int irc_freq, unsigned char irc_select)
 934:../Sources/mcg.c **** {
 3982              		.loc 1 934 0
 3983              		.cfi_startproc
 3984 0000 80B5     		push	{r7, lr}
 3985              	.LCFI42:
 3986              		.cfi_def_cfa_offset 8
 3987              		.cfi_offset 7, -8
 3988              		.cfi_offset 14, -4
 3989 0002 84B0     		sub	sp, sp, #16
 3990              	.LCFI43:
 3991              		.cfi_def_cfa_offset 24
 3992 0004 00AF     		add	r7, sp, #0
 3993              	.LCFI44:
 3994              		.cfi_def_cfa_register 7
 3995 0006 7860     		str	r0, [r7, #4]
 3996 0008 0A1C     		mov	r2, r1
 3997 000a FB1C     		add	r3, r7, #3
 3998 000c 1A70     		strb	r2, [r3]
 935:../Sources/mcg.c ****   unsigned char temp_reg;
 936:../Sources/mcg.c ****   unsigned char fcrdiv_val;
 937:../Sources/mcg.c ****   short i;
 938:../Sources/mcg.c ****   
 939:../Sources/mcg.c **** // Check MCG is in FBE mode
 940:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 3999              		.loc 1 940 0
 4000 000e 964B     		ldr	r3, .L340
 4001 0010 9B79     		ldrb	r3, [r3, #6]
 4002 0012 DBB2     		uxtb	r3, r3
 4003 0014 1A1C     		mov	r2, r3
 4004 0016 0C23     		mov	r3, #12
 4005 0018 1340     		and	r3, r2
 4006 001a 9B08     		lsr	r3, r3, #2
 4007 001c 022B     		cmp	r3, #2
 4008 001e 14D1     		bne	.L306
 941:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4009              		.loc 1 941 0 discriminator 1
 4010 0020 914B     		ldr	r3, .L340
 4011 0022 9B79     		ldrb	r3, [r3, #6]
 4012 0024 DBB2     		uxtb	r3, r3
 4013 0026 1A1C     		mov	r2, r3
 4014 0028 1023     		mov	r3, #16
 4015 002a 1340     		and	r3, r2
 940:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4016              		.loc 1 940 0 discriminator 1
 4017 002c 0DD1     		bne	.L306
 942:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4018              		.loc 1 942 0
 4019 002e 8E4B     		ldr	r3, .L340
 4020 0030 9B79     		ldrb	r3, [r3, #6]
 4021 0032 DBB2     		uxtb	r3, r3
 4022 0034 1A1C     		mov	r2, r3
 4023 0036 2023     		mov	r3, #32
 4024 0038 1340     		and	r3, r2
 941:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4025              		.loc 1 941 0
 4026 003a 06D1     		bne	.L306
 943:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 4027              		.loc 1 943 0
 4028 003c 8A4B     		ldr	r3, .L340
 4029 003e 5B78     		ldrb	r3, [r3, #1]
 4030 0040 DBB2     		uxtb	r3, r3
 4031 0042 1A1C     		mov	r2, r3
 4032 0044 0223     		mov	r3, #2
 4033 0046 1340     		and	r3, r2
 940:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4034              		.loc 1 940 0
 4035 0048 01D0     		beq	.L307
 4036              	.L306:
 944:../Sources/mcg.c ****   {
 945:../Sources/mcg.c ****     return 0x4;                                                       // return error code
 4037              		.loc 1 945 0
 4038 004a 0423     		mov	r3, #4
 4039 004c 08E1     		b	.L308
 4040              	.L307:
 946:../Sources/mcg.c ****   }
 947:../Sources/mcg.c **** 
 948:../Sources/mcg.c **** // Check that the irc frequency matches the selected IRC 
 949:../Sources/mcg.c ****   if (!(irc_select))
 4041              		.loc 1 949 0
 4042 004e FB1C     		add	r3, r7, #3
 4043 0050 1B78     		ldrb	r3, [r3]
 4044 0052 002B     		cmp	r3, #0
 4045 0054 09D1     		bne	.L309
 950:../Sources/mcg.c ****   {    
 951:../Sources/mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 4046              		.loc 1 951 0
 4047 0056 7A68     		ldr	r2, [r7, #4]
 4048 0058 844B     		ldr	r3, .L340+4
 4049 005a 9A42     		cmp	r2, r3
 4050 005c 03DD     		ble	.L310
 4051              		.loc 1 951 0 is_stmt 0 discriminator 2
 4052 005e 7A68     		ldr	r2, [r7, #4]
 4053 0060 834B     		ldr	r3, .L340+8
 4054 0062 9A42     		cmp	r2, r3
 4055 0064 0BDD     		ble	.L311
 4056              	.L310:
 4057              		.loc 1 951 0 discriminator 1
 4058 0066 3123     		mov	r3, #49
 4059 0068 FAE0     		b	.L308
 4060              	.L309:
 952:../Sources/mcg.c ****   }
 953:../Sources/mcg.c ****   else
 954:../Sources/mcg.c ****   {
 955:../Sources/mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 4061              		.loc 1 955 0 is_stmt 1
 4062 006a 7A68     		ldr	r2, [r7, #4]
 4063 006c 814B     		ldr	r3, .L340+12
 4064 006e 9A42     		cmp	r2, r3
 4065 0070 03DD     		ble	.L312
 4066              		.loc 1 955 0 is_stmt 0 discriminator 2
 4067 0072 7A68     		ldr	r2, [r7, #4]
 4068 0074 804B     		ldr	r3, .L340+16
 4069 0076 9A42     		cmp	r2, r3
 4070 0078 01DD     		ble	.L311
 4071              	.L312:
 4072              		.loc 1 955 0 discriminator 1
 4073 007a 3223     		mov	r3, #50
 4074 007c F0E0     		b	.L308
 4075              	.L311:
 956:../Sources/mcg.c ****   }
 957:../Sources/mcg.c ****   
 958:../Sources/mcg.c **** // Select the required IRC
 959:../Sources/mcg.c ****   if (irc_select)
 4076              		.loc 1 959 0 is_stmt 1
 4077 007e FB1C     		add	r3, r7, #3
 4078 0080 1B78     		ldrb	r3, [r3]
 4079 0082 002B     		cmp	r3, #0
 4080 0084 08D0     		beq	.L313
 960:../Sources/mcg.c ****   {
 961:../Sources/mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 4081              		.loc 1 961 0
 4082 0086 784B     		ldr	r3, .L340
 4083 0088 774A     		ldr	r2, .L340
 4084 008a 5278     		ldrb	r2, [r2, #1]
 4085 008c D2B2     		uxtb	r2, r2
 4086 008e 0121     		mov	r1, #1
 4087 0090 0A43     		orr	r2, r1
 4088 0092 D2B2     		uxtb	r2, r2
 4089 0094 5A70     		strb	r2, [r3, #1]
 4090 0096 07E0     		b	.L314
 4091              	.L313:
 962:../Sources/mcg.c ****   }
 963:../Sources/mcg.c ****   else
 964:../Sources/mcg.c ****   {
 965:../Sources/mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 4092              		.loc 1 965 0
 4093 0098 734B     		ldr	r3, .L340
 4094 009a 734A     		ldr	r2, .L340
 4095 009c 5278     		ldrb	r2, [r2, #1]
 4096 009e D2B2     		uxtb	r2, r2
 4097 00a0 0121     		mov	r1, #1
 4098 00a2 8A43     		bic	r2, r1
 4099 00a4 D2B2     		uxtb	r2, r2
 4100 00a6 5A70     		strb	r2, [r3, #1]
 4101              	.L314:
 966:../Sources/mcg.c ****   }
 967:../Sources/mcg.c ****   
 968:../Sources/mcg.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
 969:../Sources/mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 4102              		.loc 1 969 0
 4103 00a8 6F4B     		ldr	r3, .L340
 4104 00aa 6F4A     		ldr	r2, .L340
 4105 00ac 5279     		ldrb	r2, [r2, #5]
 4106 00ae D2B2     		uxtb	r2, r2
 4107 00b0 2021     		mov	r1, #32
 4108 00b2 8A43     		bic	r2, r1
 4109 00b4 D2B2     		uxtb	r2, r2
 4110 00b6 5A71     		strb	r2, [r3, #5]
 970:../Sources/mcg.c ****   
 971:../Sources/mcg.c **** // Select the IRC as the CLKS mux selection
 972:../Sources/mcg.c ****   temp_reg = MCG_C1;
 4111              		.loc 1 972 0
 4112 00b8 6B4A     		ldr	r2, .L340
 4113 00ba 3B1C     		mov	r3, r7
 4114 00bc 0D33     		add	r3, r3, #13
 4115 00be 1278     		ldrb	r2, [r2]
 4116 00c0 1A70     		strb	r2, [r3]
 973:../Sources/mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 4117              		.loc 1 973 0
 4118 00c2 3B1C     		mov	r3, r7
 4119 00c4 0D33     		add	r3, r3, #13
 4120 00c6 3A1C     		mov	r2, r7
 4121 00c8 0D32     		add	r2, r2, #13
 4122 00ca 1178     		ldrb	r1, [r2]
 4123 00cc 3F22     		mov	r2, #63
 4124 00ce 0A40     		and	r2, r1
 4125 00d0 1A70     		strb	r2, [r3]
 974:../Sources/mcg.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 4126              		.loc 1 974 0
 4127 00d2 3B1C     		mov	r3, r7
 4128 00d4 0D33     		add	r3, r3, #13
 4129 00d6 3A1C     		mov	r2, r7
 4130 00d8 0D32     		add	r2, r2, #13
 4131 00da 1278     		ldrb	r2, [r2]
 4132 00dc 4421     		mov	r1, #68
 4133 00de 0A43     		orr	r2, r1
 4134 00e0 1A70     		strb	r2, [r3]
 975:../Sources/mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 4135              		.loc 1 975 0
 4136 00e2 614B     		ldr	r3, .L340
 4137 00e4 3A1C     		mov	r2, r7
 4138 00e6 0D32     		add	r2, r2, #13
 4139 00e8 1278     		ldrb	r2, [r2]
 4140 00ea 1A70     		strb	r2, [r3]
 976:../Sources/mcg.c ****   
 977:../Sources/mcg.c **** // wait until internal reference switches to requested irc.
 978:../Sources/mcg.c ****   if (!(irc_select))
 4141              		.loc 1 978 0
 4142 00ec FB1C     		add	r3, r7, #3
 4143 00ee 1B78     		ldrb	r3, [r3]
 4144 00f0 002B     		cmp	r3, #0
 4145 00f2 26D1     		bne	.L315
 979:../Sources/mcg.c ****   {
 980:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 4146              		.loc 1 980 0
 4147 00f4 3B1C     		mov	r3, r7
 4148 00f6 0E33     		add	r3, r3, #14
 4149 00f8 0022     		mov	r2, #0
 4150 00fa 1A80     		strh	r2, [r3]
 4151 00fc 0DE0     		b	.L316
 4152              	.L319:
 981:../Sources/mcg.c ****     {
 982:../Sources/mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 4153              		.loc 1 982 0
 4154 00fe 5A4B     		ldr	r3, .L340
 4155 0100 9B79     		ldrb	r3, [r3, #6]
 4156 0102 DBB2     		uxtb	r3, r3
 4157 0104 1A1C     		mov	r2, r3
 4158 0106 0123     		mov	r3, #1
 4159 0108 1340     		and	r3, r2
 4160 010a 0ED0     		beq	.L336
 4161              	.L317:
 980:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 4162              		.loc 1 980 0
 4163 010c 3B1C     		mov	r3, r7
 4164 010e 0E33     		add	r3, r3, #14
 4165 0110 3A1C     		mov	r2, r7
 4166 0112 0E32     		add	r2, r2, #14
 4167 0114 1288     		ldrh	r2, [r2]
 4168 0116 0132     		add	r2, r2, #1
 4169 0118 1A80     		strh	r2, [r3]
 4170              	.L316:
 980:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 4171              		.loc 1 980 0 is_stmt 0 discriminator 1
 4172 011a 3B1C     		mov	r3, r7
 4173 011c 0E33     		add	r3, r3, #14
 4174 011e 0021     		mov	r1, #0
 4175 0120 5A5E     		ldrsh	r2, [r3, r1]
 4176 0122 564B     		ldr	r3, .L340+20
 4177 0124 9A42     		cmp	r2, r3
 4178 0126 EADD     		ble	.L319
 4179 0128 00E0     		b	.L318
 4180              	.L336:
 4181              		.loc 1 982 0 is_stmt 1
 4182 012a C046     		mov	r8, r8
 4183              	.L318:
 983:../Sources/mcg.c ****     }
 984:../Sources/mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 4184              		.loc 1 984 0
 4185 012c 4E4B     		ldr	r3, .L340
 4186 012e 9B79     		ldrb	r3, [r3, #6]
 4187 0130 DBB2     		uxtb	r3, r3
 4188 0132 1A1C     		mov	r2, r3
 4189 0134 0123     		mov	r3, #1
 4190 0136 1340     		and	r3, r2
 4191 0138 DBB2     		uxtb	r3, r3
 4192 013a 002B     		cmp	r3, #0
 4193 013c 28D0     		beq	.L320
 4194              		.loc 1 984 0 is_stmt 0 discriminator 1
 4195 013e 1323     		mov	r3, #19
 4196 0140 8EE0     		b	.L308
 4197              	.L315:
 985:../Sources/mcg.c ****   }
 986:../Sources/mcg.c ****   else
 987:../Sources/mcg.c ****   {
 988:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 4198              		.loc 1 988 0 is_stmt 1
 4199 0142 3B1C     		mov	r3, r7
 4200 0144 0E33     		add	r3, r3, #14
 4201 0146 0022     		mov	r2, #0
 4202 0148 1A80     		strh	r2, [r3]
 4203 014a 0FE0     		b	.L321
 4204              	.L324:
 989:../Sources/mcg.c ****     {
 990:../Sources/mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 4205              		.loc 1 990 0
 4206 014c 464B     		ldr	r3, .L340
 4207 014e 9B79     		ldrb	r3, [r3, #6]
 4208 0150 DBB2     		uxtb	r3, r3
 4209 0152 1A1C     		mov	r2, r3
 4210 0154 0123     		mov	r3, #1
 4211 0156 1340     		and	r3, r2
 4212 0158 DBB2     		uxtb	r3, r3
 4213 015a 002B     		cmp	r3, #0
 4214 015c 0ED1     		bne	.L337
 4215              	.L322:
 988:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 4216              		.loc 1 988 0
 4217 015e 3B1C     		mov	r3, r7
 4218 0160 0E33     		add	r3, r3, #14
 4219 0162 3A1C     		mov	r2, r7
 4220 0164 0E32     		add	r2, r2, #14
 4221 0166 1288     		ldrh	r2, [r2]
 4222 0168 0132     		add	r2, r2, #1
 4223 016a 1A80     		strh	r2, [r3]
 4224              	.L321:
 988:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 4225              		.loc 1 988 0 is_stmt 0 discriminator 1
 4226 016c 3B1C     		mov	r3, r7
 4227 016e 0E33     		add	r3, r3, #14
 4228 0170 0021     		mov	r1, #0
 4229 0172 5A5E     		ldrsh	r2, [r3, r1]
 4230 0174 414B     		ldr	r3, .L340+20
 4231 0176 9A42     		cmp	r2, r3
 4232 0178 E8DD     		ble	.L324
 4233 017a 00E0     		b	.L323
 4234              	.L337:
 4235              		.loc 1 990 0 is_stmt 1
 4236 017c C046     		mov	r8, r8
 4237              	.L323:
 991:../Sources/mcg.c ****     }
 992:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 4238              		.loc 1 992 0
 4239 017e 3A4B     		ldr	r3, .L340
 4240 0180 9B79     		ldrb	r3, [r3, #6]
 4241 0182 DBB2     		uxtb	r3, r3
 4242 0184 1A1C     		mov	r2, r3
 4243 0186 0123     		mov	r3, #1
 4244 0188 1340     		and	r3, r2
 4245 018a 01D1     		bne	.L320
 4246              		.loc 1 992 0 is_stmt 0 discriminator 1
 4247 018c 1423     		mov	r3, #20
 4248 018e 67E0     		b	.L308
 4249              	.L320:
 993:../Sources/mcg.c ****   }
 994:../Sources/mcg.c ****  
 995:../Sources/mcg.c **** // Wait for clock status bits to update
 996:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4250              		.loc 1 996 0 is_stmt 1
 4251 0190 3B1C     		mov	r3, r7
 4252 0192 0E33     		add	r3, r3, #14
 4253 0194 0022     		mov	r2, #0
 4254 0196 1A80     		strh	r2, [r3]
 4255 0198 0FE0     		b	.L325
 4256              	.L328:
 997:../Sources/mcg.c ****   {
 998:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 4257              		.loc 1 998 0
 4258 019a 334B     		ldr	r3, .L340
 4259 019c 9B79     		ldrb	r3, [r3, #6]
 4260 019e DBB2     		uxtb	r3, r3
 4261 01a0 1A1C     		mov	r2, r3
 4262 01a2 0C23     		mov	r3, #12
 4263 01a4 1340     		and	r3, r2
 4264 01a6 9B08     		lsr	r3, r3, #2
 4265 01a8 012B     		cmp	r3, #1
 4266 01aa 0ED0     		beq	.L338
 4267              	.L326:
 996:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4268              		.loc 1 996 0
 4269 01ac 3B1C     		mov	r3, r7
 4270 01ae 0E33     		add	r3, r3, #14
 4271 01b0 3A1C     		mov	r2, r7
 4272 01b2 0E32     		add	r2, r2, #14
 4273 01b4 1288     		ldrh	r2, [r2]
 4274 01b6 0132     		add	r2, r2, #1
 4275 01b8 1A80     		strh	r2, [r3]
 4276              	.L325:
 996:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4277              		.loc 1 996 0 is_stmt 0 discriminator 1
 4278 01ba 3B1C     		mov	r3, r7
 4279 01bc 0E33     		add	r3, r3, #14
 4280 01be 0021     		mov	r1, #0
 4281 01c0 5A5E     		ldrsh	r2, [r3, r1]
 4282 01c2 2E4B     		ldr	r3, .L340+20
 4283 01c4 9A42     		cmp	r2, r3
 4284 01c6 E8DD     		ble	.L328
 4285 01c8 00E0     		b	.L327
 4286              	.L338:
 4287              		.loc 1 998 0 is_stmt 1
 4288 01ca C046     		mov	r8, r8
 4289              	.L327:
 999:../Sources/mcg.c ****   }
1000:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 4290              		.loc 1 1000 0
 4291 01cc 264B     		ldr	r3, .L340
 4292 01ce 9B79     		ldrb	r3, [r3, #6]
 4293 01d0 DBB2     		uxtb	r3, r3
 4294 01d2 1A1C     		mov	r2, r3
 4295 01d4 0C23     		mov	r3, #12
 4296 01d6 1340     		and	r3, r2
 4297 01d8 9B08     		lsr	r3, r3, #2
 4298 01da 012B     		cmp	r3, #1
 4299 01dc 01D0     		beq	.L329
 4300              		.loc 1 1000 0 is_stmt 0 discriminator 1
 4301 01de 1923     		mov	r3, #25
 4302 01e0 3EE0     		b	.L308
 4303              	.L329:
1001:../Sources/mcg.c ****   
1002:../Sources/mcg.c ****   // wait for Reference clock Status bit to set
1003:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4304              		.loc 1 1003 0 is_stmt 1
 4305 01e2 3B1C     		mov	r3, r7
 4306 01e4 0E33     		add	r3, r3, #14
 4307 01e6 0022     		mov	r2, #0
 4308 01e8 1A80     		strh	r2, [r3]
 4309 01ea 0DE0     		b	.L330
 4310              	.L333:
1004:../Sources/mcg.c ****   {
1005:../Sources/mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4311              		.loc 1 1005 0
 4312 01ec 1E4B     		ldr	r3, .L340
 4313 01ee 9B79     		ldrb	r3, [r3, #6]
 4314 01f0 DBB2     		uxtb	r3, r3
 4315 01f2 1A1C     		mov	r2, r3
 4316 01f4 1023     		mov	r3, #16
 4317 01f6 1340     		and	r3, r2
 4318 01f8 0ED1     		bne	.L339
 4319              	.L331:
1003:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4320              		.loc 1 1003 0
 4321 01fa 3B1C     		mov	r3, r7
 4322 01fc 0E33     		add	r3, r3, #14
 4323 01fe 3A1C     		mov	r2, r7
 4324 0200 0E32     		add	r2, r2, #14
 4325 0202 1288     		ldrh	r2, [r2]
 4326 0204 0132     		add	r2, r2, #1
 4327 0206 1A80     		strh	r2, [r3]
 4328              	.L330:
1003:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4329              		.loc 1 1003 0 is_stmt 0 discriminator 1
 4330 0208 3B1C     		mov	r3, r7
 4331 020a 0E33     		add	r3, r3, #14
 4332 020c 0021     		mov	r1, #0
 4333 020e 5A5E     		ldrsh	r2, [r3, r1]
 4334 0210 1A4B     		ldr	r3, .L340+20
 4335 0212 9A42     		cmp	r2, r3
 4336 0214 EADD     		ble	.L333
 4337 0216 00E0     		b	.L332
 4338              	.L339:
 4339              		.loc 1 1005 0 is_stmt 1
 4340 0218 C046     		mov	r8, r8
 4341              	.L332:
1006:../Sources/mcg.c ****   }
1007:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 4342              		.loc 1 1007 0
 4343 021a 134B     		ldr	r3, .L340
 4344 021c 9B79     		ldrb	r3, [r3, #6]
 4345 021e DBB2     		uxtb	r3, r3
 4346 0220 1A1C     		mov	r2, r3
 4347 0222 1023     		mov	r3, #16
 4348 0224 1340     		and	r3, r2
 4349 0226 01D1     		bne	.L334
 4350              		.loc 1 1007 0 is_stmt 0 discriminator 1
 4351 0228 1223     		mov	r3, #18
 4352 022a 19E0     		b	.L308
 4353              	.L334:
1008:../Sources/mcg.c ****   
1009:../Sources/mcg.c **** // Now in FBI mode
1010:../Sources/mcg.c ****   
1011:../Sources/mcg.c ****   if (irc_select)
 4354              		.loc 1 1011 0 is_stmt 1
 4355 022c FB1C     		add	r3, r7, #3
 4356 022e 1B78     		ldrb	r3, [r3]
 4357 0230 002B     		cmp	r3, #0
 4358 0232 14D0     		beq	.L335
1012:../Sources/mcg.c ****   {
1013:../Sources/mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 4359              		.loc 1 1013 0
 4360 0234 0C4B     		ldr	r3, .L340
 4361 0236 1B7A     		ldrb	r3, [r3, #8]
 4362 0238 DBB2     		uxtb	r3, r3
 4363 023a 1A1C     		mov	r2, r3
 4364 023c 0E23     		mov	r3, #14
 4365 023e 1340     		and	r3, r2
 4366 0240 5B08     		lsr	r3, r3, #1
 4367 0242 0122     		mov	r2, #1
 4368 0244 9A40     		lsl	r2, r2, r3
 4369 0246 3B1C     		mov	r3, r7
 4370 0248 0C33     		add	r3, r3, #12
 4371 024a 1A70     		strb	r2, [r3]
1014:../Sources/mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV
 4372              		.loc 1 1014 0
 4373 024c 3B1C     		mov	r3, r7
 4374 024e 0C33     		add	r3, r3, #12
 4375 0250 1B78     		ldrb	r3, [r3]
 4376 0252 7868     		ldr	r0, [r7, #4]
 4377 0254 191C     		mov	r1, r3
 4378 0256 FFF7FEFF 		bl	__aeabi_idiv
 4379 025a 031C     		mov	r3, r0
 4380 025c 00E0     		b	.L308
 4381              	.L335:
1015:../Sources/mcg.c ****   }
1016:../Sources/mcg.c ****   else
1017:../Sources/mcg.c ****   {
1018:../Sources/mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 4382              		.loc 1 1018 0
 4383 025e 7B68     		ldr	r3, [r7, #4]
 4384              	.L308:
1019:../Sources/mcg.c ****   }
1020:../Sources/mcg.c **** } //fbe_fbi
 4385              		.loc 1 1020 0
 4386 0260 181C     		mov	r0, r3
 4387 0262 BD46     		mov	sp, r7
 4388 0264 04B0     		add	sp, sp, #16
 4389              		@ sp needed for prologue
 4390 0266 80BD     		pop	{r7, pc}
 4391              	.L341:
 4392              		.align	2
 4393              	.L340:
 4394 0268 00400640 		.word	1074151424
 4395 026c 117A0000 		.word	31249
 4396 0270 97980000 		.word	39063
 4397 0274 BFC62D00 		.word	2999999
 4398 0278 404B4C00 		.word	5000000
 4399 027c CF070000 		.word	1999
 4400              		.cfi_endproc
 4401              	.LFE14:
 4403              		.section	.text.fbi_fbe,"ax",%progbits
 4404              		.align	2
 4405              		.global	fbi_fbe
 4406              		.code	16
 4407              		.thumb_func
 4409              	fbi_fbe:
 4410              	.LFB15:
1021:../Sources/mcg.c **** 
1022:../Sources/mcg.c **** 
1023:../Sources/mcg.c **** int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1024:../Sources/mcg.c **** {
 4411              		.loc 1 1024 0
 4412              		.cfi_startproc
 4413 0000 80B5     		push	{r7, lr}
 4414              	.LCFI45:
 4415              		.cfi_def_cfa_offset 8
 4416              		.cfi_offset 7, -8
 4417              		.cfi_offset 14, -4
 4418 0002 84B0     		sub	sp, sp, #16
 4419              	.LCFI46:
 4420              		.cfi_def_cfa_offset 24
 4421 0004 00AF     		add	r7, sp, #0
 4422              	.LCFI47:
 4423              		.cfi_def_cfa_register 7
 4424 0006 7860     		str	r0, [r7, #4]
 4425 0008 FB1C     		add	r3, r7, #3
 4426 000a 1970     		strb	r1, [r3]
 4427 000c BB1C     		add	r3, r7, #2
 4428 000e 1A70     		strb	r2, [r3]
1025:../Sources/mcg.c ****   unsigned char temp_reg;
1026:../Sources/mcg.c ****   unsigned char frdiv_val;
1027:../Sources/mcg.c ****   short i;
1028:../Sources/mcg.c ****   
1029:../Sources/mcg.c **** // check if in FBI mode
1030:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4429              		.loc 1 1030 0
 4430 0010 B84B     		ldr	r3, .L378
 4431 0012 9B79     		ldrb	r3, [r3, #6]
 4432 0014 DBB2     		uxtb	r3, r3
 4433 0016 1A1C     		mov	r2, r3
 4434 0018 0C23     		mov	r3, #12
 4435 001a 1340     		and	r3, r2
 4436 001c 9B08     		lsr	r3, r3, #2
 4437 001e 012B     		cmp	r3, #1
 4438 0020 14D1     		bne	.L343
1031:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4439              		.loc 1 1031 0 discriminator 1
 4440 0022 B44B     		ldr	r3, .L378
 4441 0024 9B79     		ldrb	r3, [r3, #6]
 4442 0026 DBB2     		uxtb	r3, r3
 4443 0028 1A1C     		mov	r2, r3
 4444 002a 1023     		mov	r3, #16
 4445 002c 1340     		and	r3, r2
1030:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4446              		.loc 1 1030 0 discriminator 1
 4447 002e 0DD0     		beq	.L343
1032:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4448              		.loc 1 1032 0
 4449 0030 B04B     		ldr	r3, .L378
 4450 0032 9B79     		ldrb	r3, [r3, #6]
 4451 0034 DBB2     		uxtb	r3, r3
 4452 0036 1A1C     		mov	r2, r3
 4453 0038 2023     		mov	r3, #32
 4454 003a 1340     		and	r3, r2
1031:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4455              		.loc 1 1031 0
 4456 003c 06D1     		bne	.L343
1033:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4457              		.loc 1 1033 0
 4458 003e AD4B     		ldr	r3, .L378
 4459 0040 5B78     		ldrb	r3, [r3, #1]
 4460 0042 DBB2     		uxtb	r3, r3
 4461 0044 1A1C     		mov	r2, r3
 4462 0046 0223     		mov	r3, #2
 4463 0048 1340     		and	r3, r2
1030:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4464              		.loc 1 1030 0
 4465 004a 01D0     		beq	.L344
 4466              	.L343:
1034:../Sources/mcg.c ****   {  
1035:../Sources/mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 4467              		.loc 1 1035 0
 4468 004c 0323     		mov	r3, #3
 4469 004e 4DE1     		b	.L345
 4470              	.L344:
1036:../Sources/mcg.c ****   }
1037:../Sources/mcg.c ****  
1038:../Sources/mcg.c **** // check external frequency is less than the maximum frequency
1039:../Sources/mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 4471              		.loc 1 1039 0
 4472 0050 7A68     		ldr	r2, [r7, #4]
 4473 0052 A94B     		ldr	r3, .L378+4
 4474 0054 9A42     		cmp	r2, r3
 4475 0056 01DD     		ble	.L346
 4476              		.loc 1 1039 0 is_stmt 0 discriminator 1
 4477 0058 2123     		mov	r3, #33
 4478 005a 47E1     		b	.L345
 4479              	.L346:
1040:../Sources/mcg.c ****   
1041:../Sources/mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
1042:../Sources/mcg.c ****   if (erefs_val)
 4480              		.loc 1 1042 0 is_stmt 1
 4481 005c BB1C     		add	r3, r7, #2
 4482 005e 1B78     		ldrb	r3, [r3]
 4483 0060 002B     		cmp	r3, #0
 4484 0062 11D0     		beq	.L347
1043:../Sources/mcg.c ****   {
1044:../Sources/mcg.c ****     if ((crystal_val < 30000) ||
 4485              		.loc 1 1044 0
 4486 0064 7A68     		ldr	r2, [r7, #4]
 4487 0066 A54B     		ldr	r3, .L378+8
 4488 0068 9A42     		cmp	r2, r3
 4489 006a 0BDD     		ble	.L348
 4490              		.loc 1 1044 0 is_stmt 0 discriminator 1
 4491 006c 7A68     		ldr	r2, [r7, #4]
 4492 006e A44B     		ldr	r3, .L378+12
 4493 0070 9A42     		cmp	r2, r3
 4494 0072 03DD     		ble	.L349
1045:../Sources/mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4495              		.loc 1 1045 0 is_stmt 1
 4496 0074 7A68     		ldr	r2, [r7, #4]
 4497 0076 A34B     		ldr	r3, .L378+16
 4498 0078 9A42     		cmp	r2, r3
 4499 007a 03DD     		ble	.L348
 4500              	.L349:
 4501              		.loc 1 1045 0 is_stmt 0 discriminator 1
 4502 007c 7A68     		ldr	r2, [r7, #4]
 4503 007e A24B     		ldr	r3, .L378+20
 4504 0080 9A42     		cmp	r2, r3
 4505 0082 01DD     		ble	.L347
 4506              	.L348:
1046:../Sources/mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 4507              		.loc 1 1046 0 is_stmt 1
 4508 0084 2223     		mov	r3, #34
 4509 0086 31E1     		b	.L345
 4510              	.L347:
1047:../Sources/mcg.c ****   }
1048:../Sources/mcg.c **** 
1049:../Sources/mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1050:../Sources/mcg.c ****   if (hgo_val > 0)
 4511              		.loc 1 1050 0
 4512 0088 FB1C     		add	r3, r7, #3
 4513 008a 1B78     		ldrb	r3, [r3]
 4514 008c 002B     		cmp	r3, #0
 4515 008e 02D0     		beq	.L350
1051:../Sources/mcg.c ****   {
1052:../Sources/mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 4516              		.loc 1 1052 0
 4517 0090 FB1C     		add	r3, r7, #3
 4518 0092 0122     		mov	r2, #1
 4519 0094 1A70     		strb	r2, [r3]
 4520              	.L350:
1053:../Sources/mcg.c ****   }
1054:../Sources/mcg.c **** 
1055:../Sources/mcg.c **** // configure the MCG_C2 register
1056:../Sources/mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1057:../Sources/mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
1058:../Sources/mcg.c ****   temp_reg = MCG_C2;
 4521              		.loc 1 1058 0
 4522 0096 974A     		ldr	r2, .L378
 4523 0098 3B1C     		mov	r3, r7
 4524 009a 0F33     		add	r3, r3, #15
 4525 009c 5278     		ldrb	r2, [r2, #1]
 4526 009e 1A70     		strb	r2, [r3]
1059:../Sources/mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 4527              		.loc 1 1059 0
 4528 00a0 3B1C     		mov	r3, r7
 4529 00a2 0F33     		add	r3, r3, #15
 4530 00a4 3A1C     		mov	r2, r7
 4531 00a6 0F32     		add	r2, r2, #15
 4532 00a8 1278     		ldrb	r2, [r2]
 4533 00aa 3C21     		mov	r1, #60
 4534 00ac 8A43     		bic	r2, r1
 4535 00ae 1A70     		strb	r2, [r3]
1060:../Sources/mcg.c ****   if (crystal_val <= 40000)
 4536              		.loc 1 1060 0
 4537 00b0 7A68     		ldr	r2, [r7, #4]
 4538 00b2 934B     		ldr	r3, .L378+12
 4539 00b4 9A42     		cmp	r2, r3
 4540 00b6 11DC     		bgt	.L351
1061:../Sources/mcg.c ****   {
1062:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4541              		.loc 1 1062 0
 4542 00b8 FB1C     		add	r3, r7, #3
 4543 00ba 1B78     		ldrb	r3, [r3]
 4544 00bc DB00     		lsl	r3, r3, #3
 4545 00be DAB2     		uxtb	r2, r3
 4546 00c0 BB1C     		add	r3, r7, #2
 4547 00c2 1B78     		ldrb	r3, [r3]
 4548 00c4 9B00     		lsl	r3, r3, #2
 4549 00c6 DBB2     		uxtb	r3, r3
 4550 00c8 1343     		orr	r3, r2
 4551 00ca D9B2     		uxtb	r1, r3
 4552 00cc 3B1C     		mov	r3, r7
 4553 00ce 0F33     		add	r3, r3, #15
 4554 00d0 3A1C     		mov	r2, r7
 4555 00d2 0F32     		add	r2, r2, #15
 4556 00d4 1278     		ldrb	r2, [r2]
 4557 00d6 0A43     		orr	r2, r1
 4558 00d8 1A70     		strb	r2, [r3]
 4559 00da 2CE0     		b	.L352
 4560              	.L351:
1063:../Sources/mcg.c ****   }
1064:../Sources/mcg.c ****   else if (crystal_val <= 8000000)
 4561              		.loc 1 1064 0
 4562 00dc 7A68     		ldr	r2, [r7, #4]
 4563 00de 8B4B     		ldr	r3, .L378+24
 4564 00e0 9A42     		cmp	r2, r3
 4565 00e2 14DC     		bgt	.L353
1065:../Sources/mcg.c ****   {
1066:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4566              		.loc 1 1066 0
 4567 00e4 FB1C     		add	r3, r7, #3
 4568 00e6 1B78     		ldrb	r3, [r3]
 4569 00e8 DB00     		lsl	r3, r3, #3
 4570 00ea DAB2     		uxtb	r2, r3
 4571 00ec BB1C     		add	r3, r7, #2
 4572 00ee 1B78     		ldrb	r3, [r3]
 4573 00f0 9B00     		lsl	r3, r3, #2
 4574 00f2 DBB2     		uxtb	r3, r3
 4575 00f4 1343     		orr	r3, r2
 4576 00f6 DAB2     		uxtb	r2, r3
 4577 00f8 3B1C     		mov	r3, r7
 4578 00fa 0F33     		add	r3, r3, #15
 4579 00fc 1B78     		ldrb	r3, [r3]
 4580 00fe 1343     		orr	r3, r2
 4581 0100 DAB2     		uxtb	r2, r3
 4582 0102 3B1C     		mov	r3, r7
 4583 0104 0F33     		add	r3, r3, #15
 4584 0106 1021     		mov	r1, #16
 4585 0108 0A43     		orr	r2, r1
 4586 010a 1A70     		strb	r2, [r3]
 4587 010c 13E0     		b	.L352
 4588              	.L353:
1067:../Sources/mcg.c ****   }
1068:../Sources/mcg.c ****   else
1069:../Sources/mcg.c ****   {
1070:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4589              		.loc 1 1070 0
 4590 010e FB1C     		add	r3, r7, #3
 4591 0110 1B78     		ldrb	r3, [r3]
 4592 0112 DB00     		lsl	r3, r3, #3
 4593 0114 DAB2     		uxtb	r2, r3
 4594 0116 BB1C     		add	r3, r7, #2
 4595 0118 1B78     		ldrb	r3, [r3]
 4596 011a 9B00     		lsl	r3, r3, #2
 4597 011c DBB2     		uxtb	r3, r3
 4598 011e 1343     		orr	r3, r2
 4599 0120 DAB2     		uxtb	r2, r3
 4600 0122 3B1C     		mov	r3, r7
 4601 0124 0F33     		add	r3, r3, #15
 4602 0126 1B78     		ldrb	r3, [r3]
 4603 0128 1343     		orr	r3, r2
 4604 012a DAB2     		uxtb	r2, r3
 4605 012c 3B1C     		mov	r3, r7
 4606 012e 0F33     		add	r3, r3, #15
 4607 0130 2021     		mov	r1, #32
 4608 0132 0A43     		orr	r2, r1
 4609 0134 1A70     		strb	r2, [r3]
 4610              	.L352:
1071:../Sources/mcg.c ****   }
1072:../Sources/mcg.c ****   MCG_C2 = temp_reg;
 4611              		.loc 1 1072 0
 4612 0136 6F4B     		ldr	r3, .L378
 4613 0138 3A1C     		mov	r2, r7
 4614 013a 0F32     		add	r2, r2, #15
 4615 013c 1278     		ldrb	r2, [r2]
 4616 013e 5A70     		strb	r2, [r3, #1]
1073:../Sources/mcg.c **** 
1074:../Sources/mcg.c **** // determine FRDIV based on reference clock frequency
1075:../Sources/mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1076:../Sources/mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4617              		.loc 1 1076 0
 4618 0140 7A68     		ldr	r2, [r7, #4]
 4619 0142 734B     		ldr	r3, .L378+28
 4620 0144 9A42     		cmp	r2, r3
 4621 0146 04DC     		bgt	.L354
 4622              		.loc 1 1076 0 is_stmt 0 discriminator 1
 4623 0148 3B1C     		mov	r3, r7
 4624 014a 0E33     		add	r3, r3, #14
 4625 014c 0022     		mov	r2, #0
 4626 014e 1A70     		strb	r2, [r3]
 4627 0150 27E0     		b	.L355
 4628              	.L354:
1077:../Sources/mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4629              		.loc 1 1077 0 is_stmt 1
 4630 0152 7A68     		ldr	r2, [r7, #4]
 4631 0154 6F4B     		ldr	r3, .L378+32
 4632 0156 9A42     		cmp	r2, r3
 4633 0158 04DC     		bgt	.L356
 4634              		.loc 1 1077 0 is_stmt 0 discriminator 1
 4635 015a 3B1C     		mov	r3, r7
 4636 015c 0E33     		add	r3, r3, #14
 4637 015e 0122     		mov	r2, #1
 4638 0160 1A70     		strb	r2, [r3]
 4639 0162 1EE0     		b	.L355
 4640              	.L356:
1078:../Sources/mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4641              		.loc 1 1078 0 is_stmt 1
 4642 0164 7A68     		ldr	r2, [r7, #4]
 4643 0166 6C4B     		ldr	r3, .L378+36
 4644 0168 9A42     		cmp	r2, r3
 4645 016a 04DC     		bgt	.L357
 4646              		.loc 1 1078 0 is_stmt 0 discriminator 1
 4647 016c 3B1C     		mov	r3, r7
 4648 016e 0E33     		add	r3, r3, #14
 4649 0170 0222     		mov	r2, #2
 4650 0172 1A70     		strb	r2, [r3]
 4651 0174 15E0     		b	.L355
 4652              	.L357:
1079:../Sources/mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4653              		.loc 1 1079 0 is_stmt 1
 4654 0176 7A68     		ldr	r2, [r7, #4]
 4655 0178 684B     		ldr	r3, .L378+40
 4656 017a 9A42     		cmp	r2, r3
 4657 017c 04DC     		bgt	.L358
 4658              		.loc 1 1079 0 is_stmt 0 discriminator 1
 4659 017e 3B1C     		mov	r3, r7
 4660 0180 0E33     		add	r3, r3, #14
 4661 0182 0322     		mov	r2, #3
 4662 0184 1A70     		strb	r2, [r3]
 4663 0186 0CE0     		b	.L355
 4664              	.L358:
1080:../Sources/mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4665              		.loc 1 1080 0 is_stmt 1
 4666 0188 7A68     		ldr	r2, [r7, #4]
 4667 018a 654B     		ldr	r3, .L378+44
 4668 018c 9A42     		cmp	r2, r3
 4669 018e 04DC     		bgt	.L359
 4670              		.loc 1 1080 0 is_stmt 0 discriminator 1
 4671 0190 3B1C     		mov	r3, r7
 4672 0192 0E33     		add	r3, r3, #14
 4673 0194 0422     		mov	r2, #4
 4674 0196 1A70     		strb	r2, [r3]
 4675 0198 03E0     		b	.L355
 4676              	.L359:
1081:../Sources/mcg.c ****   else {frdiv_val = 5;}
 4677              		.loc 1 1081 0 is_stmt 1
 4678 019a 3B1C     		mov	r3, r7
 4679 019c 0E33     		add	r3, r3, #14
 4680 019e 0522     		mov	r2, #5
 4681 01a0 1A70     		strb	r2, [r3]
 4682              	.L355:
1082:../Sources/mcg.c ****   
1083:../Sources/mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1084:../Sources/mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1085:../Sources/mcg.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1086:../Sources/mcg.c ****   temp_reg = MCG_C1;
 4683              		.loc 1 1086 0
 4684 01a2 544A     		ldr	r2, .L378
 4685 01a4 3B1C     		mov	r3, r7
 4686 01a6 0F33     		add	r3, r3, #15
 4687 01a8 1278     		ldrb	r2, [r2]
 4688 01aa 1A70     		strb	r2, [r3]
1087:../Sources/mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 4689              		.loc 1 1087 0
 4690 01ac 3B1C     		mov	r3, r7
 4691 01ae 0F33     		add	r3, r3, #15
 4692 01b0 3A1C     		mov	r2, r7
 4693 01b2 0F32     		add	r2, r2, #15
 4694 01b4 1178     		ldrb	r1, [r2]
 4695 01b6 0322     		mov	r2, #3
 4696 01b8 0A40     		and	r2, r1
 4697 01ba 1A70     		strb	r2, [r3]
1088:../Sources/mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 4698              		.loc 1 1088 0
 4699 01bc 3B1C     		mov	r3, r7
 4700 01be 0E33     		add	r3, r3, #14
 4701 01c0 1B78     		ldrb	r3, [r3]
 4702 01c2 DB00     		lsl	r3, r3, #3
 4703 01c4 DAB2     		uxtb	r2, r3
 4704 01c6 3823     		mov	r3, #56
 4705 01c8 1340     		and	r3, r2
 4706 01ca DAB2     		uxtb	r2, r3
 4707 01cc 3B1C     		mov	r3, r7
 4708 01ce 0F33     		add	r3, r3, #15
 4709 01d0 1B78     		ldrb	r3, [r3]
 4710 01d2 1343     		orr	r3, r2
 4711 01d4 DAB2     		uxtb	r2, r3
 4712 01d6 3B1C     		mov	r3, r7
 4713 01d8 0F33     		add	r3, r3, #15
 4714 01da 8021     		mov	r1, #128
 4715 01dc 4942     		neg	r1, r1
 4716 01de 0A43     		orr	r2, r1
 4717 01e0 1A70     		strb	r2, [r3]
1089:../Sources/mcg.c ****   MCG_C1 = temp_reg;
 4718              		.loc 1 1089 0
 4719 01e2 444B     		ldr	r3, .L378
 4720 01e4 3A1C     		mov	r2, r7
 4721 01e6 0F32     		add	r2, r2, #15
 4722 01e8 1278     		ldrb	r2, [r2]
 4723 01ea 1A70     		strb	r2, [r3]
1090:../Sources/mcg.c **** 
1091:../Sources/mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
1092:../Sources/mcg.c ****   if (erefs_val)
 4724              		.loc 1 1092 0
 4725 01ec BB1C     		add	r3, r7, #2
 4726 01ee 1B78     		ldrb	r3, [r3]
 4727 01f0 002B     		cmp	r3, #0
 4728 01f2 24D0     		beq	.L360
1093:../Sources/mcg.c ****   {
1094:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 4729              		.loc 1 1094 0
 4730 01f4 3B1C     		mov	r3, r7
 4731 01f6 0C33     		add	r3, r3, #12
 4732 01f8 0022     		mov	r2, #0
 4733 01fa 1A80     		strh	r2, [r3]
 4734 01fc 0DE0     		b	.L361
 4735              	.L364:
1095:../Sources/mcg.c ****     {
1096:../Sources/mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4736              		.loc 1 1096 0
 4737 01fe 3D4B     		ldr	r3, .L378
 4738 0200 9B79     		ldrb	r3, [r3, #6]
 4739 0202 DBB2     		uxtb	r3, r3
 4740 0204 1A1C     		mov	r2, r3
 4741 0206 0223     		mov	r3, #2
 4742 0208 1340     		and	r3, r2
 4743 020a 0ED1     		bne	.L375
 4744              	.L362:
1094:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 4745              		.loc 1 1094 0
 4746 020c 3B1C     		mov	r3, r7
 4747 020e 0C33     		add	r3, r3, #12
 4748 0210 3A1C     		mov	r2, r7
 4749 0212 0C32     		add	r2, r2, #12
 4750 0214 1288     		ldrh	r2, [r2]
 4751 0216 0132     		add	r2, r2, #1
 4752 0218 1A80     		strh	r2, [r3]
 4753              	.L361:
1094:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 4754              		.loc 1 1094 0 is_stmt 0 discriminator 1
 4755 021a 3B1C     		mov	r3, r7
 4756 021c 0C33     		add	r3, r3, #12
 4757 021e 0021     		mov	r1, #0
 4758 0220 5A5E     		ldrsh	r2, [r3, r1]
 4759 0222 404B     		ldr	r3, .L378+48
 4760 0224 9A42     		cmp	r2, r3
 4761 0226 EADD     		ble	.L364
 4762 0228 00E0     		b	.L363
 4763              	.L375:
 4764              		.loc 1 1096 0 is_stmt 1
 4765 022a C046     		mov	r8, r8
 4766              	.L363:
1097:../Sources/mcg.c ****     }
1098:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 4767              		.loc 1 1098 0
 4768 022c 314B     		ldr	r3, .L378
 4769 022e 9B79     		ldrb	r3, [r3, #6]
 4770 0230 DBB2     		uxtb	r3, r3
 4771 0232 1A1C     		mov	r2, r3
 4772 0234 0223     		mov	r3, #2
 4773 0236 1340     		and	r3, r2
 4774 0238 01D1     		bne	.L360
 4775              		.loc 1 1098 0 is_stmt 0 discriminator 1
 4776 023a 2323     		mov	r3, #35
 4777 023c 56E0     		b	.L345
 4778              	.L360:
1099:../Sources/mcg.c ****   }
1100:../Sources/mcg.c **** 
1101:../Sources/mcg.c **** // wait for Reference clock Status bit to clear
1102:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4779              		.loc 1 1102 0 is_stmt 1
 4780 023e 3B1C     		mov	r3, r7
 4781 0240 0C33     		add	r3, r3, #12
 4782 0242 0022     		mov	r2, #0
 4783 0244 1A80     		strh	r2, [r3]
 4784 0246 0DE0     		b	.L365
 4785              	.L368:
1103:../Sources/mcg.c ****   {
1104:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4786              		.loc 1 1104 0
 4787 0248 2A4B     		ldr	r3, .L378
 4788 024a 9B79     		ldrb	r3, [r3, #6]
 4789 024c DBB2     		uxtb	r3, r3
 4790 024e 1A1C     		mov	r2, r3
 4791 0250 1023     		mov	r3, #16
 4792 0252 1340     		and	r3, r2
 4793 0254 0ED0     		beq	.L376
 4794              	.L366:
1102:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4795              		.loc 1 1102 0
 4796 0256 3B1C     		mov	r3, r7
 4797 0258 0C33     		add	r3, r3, #12
 4798 025a 3A1C     		mov	r2, r7
 4799 025c 0C32     		add	r2, r2, #12
 4800 025e 1288     		ldrh	r2, [r2]
 4801 0260 0132     		add	r2, r2, #1
 4802 0262 1A80     		strh	r2, [r3]
 4803              	.L365:
1102:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4804              		.loc 1 1102 0 is_stmt 0 discriminator 1
 4805 0264 3B1C     		mov	r3, r7
 4806 0266 0C33     		add	r3, r3, #12
 4807 0268 0021     		mov	r1, #0
 4808 026a 5A5E     		ldrsh	r2, [r3, r1]
 4809 026c 2E4B     		ldr	r3, .L378+52
 4810 026e 9A42     		cmp	r2, r3
 4811 0270 EADD     		ble	.L368
 4812 0272 00E0     		b	.L367
 4813              	.L376:
 4814              		.loc 1 1104 0 is_stmt 1
 4815 0274 C046     		mov	r8, r8
 4816              	.L367:
1105:../Sources/mcg.c ****   }
1106:../Sources/mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 4817              		.loc 1 1106 0
 4818 0276 1F4B     		ldr	r3, .L378
 4819 0278 9B79     		ldrb	r3, [r3, #6]
 4820 027a DBB2     		uxtb	r3, r3
 4821 027c 1A1C     		mov	r2, r3
 4822 027e 1023     		mov	r3, #16
 4823 0280 1340     		and	r3, r2
 4824 0282 01D0     		beq	.L369
 4825              		.loc 1 1106 0 is_stmt 0 discriminator 1
 4826 0284 1123     		mov	r3, #17
 4827 0286 31E0     		b	.L345
 4828              	.L369:
1107:../Sources/mcg.c ****   
1108:../Sources/mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
1109:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4829              		.loc 1 1109 0 is_stmt 1
 4830 0288 3B1C     		mov	r3, r7
 4831 028a 0C33     		add	r3, r3, #12
 4832 028c 0022     		mov	r2, #0
 4833 028e 1A80     		strh	r2, [r3]
 4834 0290 0FE0     		b	.L370
 4835              	.L373:
1110:../Sources/mcg.c ****   {
1111:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 4836              		.loc 1 1111 0
 4837 0292 184B     		ldr	r3, .L378
 4838 0294 9B79     		ldrb	r3, [r3, #6]
 4839 0296 DBB2     		uxtb	r3, r3
 4840 0298 1A1C     		mov	r2, r3
 4841 029a 0C23     		mov	r3, #12
 4842 029c 1340     		and	r3, r2
 4843 029e 9B08     		lsr	r3, r3, #2
 4844 02a0 022B     		cmp	r3, #2
 4845 02a2 0ED0     		beq	.L377
 4846              	.L371:
1109:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4847              		.loc 1 1109 0
 4848 02a4 3B1C     		mov	r3, r7
 4849 02a6 0C33     		add	r3, r3, #12
 4850 02a8 3A1C     		mov	r2, r7
 4851 02aa 0C32     		add	r2, r2, #12
 4852 02ac 1288     		ldrh	r2, [r2]
 4853 02ae 0132     		add	r2, r2, #1
 4854 02b0 1A80     		strh	r2, [r3]
 4855              	.L370:
1109:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4856              		.loc 1 1109 0 is_stmt 0 discriminator 1
 4857 02b2 3B1C     		mov	r3, r7
 4858 02b4 0C33     		add	r3, r3, #12
 4859 02b6 0021     		mov	r1, #0
 4860 02b8 5A5E     		ldrsh	r2, [r3, r1]
 4861 02ba 1B4B     		ldr	r3, .L378+52
 4862 02bc 9A42     		cmp	r2, r3
 4863 02be E8DD     		ble	.L373
 4864 02c0 00E0     		b	.L372
 4865              	.L377:
 4866              		.loc 1 1111 0 is_stmt 1
 4867 02c2 C046     		mov	r8, r8
 4868              	.L372:
1112:../Sources/mcg.c ****   }
1113:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 4869              		.loc 1 1113 0
 4870 02c4 0B4B     		ldr	r3, .L378
 4871 02c6 9B79     		ldrb	r3, [r3, #6]
 4872 02c8 DBB2     		uxtb	r3, r3
 4873 02ca 1A1C     		mov	r2, r3
 4874 02cc 0C23     		mov	r3, #12
 4875 02ce 1340     		and	r3, r2
 4876 02d0 9B08     		lsr	r3, r3, #2
 4877 02d2 022B     		cmp	r3, #2
 4878 02d4 01D0     		beq	.L374
 4879              		.loc 1 1113 0 is_stmt 0 discriminator 1
 4880 02d6 1A23     		mov	r3, #26
 4881 02d8 08E0     		b	.L345
 4882              	.L374:
1114:../Sources/mcg.c ****  
1115:../Sources/mcg.c **** // Now in FBE  
1116:../Sources/mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1117:../Sources/mcg.c **** // It is enabled here but can be removed if this is not required.
1118:../Sources/mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 4883              		.loc 1 1118 0 is_stmt 1
 4884 02da 064B     		ldr	r3, .L378
 4885 02dc 054A     		ldr	r2, .L378
 4886 02de 5279     		ldrb	r2, [r2, #5]
 4887 02e0 D2B2     		uxtb	r2, r2
 4888 02e2 2021     		mov	r1, #32
 4889 02e4 0A43     		orr	r2, r1
 4890 02e6 D2B2     		uxtb	r2, r2
 4891 02e8 5A71     		strb	r2, [r3, #5]
1119:../Sources/mcg.c ****   
1120:../Sources/mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 4892              		.loc 1 1120 0
 4893 02ea 7B68     		ldr	r3, [r7, #4]
 4894              	.L345:
1121:../Sources/mcg.c **** } // fbi_fbe
 4895              		.loc 1 1121 0
 4896 02ec 181C     		mov	r0, r3
 4897 02ee BD46     		mov	sp, r7
 4898 02f0 04B0     		add	sp, sp, #16
 4899              		@ sp needed for prologue
 4900 02f2 80BD     		pop	{r7, pc}
 4901              	.L379:
 4902              		.align	2
 4903              	.L378:
 4904 02f4 00400640 		.word	1074151424
 4905 02f8 80F0FA02 		.word	50000000
 4906 02fc 2F750000 		.word	29999
 4907 0300 409C0000 		.word	40000
 4908 0304 BFC62D00 		.word	2999999
 4909 0308 0048E801 		.word	32000000
 4910 030c 00127A00 		.word	8000000
 4911 0310 D0121300 		.word	1250000
 4912 0314 A0252600 		.word	2500000
 4913 0318 404B4C00 		.word	5000000
 4914 031c 80969800 		.word	10000000
 4915 0320 002D3101 		.word	20000000
 4916 0324 0F270000 		.word	9999
 4917 0328 CF070000 		.word	1999
 4918              		.cfi_endproc
 4919              	.LFE15:
 4921              		.section	.text.fbi_blpi,"ax",%progbits
 4922              		.align	2
 4923              		.global	fbi_blpi
 4924              		.code	16
 4925              		.thumb_func
 4927              	fbi_blpi:
 4928              	.LFB16:
1122:../Sources/mcg.c **** 
1123:../Sources/mcg.c **** 
1124:../Sources/mcg.c **** /********************************************************************/
1125:../Sources/mcg.c **** /* Functon name : fbi_blpi
1126:../Sources/mcg.c ****  *
1127:../Sources/mcg.c ****  * Mode transition: FBI to BLPI mode
1128:../Sources/mcg.c ****  *
1129:../Sources/mcg.c ****  * This function transitions the MCG from FBI mode to BLPI mode. This is
1130:../Sources/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1131:../Sources/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1132:../Sources/mcg.c ****  * in FBI mode. 
1133:../Sources/mcg.c ****  *
1134:../Sources/mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1135:../Sources/mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1136:../Sources/mcg.c ****  *
1137:../Sources/mcg.c ****  * Return value : MCGOUT frequency or error code 0x13
1138:../Sources/mcg.c ****  */
1139:../Sources/mcg.c **** int fbi_blpi(int irc_freq, unsigned char irc_select)
1140:../Sources/mcg.c **** {
 4929              		.loc 1 1140 0
 4930              		.cfi_startproc
 4931 0000 80B5     		push	{r7, lr}
 4932              	.LCFI48:
 4933              		.cfi_def_cfa_offset 8
 4934              		.cfi_offset 7, -8
 4935              		.cfi_offset 14, -4
 4936 0002 84B0     		sub	sp, sp, #16
 4937              	.LCFI49:
 4938              		.cfi_def_cfa_offset 24
 4939 0004 00AF     		add	r7, sp, #0
 4940              	.LCFI50:
 4941              		.cfi_def_cfa_register 7
 4942 0006 7860     		str	r0, [r7, #4]
 4943 0008 0A1C     		mov	r2, r1
 4944 000a FB1C     		add	r3, r7, #3
 4945 000c 1A70     		strb	r2, [r3]
1141:../Sources/mcg.c ****   unsigned char fcrdiv_val;
1142:../Sources/mcg.c ****   
1143:../Sources/mcg.c **** // check if in FBI mode
1144:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4946              		.loc 1 1144 0
 4947 000e 234B     		ldr	r3, .L385
 4948 0010 9B79     		ldrb	r3, [r3, #6]
 4949 0012 DBB2     		uxtb	r3, r3
 4950 0014 1A1C     		mov	r2, r3
 4951 0016 0C23     		mov	r3, #12
 4952 0018 1340     		and	r3, r2
 4953 001a 9B08     		lsr	r3, r3, #2
 4954 001c 012B     		cmp	r3, #1
 4955 001e 14D1     		bne	.L381
1145:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4956              		.loc 1 1145 0 discriminator 1
 4957 0020 1E4B     		ldr	r3, .L385
 4958 0022 9B79     		ldrb	r3, [r3, #6]
 4959 0024 DBB2     		uxtb	r3, r3
 4960 0026 1A1C     		mov	r2, r3
 4961 0028 1023     		mov	r3, #16
 4962 002a 1340     		and	r3, r2
1144:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4963              		.loc 1 1144 0 discriminator 1
 4964 002c 0DD0     		beq	.L381
1146:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4965              		.loc 1 1146 0
 4966 002e 1B4B     		ldr	r3, .L385
 4967 0030 9B79     		ldrb	r3, [r3, #6]
 4968 0032 DBB2     		uxtb	r3, r3
 4969 0034 1A1C     		mov	r2, r3
 4970 0036 2023     		mov	r3, #32
 4971 0038 1340     		and	r3, r2
1145:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4972              		.loc 1 1145 0
 4973 003a 06D1     		bne	.L381
1147:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4974              		.loc 1 1147 0
 4975 003c 174B     		ldr	r3, .L385
 4976 003e 5B78     		ldrb	r3, [r3, #1]
 4977 0040 DBB2     		uxtb	r3, r3
 4978 0042 1A1C     		mov	r2, r3
 4979 0044 0223     		mov	r3, #2
 4980 0046 1340     		and	r3, r2
1144:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4981              		.loc 1 1144 0
 4982 0048 01D0     		beq	.L382
 4983              	.L381:
1148:../Sources/mcg.c ****   {  
1149:../Sources/mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 4984              		.loc 1 1149 0
 4985 004a 0323     		mov	r3, #3
 4986 004c 21E0     		b	.L383
 4987              	.L382:
1150:../Sources/mcg.c ****   }
1151:../Sources/mcg.c **** 
1152:../Sources/mcg.c **** // Set LP bit to disable the FLL and enter BLPI
1153:../Sources/mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 4988              		.loc 1 1153 0
 4989 004e 134B     		ldr	r3, .L385
 4990 0050 124A     		ldr	r2, .L385
 4991 0052 5278     		ldrb	r2, [r2, #1]
 4992 0054 D2B2     		uxtb	r2, r2
 4993 0056 0221     		mov	r1, #2
 4994 0058 0A43     		orr	r2, r1
 4995 005a D2B2     		uxtb	r2, r2
 4996 005c 5A70     		strb	r2, [r3, #1]
1154:../Sources/mcg.c ****   
1155:../Sources/mcg.c **** // Now in BLPI
1156:../Sources/mcg.c ****   if (irc_select)
 4997              		.loc 1 1156 0
 4998 005e FB1C     		add	r3, r7, #3
 4999 0060 1B78     		ldrb	r3, [r3]
 5000 0062 002B     		cmp	r3, #0
 5001 0064 14D0     		beq	.L384
1157:../Sources/mcg.c ****   {
1158:../Sources/mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 5002              		.loc 1 1158 0
 5003 0066 0D4B     		ldr	r3, .L385
 5004 0068 1B7A     		ldrb	r3, [r3, #8]
 5005 006a DBB2     		uxtb	r3, r3
 5006 006c 1A1C     		mov	r2, r3
 5007 006e 0E23     		mov	r3, #14
 5008 0070 1340     		and	r3, r2
 5009 0072 5B08     		lsr	r3, r3, #1
 5010 0074 0122     		mov	r2, #1
 5011 0076 9A40     		lsl	r2, r2, r3
 5012 0078 3B1C     		mov	r3, r7
 5013 007a 0F33     		add	r3, r3, #15
 5014 007c 1A70     		strb	r2, [r3]
1159:../Sources/mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 5015              		.loc 1 1159 0
 5016 007e 3B1C     		mov	r3, r7
 5017 0080 0F33     		add	r3, r3, #15
 5018 0082 1B78     		ldrb	r3, [r3]
 5019 0084 7868     		ldr	r0, [r7, #4]
 5020 0086 191C     		mov	r1, r3
 5021 0088 FFF7FEFF 		bl	__aeabi_idiv
 5022 008c 031C     		mov	r3, r0
 5023 008e 00E0     		b	.L383
 5024              	.L384:
1160:../Sources/mcg.c ****   }
1161:../Sources/mcg.c ****   else
1162:../Sources/mcg.c ****   {
1163:../Sources/mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 5025              		.loc 1 1163 0
 5026 0090 7B68     		ldr	r3, [r7, #4]
 5027              	.L383:
1164:../Sources/mcg.c ****   }   
1165:../Sources/mcg.c **** } // fbi_blpi
 5028              		.loc 1 1165 0
 5029 0092 181C     		mov	r0, r3
 5030 0094 BD46     		mov	sp, r7
 5031 0096 04B0     		add	sp, sp, #16
 5032              		@ sp needed for prologue
 5033 0098 80BD     		pop	{r7, pc}
 5034              	.L386:
 5035 009a C046     		.align	2
 5036              	.L385:
 5037 009c 00400640 		.word	1074151424
 5038              		.cfi_endproc
 5039              	.LFE16:
 5041              		.section	.text.blpi_fbi,"ax",%progbits
 5042              		.align	2
 5043              		.global	blpi_fbi
 5044              		.code	16
 5045              		.thumb_func
 5047              	blpi_fbi:
 5048              	.LFB17:
1166:../Sources/mcg.c **** 
1167:../Sources/mcg.c **** 
1168:../Sources/mcg.c **** 
1169:../Sources/mcg.c **** /********************************************************************/
1170:../Sources/mcg.c **** /* Functon name : blpi_fbi
1171:../Sources/mcg.c ****  *
1172:../Sources/mcg.c ****  * Mode transition: BLPI to FBI mode
1173:../Sources/mcg.c ****  *
1174:../Sources/mcg.c ****  * This function transitions the MCG from BLPI mode to FBI mode. This is
1175:../Sources/mcg.c ****  * achieved by clearing the MCG_C2[LP] bit. There is no status bit to 
1176:../Sources/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1177:../Sources/mcg.c ****  * in BLPI mode. 
1178:../Sources/mcg.c ****  *
1179:../Sources/mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1180:../Sources/mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1181:../Sources/mcg.c ****  *
1182:../Sources/mcg.c ****  * Return value : MCGOUT frequency or error code 0x15
1183:../Sources/mcg.c ****  */
1184:../Sources/mcg.c **** int blpi_fbi(int irc_freq, unsigned char irc_select)
1185:../Sources/mcg.c **** {
 5049              		.loc 1 1185 0
 5050              		.cfi_startproc
 5051 0000 80B5     		push	{r7, lr}
 5052              	.LCFI51:
 5053              		.cfi_def_cfa_offset 8
 5054              		.cfi_offset 7, -8
 5055              		.cfi_offset 14, -4
 5056 0002 84B0     		sub	sp, sp, #16
 5057              	.LCFI52:
 5058              		.cfi_def_cfa_offset 24
 5059 0004 00AF     		add	r7, sp, #0
 5060              	.LCFI53:
 5061              		.cfi_def_cfa_register 7
 5062 0006 7860     		str	r0, [r7, #4]
 5063 0008 0A1C     		mov	r2, r1
 5064 000a FB1C     		add	r3, r7, #3
 5065 000c 1A70     		strb	r2, [r3]
1186:../Sources/mcg.c ****   unsigned char fcrdiv_val;
1187:../Sources/mcg.c ****   // check if in BLPI mode
1188:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5066              		.loc 1 1188 0
 5067 000e 234B     		ldr	r3, .L392
 5068 0010 9B79     		ldrb	r3, [r3, #6]
 5069 0012 DBB2     		uxtb	r3, r3
 5070 0014 1A1C     		mov	r2, r3
 5071 0016 0C23     		mov	r3, #12
 5072 0018 1340     		and	r3, r2
 5073 001a 9B08     		lsr	r3, r3, #2
 5074 001c 012B     		cmp	r3, #1
 5075 001e 14D1     		bne	.L388
1189:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 5076              		.loc 1 1189 0 discriminator 1
 5077 0020 1E4B     		ldr	r3, .L392
 5078 0022 9B79     		ldrb	r3, [r3, #6]
 5079 0024 DBB2     		uxtb	r3, r3
 5080 0026 1A1C     		mov	r2, r3
 5081 0028 1023     		mov	r3, #16
 5082 002a 1340     		and	r3, r2
1188:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5083              		.loc 1 1188 0 discriminator 1
 5084 002c 0DD0     		beq	.L388
1190:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 5085              		.loc 1 1190 0
 5086 002e 1B4B     		ldr	r3, .L392
 5087 0030 9B79     		ldrb	r3, [r3, #6]
 5088 0032 DBB2     		uxtb	r3, r3
 5089 0034 1A1C     		mov	r2, r3
 5090 0036 2023     		mov	r3, #32
 5091 0038 1340     		and	r3, r2
1189:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 5092              		.loc 1 1189 0
 5093 003a 06D1     		bne	.L388
1191:../Sources/mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
 5094              		.loc 1 1191 0
 5095 003c 174B     		ldr	r3, .L392
 5096 003e 5B78     		ldrb	r3, [r3, #1]
 5097 0040 DBB2     		uxtb	r3, r3
 5098 0042 1A1C     		mov	r2, r3
 5099 0044 0223     		mov	r3, #2
 5100 0046 1340     		and	r3, r2
1188:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5101              		.loc 1 1188 0
 5102 0048 01D1     		bne	.L389
 5103              	.L388:
1192:../Sources/mcg.c ****   {
1193:../Sources/mcg.c ****     return 0x5;                                                       // MCG not in correct mode re
 5104              		.loc 1 1193 0
 5105 004a 0523     		mov	r3, #5
 5106 004c 21E0     		b	.L390
 5107              	.L389:
1194:../Sources/mcg.c ****   }
1195:../Sources/mcg.c **** 
1196:../Sources/mcg.c **** // Clear LP bit to enable the FLL and enter FBI mode   
1197:../Sources/mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 5108              		.loc 1 1197 0
 5109 004e 134B     		ldr	r3, .L392
 5110 0050 124A     		ldr	r2, .L392
 5111 0052 5278     		ldrb	r2, [r2, #1]
 5112 0054 D2B2     		uxtb	r2, r2
 5113 0056 0221     		mov	r1, #2
 5114 0058 8A43     		bic	r2, r1
 5115 005a D2B2     		uxtb	r2, r2
 5116 005c 5A70     		strb	r2, [r3, #1]
1198:../Sources/mcg.c ****   
1199:../Sources/mcg.c **** // Now in FBI mode
1200:../Sources/mcg.c ****   if (irc_select)
 5117              		.loc 1 1200 0
 5118 005e FB1C     		add	r3, r7, #3
 5119 0060 1B78     		ldrb	r3, [r3]
 5120 0062 002B     		cmp	r3, #0
 5121 0064 14D0     		beq	.L391
1201:../Sources/mcg.c ****   {
1202:../Sources/mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 5122              		.loc 1 1202 0
 5123 0066 0D4B     		ldr	r3, .L392
 5124 0068 1B7A     		ldrb	r3, [r3, #8]
 5125 006a DBB2     		uxtb	r3, r3
 5126 006c 1A1C     		mov	r2, r3
 5127 006e 0E23     		mov	r3, #14
 5128 0070 1340     		and	r3, r2
 5129 0072 5B08     		lsr	r3, r3, #1
 5130 0074 0122     		mov	r2, #1
 5131 0076 9A40     		lsl	r2, r2, r3
 5132 0078 3B1C     		mov	r3, r7
 5133 007a 0F33     		add	r3, r3, #15
 5134 007c 1A70     		strb	r2, [r3]
1203:../Sources/mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 5135              		.loc 1 1203 0
 5136 007e 3B1C     		mov	r3, r7
 5137 0080 0F33     		add	r3, r3, #15
 5138 0082 1B78     		ldrb	r3, [r3]
 5139 0084 7868     		ldr	r0, [r7, #4]
 5140 0086 191C     		mov	r1, r3
 5141 0088 FFF7FEFF 		bl	__aeabi_idiv
 5142 008c 031C     		mov	r3, r0
 5143 008e 00E0     		b	.L390
 5144              	.L391:
1204:../Sources/mcg.c ****   }
1205:../Sources/mcg.c ****   else
1206:../Sources/mcg.c ****   {
1207:../Sources/mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 5145              		.loc 1 1207 0
 5146 0090 7B68     		ldr	r3, [r7, #4]
 5147              	.L390:
1208:../Sources/mcg.c ****   }
1209:../Sources/mcg.c **** } // blpi_fbi
 5148              		.loc 1 1209 0
 5149 0092 181C     		mov	r0, r3
 5150 0094 BD46     		mov	sp, r7
 5151 0096 04B0     		add	sp, sp, #16
 5152              		@ sp needed for prologue
 5153 0098 80BD     		pop	{r7, pc}
 5154              	.L393:
 5155 009a C046     		.align	2
 5156              	.L392:
 5157 009c 00400640 		.word	1074151424
 5158              		.cfi_endproc
 5159              	.LFE17:
 5161              		.section	.text.fbi_fee,"ax",%progbits
 5162              		.align	2
 5163              		.global	fbi_fee
 5164              		.code	16
 5165              		.thumb_func
 5167              	fbi_fee:
 5168              	.LFB18:
1210:../Sources/mcg.c **** 
1211:../Sources/mcg.c **** 
1212:../Sources/mcg.c **** int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1213:../Sources/mcg.c **** {
 5169              		.loc 1 1213 0
 5170              		.cfi_startproc
 5171 0000 80B5     		push	{r7, lr}
 5172              	.LCFI54:
 5173              		.cfi_def_cfa_offset 8
 5174              		.cfi_offset 7, -8
 5175              		.cfi_offset 14, -4
 5176 0002 86B0     		sub	sp, sp, #24
 5177              	.LCFI55:
 5178              		.cfi_def_cfa_offset 32
 5179 0004 00AF     		add	r7, sp, #0
 5180              	.LCFI56:
 5181              		.cfi_def_cfa_register 7
 5182 0006 7860     		str	r0, [r7, #4]
 5183 0008 FB1C     		add	r3, r7, #3
 5184 000a 1970     		strb	r1, [r3]
 5185 000c BB1C     		add	r3, r7, #2
 5186 000e 1A70     		strb	r2, [r3]
1214:../Sources/mcg.c ****   unsigned char temp_reg;
1215:../Sources/mcg.c ****   unsigned char frdiv_val;
1216:../Sources/mcg.c ****   short i;
1217:../Sources/mcg.c ****   int mcg_out, fll_ref_freq;
1218:../Sources/mcg.c **** 
1219:../Sources/mcg.c **** // check if in FBI mode
1220:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5187              		.loc 1 1220 0
 5188 0010 C04B     		ldr	r3, .L433
 5189 0012 9B79     		ldrb	r3, [r3, #6]
 5190 0014 DBB2     		uxtb	r3, r3
 5191 0016 1A1C     		mov	r2, r3
 5192 0018 0C23     		mov	r3, #12
 5193 001a 1340     		and	r3, r2
 5194 001c 9B08     		lsr	r3, r3, #2
 5195 001e 012B     		cmp	r3, #1
 5196 0020 14D1     		bne	.L395
1221:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 5197              		.loc 1 1221 0 discriminator 1
 5198 0022 BC4B     		ldr	r3, .L433
 5199 0024 9B79     		ldrb	r3, [r3, #6]
 5200 0026 DBB2     		uxtb	r3, r3
 5201 0028 1A1C     		mov	r2, r3
 5202 002a 1023     		mov	r3, #16
 5203 002c 1340     		and	r3, r2
1220:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5204              		.loc 1 1220 0 discriminator 1
 5205 002e 0DD0     		beq	.L395
1222:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 5206              		.loc 1 1222 0
 5207 0030 B84B     		ldr	r3, .L433
 5208 0032 9B79     		ldrb	r3, [r3, #6]
 5209 0034 DBB2     		uxtb	r3, r3
 5210 0036 1A1C     		mov	r2, r3
 5211 0038 2023     		mov	r3, #32
 5212 003a 1340     		and	r3, r2
1221:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 5213              		.loc 1 1221 0
 5214 003c 06D1     		bne	.L395
1223:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 5215              		.loc 1 1223 0
 5216 003e B54B     		ldr	r3, .L433
 5217 0040 5B78     		ldrb	r3, [r3, #1]
 5218 0042 DBB2     		uxtb	r3, r3
 5219 0044 1A1C     		mov	r2, r3
 5220 0046 0223     		mov	r3, #2
 5221 0048 1340     		and	r3, r2
1220:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 5222              		.loc 1 1220 0
 5223 004a 01D0     		beq	.L396
 5224              	.L395:
1224:../Sources/mcg.c ****   {  
1225:../Sources/mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 5225              		.loc 1 1225 0
 5226 004c 0323     		mov	r3, #3
 5227 004e 91E1     		b	.L397
 5228              	.L396:
1226:../Sources/mcg.c ****   }
1227:../Sources/mcg.c ****   
1228:../Sources/mcg.c **** // check external frequency is less than the maximum frequency
1229:../Sources/mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 5229              		.loc 1 1229 0
 5230 0050 7A68     		ldr	r2, [r7, #4]
 5231 0052 B14B     		ldr	r3, .L433+4
 5232 0054 9A42     		cmp	r2, r3
 5233 0056 01DD     		ble	.L398
 5234              		.loc 1 1229 0 is_stmt 0 discriminator 1
 5235 0058 2123     		mov	r3, #33
 5236 005a 8BE1     		b	.L397
 5237              	.L398:
1230:../Sources/mcg.c ****   
1231:../Sources/mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
1232:../Sources/mcg.c ****   if (erefs_val)
 5238              		.loc 1 1232 0 is_stmt 1
 5239 005c BB1C     		add	r3, r7, #2
 5240 005e 1B78     		ldrb	r3, [r3]
 5241 0060 002B     		cmp	r3, #0
 5242 0062 11D0     		beq	.L399
1233:../Sources/mcg.c ****   {
1234:../Sources/mcg.c ****     if ((crystal_val < 30000) ||
 5243              		.loc 1 1234 0
 5244 0064 7A68     		ldr	r2, [r7, #4]
 5245 0066 AD4B     		ldr	r3, .L433+8
 5246 0068 9A42     		cmp	r2, r3
 5247 006a 0BDD     		ble	.L400
 5248              		.loc 1 1234 0 is_stmt 0 discriminator 1
 5249 006c 7A68     		ldr	r2, [r7, #4]
 5250 006e AC4B     		ldr	r3, .L433+12
 5251 0070 9A42     		cmp	r2, r3
 5252 0072 03DD     		ble	.L401
1235:../Sources/mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 5253              		.loc 1 1235 0 is_stmt 1
 5254 0074 7A68     		ldr	r2, [r7, #4]
 5255 0076 AB4B     		ldr	r3, .L433+16
 5256 0078 9A42     		cmp	r2, r3
 5257 007a 03DD     		ble	.L400
 5258              	.L401:
 5259              		.loc 1 1235 0 is_stmt 0 discriminator 1
 5260 007c 7A68     		ldr	r2, [r7, #4]
 5261 007e AA4B     		ldr	r3, .L433+20
 5262 0080 9A42     		cmp	r2, r3
 5263 0082 01DD     		ble	.L399
 5264              	.L400:
1236:../Sources/mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 5265              		.loc 1 1236 0 is_stmt 1
 5266 0084 2223     		mov	r3, #34
 5267 0086 75E1     		b	.L397
 5268              	.L399:
1237:../Sources/mcg.c ****   }
1238:../Sources/mcg.c **** 
1239:../Sources/mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1240:../Sources/mcg.c ****   if (hgo_val > 0)
 5269              		.loc 1 1240 0
 5270 0088 FB1C     		add	r3, r7, #3
 5271 008a 1B78     		ldrb	r3, [r3]
 5272 008c 002B     		cmp	r3, #0
 5273 008e 02D0     		beq	.L402
1241:../Sources/mcg.c ****   {
1242:../Sources/mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 5274              		.loc 1 1242 0
 5275 0090 FB1C     		add	r3, r7, #3
 5276 0092 0122     		mov	r2, #1
 5277 0094 1A70     		strb	r2, [r3]
 5278              	.L402:
1243:../Sources/mcg.c ****   }
1244:../Sources/mcg.c **** 
1245:../Sources/mcg.c **** // configure the MCG_C2 register
1246:../Sources/mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1247:../Sources/mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
1248:../Sources/mcg.c ****   temp_reg = MCG_C2;
 5279              		.loc 1 1248 0
 5280 0096 9F4A     		ldr	r2, .L433
 5281 0098 3B1C     		mov	r3, r7
 5282 009a 1733     		add	r3, r3, #23
 5283 009c 5278     		ldrb	r2, [r2, #1]
 5284 009e 1A70     		strb	r2, [r3]
1249:../Sources/mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 5285              		.loc 1 1249 0
 5286 00a0 3B1C     		mov	r3, r7
 5287 00a2 1733     		add	r3, r3, #23
 5288 00a4 3A1C     		mov	r2, r7
 5289 00a6 1732     		add	r2, r2, #23
 5290 00a8 1278     		ldrb	r2, [r2]
 5291 00aa 3C21     		mov	r1, #60
 5292 00ac 8A43     		bic	r2, r1
 5293 00ae 1A70     		strb	r2, [r3]
1250:../Sources/mcg.c ****   if (crystal_val <= 40000)
 5294              		.loc 1 1250 0
 5295 00b0 7A68     		ldr	r2, [r7, #4]
 5296 00b2 9B4B     		ldr	r3, .L433+12
 5297 00b4 9A42     		cmp	r2, r3
 5298 00b6 11DC     		bgt	.L403
1251:../Sources/mcg.c ****   {
1252:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 5299              		.loc 1 1252 0
 5300 00b8 FB1C     		add	r3, r7, #3
 5301 00ba 1B78     		ldrb	r3, [r3]
 5302 00bc DB00     		lsl	r3, r3, #3
 5303 00be DAB2     		uxtb	r2, r3
 5304 00c0 BB1C     		add	r3, r7, #2
 5305 00c2 1B78     		ldrb	r3, [r3]
 5306 00c4 9B00     		lsl	r3, r3, #2
 5307 00c6 DBB2     		uxtb	r3, r3
 5308 00c8 1343     		orr	r3, r2
 5309 00ca D9B2     		uxtb	r1, r3
 5310 00cc 3B1C     		mov	r3, r7
 5311 00ce 1733     		add	r3, r3, #23
 5312 00d0 3A1C     		mov	r2, r7
 5313 00d2 1732     		add	r2, r2, #23
 5314 00d4 1278     		ldrb	r2, [r2]
 5315 00d6 0A43     		orr	r2, r1
 5316 00d8 1A70     		strb	r2, [r3]
 5317 00da 2CE0     		b	.L404
 5318              	.L403:
1253:../Sources/mcg.c ****   }
1254:../Sources/mcg.c ****   else if (crystal_val <= 8000000)
 5319              		.loc 1 1254 0
 5320 00dc 7A68     		ldr	r2, [r7, #4]
 5321 00de 934B     		ldr	r3, .L433+24
 5322 00e0 9A42     		cmp	r2, r3
 5323 00e2 14DC     		bgt	.L405
1255:../Sources/mcg.c ****   {
1256:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 5324              		.loc 1 1256 0
 5325 00e4 FB1C     		add	r3, r7, #3
 5326 00e6 1B78     		ldrb	r3, [r3]
 5327 00e8 DB00     		lsl	r3, r3, #3
 5328 00ea DAB2     		uxtb	r2, r3
 5329 00ec BB1C     		add	r3, r7, #2
 5330 00ee 1B78     		ldrb	r3, [r3]
 5331 00f0 9B00     		lsl	r3, r3, #2
 5332 00f2 DBB2     		uxtb	r3, r3
 5333 00f4 1343     		orr	r3, r2
 5334 00f6 DAB2     		uxtb	r2, r3
 5335 00f8 3B1C     		mov	r3, r7
 5336 00fa 1733     		add	r3, r3, #23
 5337 00fc 1B78     		ldrb	r3, [r3]
 5338 00fe 1343     		orr	r3, r2
 5339 0100 DAB2     		uxtb	r2, r3
 5340 0102 3B1C     		mov	r3, r7
 5341 0104 1733     		add	r3, r3, #23
 5342 0106 1021     		mov	r1, #16
 5343 0108 0A43     		orr	r2, r1
 5344 010a 1A70     		strb	r2, [r3]
 5345 010c 13E0     		b	.L404
 5346              	.L405:
1257:../Sources/mcg.c ****   }
1258:../Sources/mcg.c ****   else
1259:../Sources/mcg.c ****   {
1260:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 5347              		.loc 1 1260 0
 5348 010e FB1C     		add	r3, r7, #3
 5349 0110 1B78     		ldrb	r3, [r3]
 5350 0112 DB00     		lsl	r3, r3, #3
 5351 0114 DAB2     		uxtb	r2, r3
 5352 0116 BB1C     		add	r3, r7, #2
 5353 0118 1B78     		ldrb	r3, [r3]
 5354 011a 9B00     		lsl	r3, r3, #2
 5355 011c DBB2     		uxtb	r3, r3
 5356 011e 1343     		orr	r3, r2
 5357 0120 DAB2     		uxtb	r2, r3
 5358 0122 3B1C     		mov	r3, r7
 5359 0124 1733     		add	r3, r3, #23
 5360 0126 1B78     		ldrb	r3, [r3]
 5361 0128 1343     		orr	r3, r2
 5362 012a DAB2     		uxtb	r2, r3
 5363 012c 3B1C     		mov	r3, r7
 5364 012e 1733     		add	r3, r3, #23
 5365 0130 2021     		mov	r1, #32
 5366 0132 0A43     		orr	r2, r1
 5367 0134 1A70     		strb	r2, [r3]
 5368              	.L404:
1261:../Sources/mcg.c ****   }
1262:../Sources/mcg.c ****   MCG_C2 = temp_reg;
 5369              		.loc 1 1262 0
 5370 0136 774B     		ldr	r3, .L433
 5371 0138 3A1C     		mov	r2, r7
 5372 013a 1732     		add	r2, r2, #23
 5373 013c 1278     		ldrb	r2, [r2]
 5374 013e 5A70     		strb	r2, [r3, #1]
1263:../Sources/mcg.c **** 
1264:../Sources/mcg.c **** // determine FRDIV based on reference clock frequency
1265:../Sources/mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1266:../Sources/mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 5375              		.loc 1 1266 0
 5376 0140 7A68     		ldr	r2, [r7, #4]
 5377 0142 7B4B     		ldr	r3, .L433+28
 5378 0144 9A42     		cmp	r2, r3
 5379 0146 04DC     		bgt	.L406
 5380              		.loc 1 1266 0 is_stmt 0 discriminator 1
 5381 0148 3B1C     		mov	r3, r7
 5382 014a 1633     		add	r3, r3, #22
 5383 014c 0022     		mov	r2, #0
 5384 014e 1A70     		strb	r2, [r3]
 5385 0150 27E0     		b	.L407
 5386              	.L406:
1267:../Sources/mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 5387              		.loc 1 1267 0 is_stmt 1
 5388 0152 7A68     		ldr	r2, [r7, #4]
 5389 0154 774B     		ldr	r3, .L433+32
 5390 0156 9A42     		cmp	r2, r3
 5391 0158 04DC     		bgt	.L408
 5392              		.loc 1 1267 0 is_stmt 0 discriminator 1
 5393 015a 3B1C     		mov	r3, r7
 5394 015c 1633     		add	r3, r3, #22
 5395 015e 0122     		mov	r2, #1
 5396 0160 1A70     		strb	r2, [r3]
 5397 0162 1EE0     		b	.L407
 5398              	.L408:
1268:../Sources/mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 5399              		.loc 1 1268 0 is_stmt 1
 5400 0164 7A68     		ldr	r2, [r7, #4]
 5401 0166 744B     		ldr	r3, .L433+36
 5402 0168 9A42     		cmp	r2, r3
 5403 016a 04DC     		bgt	.L409
 5404              		.loc 1 1268 0 is_stmt 0 discriminator 1
 5405 016c 3B1C     		mov	r3, r7
 5406 016e 1633     		add	r3, r3, #22
 5407 0170 0222     		mov	r2, #2
 5408 0172 1A70     		strb	r2, [r3]
 5409 0174 15E0     		b	.L407
 5410              	.L409:
1269:../Sources/mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 5411              		.loc 1 1269 0 is_stmt 1
 5412 0176 7A68     		ldr	r2, [r7, #4]
 5413 0178 704B     		ldr	r3, .L433+40
 5414 017a 9A42     		cmp	r2, r3
 5415 017c 04DC     		bgt	.L410
 5416              		.loc 1 1269 0 is_stmt 0 discriminator 1
 5417 017e 3B1C     		mov	r3, r7
 5418 0180 1633     		add	r3, r3, #22
 5419 0182 0322     		mov	r2, #3
 5420 0184 1A70     		strb	r2, [r3]
 5421 0186 0CE0     		b	.L407
 5422              	.L410:
1270:../Sources/mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 5423              		.loc 1 1270 0 is_stmt 1
 5424 0188 7A68     		ldr	r2, [r7, #4]
 5425 018a 6D4B     		ldr	r3, .L433+44
 5426 018c 9A42     		cmp	r2, r3
 5427 018e 04DC     		bgt	.L411
 5428              		.loc 1 1270 0 is_stmt 0 discriminator 1
 5429 0190 3B1C     		mov	r3, r7
 5430 0192 1633     		add	r3, r3, #22
 5431 0194 0422     		mov	r2, #4
 5432 0196 1A70     		strb	r2, [r3]
 5433 0198 03E0     		b	.L407
 5434              	.L411:
1271:../Sources/mcg.c ****   else {frdiv_val = 5;}
 5435              		.loc 1 1271 0 is_stmt 1
 5436 019a 3B1C     		mov	r3, r7
 5437 019c 1633     		add	r3, r3, #22
 5438 019e 0522     		mov	r2, #5
 5439 01a0 1A70     		strb	r2, [r3]
 5440              	.L407:
1272:../Sources/mcg.c **** // The FLL ref clk divide value depends on FRDIV and the RANGE value
1273:../Sources/mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 5441              		.loc 1 1273 0
 5442 01a2 5C4B     		ldr	r3, .L433
 5443 01a4 5B78     		ldrb	r3, [r3, #1]
 5444 01a6 DBB2     		uxtb	r3, r3
 5445 01a8 1A1C     		mov	r2, r3
 5446 01aa 3023     		mov	r3, #48
 5447 01ac 1340     		and	r3, r2
 5448 01ae 1B09     		lsr	r3, r3, #4
 5449 01b0 0DD0     		beq	.L412
1274:../Sources/mcg.c ****   {
1275:../Sources/mcg.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 5450              		.loc 1 1275 0
 5451 01b2 3B1C     		mov	r3, r7
 5452 01b4 1633     		add	r3, r3, #22
 5453 01b6 1B78     		ldrb	r3, [r3]
 5454 01b8 2022     		mov	r2, #32
 5455 01ba 111C     		mov	r1, r2
 5456 01bc 9940     		lsl	r1, r1, r3
 5457 01be 0B1C     		mov	r3, r1
 5458 01c0 7868     		ldr	r0, [r7, #4]
 5459 01c2 191C     		mov	r1, r3
 5460 01c4 FFF7FEFF 		bl	__aeabi_idiv
 5461 01c8 031C     		mov	r3, r0
 5462 01ca 3B61     		str	r3, [r7, #16]
 5463 01cc 0CE0     		b	.L413
 5464              	.L412:
1276:../Sources/mcg.c ****   }
1277:../Sources/mcg.c ****   else
1278:../Sources/mcg.c ****   {
1279:../Sources/mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 5465              		.loc 1 1279 0
 5466 01ce 3B1C     		mov	r3, r7
 5467 01d0 1633     		add	r3, r3, #22
 5468 01d2 1B78     		ldrb	r3, [r3]
 5469 01d4 0122     		mov	r2, #1
 5470 01d6 111C     		mov	r1, r2
 5471 01d8 9940     		lsl	r1, r1, r3
 5472 01da 0B1C     		mov	r3, r1
 5473 01dc 7868     		ldr	r0, [r7, #4]
 5474 01de 191C     		mov	r1, r3
 5475 01e0 FFF7FEFF 		bl	__aeabi_idiv
 5476 01e4 031C     		mov	r3, r0
 5477 01e6 3B61     		str	r3, [r7, #16]
 5478              	.L413:
1280:../Sources/mcg.c ****   }
1281:../Sources/mcg.c ****   
1282:../Sources/mcg.c **** // Check resulting FLL frequency 
1283:../Sources/mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 5479              		.loc 1 1283 0
 5480 01e8 3B69     		ldr	r3, [r7, #16]
 5481 01ea 181C     		mov	r0, r3
 5482 01ec FFF7FEFF 		bl	fll_freq
 5483 01f0 031C     		mov	r3, r0
 5484 01f2 FB60     		str	r3, [r7, #12]
1284:../Sources/mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 5485              		.loc 1 1284 0
 5486 01f4 FB68     		ldr	r3, [r7, #12]
 5487 01f6 3B2B     		cmp	r3, #59
 5488 01f8 01DC     		bgt	.L414
 5489              		.loc 1 1284 0 is_stmt 0 discriminator 1
 5490 01fa FB68     		ldr	r3, [r7, #12]
 5491 01fc BAE0     		b	.L397
 5492              	.L414:
1285:../Sources/mcg.c ****   
1286:../Sources/mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1287:../Sources/mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1288:../Sources/mcg.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
1289:../Sources/mcg.c ****   temp_reg = MCG_C1;
 5493              		.loc 1 1289 0 is_stmt 1
 5494 01fe 454A     		ldr	r2, .L433
 5495 0200 3B1C     		mov	r3, r7
 5496 0202 1733     		add	r3, r3, #23
 5497 0204 1278     		ldrb	r2, [r2]
 5498 0206 1A70     		strb	r2, [r3]
1290:../Sources/mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
 5499              		.loc 1 1290 0
 5500 0208 3B1C     		mov	r3, r7
 5501 020a 1733     		add	r3, r3, #23
 5502 020c 3A1C     		mov	r2, r7
 5503 020e 1732     		add	r2, r2, #23
 5504 0210 1178     		ldrb	r1, [r2]
 5505 0212 0322     		mov	r2, #3
 5506 0214 0A40     		and	r2, r1
 5507 0216 1A70     		strb	r2, [r3]
1291:../Sources/mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 5508              		.loc 1 1291 0
 5509 0218 3B1C     		mov	r3, r7
 5510 021a 1633     		add	r3, r3, #22
 5511 021c 1B78     		ldrb	r3, [r3]
 5512 021e DB00     		lsl	r3, r3, #3
 5513 0220 DAB2     		uxtb	r2, r3
 5514 0222 3823     		mov	r3, #56
 5515 0224 1340     		and	r3, r2
 5516 0226 D9B2     		uxtb	r1, r3
 5517 0228 3B1C     		mov	r3, r7
 5518 022a 1733     		add	r3, r3, #23
 5519 022c 3A1C     		mov	r2, r7
 5520 022e 1732     		add	r2, r2, #23
 5521 0230 1278     		ldrb	r2, [r2]
 5522 0232 0A43     		orr	r2, r1
 5523 0234 1A70     		strb	r2, [r3]
1292:../Sources/mcg.c ****   MCG_C1 = temp_reg;
 5524              		.loc 1 1292 0
 5525 0236 374B     		ldr	r3, .L433
 5526 0238 3A1C     		mov	r2, r7
 5527 023a 1732     		add	r2, r2, #23
 5528 023c 1278     		ldrb	r2, [r2]
 5529 023e 1A70     		strb	r2, [r3]
1293:../Sources/mcg.c **** 
1294:../Sources/mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
1295:../Sources/mcg.c ****   if (erefs_val)
 5530              		.loc 1 1295 0
 5531 0240 BB1C     		add	r3, r7, #2
 5532 0242 1B78     		ldrb	r3, [r3]
 5533 0244 002B     		cmp	r3, #0
 5534 0246 24D0     		beq	.L415
1296:../Sources/mcg.c ****   {
1297:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 5535              		.loc 1 1297 0
 5536 0248 3B1C     		mov	r3, r7
 5537 024a 1433     		add	r3, r3, #20
 5538 024c 0022     		mov	r2, #0
 5539 024e 1A80     		strh	r2, [r3]
 5540 0250 0DE0     		b	.L416
 5541              	.L419:
1298:../Sources/mcg.c ****     {
1299:../Sources/mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 5542              		.loc 1 1299 0
 5543 0252 304B     		ldr	r3, .L433
 5544 0254 9B79     		ldrb	r3, [r3, #6]
 5545 0256 DBB2     		uxtb	r3, r3
 5546 0258 1A1C     		mov	r2, r3
 5547 025a 0223     		mov	r3, #2
 5548 025c 1340     		and	r3, r2
 5549 025e 0ED1     		bne	.L430
 5550              	.L417:
1297:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 5551              		.loc 1 1297 0
 5552 0260 3B1C     		mov	r3, r7
 5553 0262 1433     		add	r3, r3, #20
 5554 0264 3A1C     		mov	r2, r7
 5555 0266 1432     		add	r2, r2, #20
 5556 0268 1288     		ldrh	r2, [r2]
 5557 026a 0132     		add	r2, r2, #1
 5558 026c 1A80     		strh	r2, [r3]
 5559              	.L416:
1297:../Sources/mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 5560              		.loc 1 1297 0 is_stmt 0 discriminator 1
 5561 026e 3B1C     		mov	r3, r7
 5562 0270 1433     		add	r3, r3, #20
 5563 0272 0021     		mov	r1, #0
 5564 0274 5A5E     		ldrsh	r2, [r3, r1]
 5565 0276 334B     		ldr	r3, .L433+48
 5566 0278 9A42     		cmp	r2, r3
 5567 027a EADD     		ble	.L419
 5568 027c 00E0     		b	.L418
 5569              	.L430:
 5570              		.loc 1 1299 0 is_stmt 1
 5571 027e C046     		mov	r8, r8
 5572              	.L418:
1300:../Sources/mcg.c ****     }
1301:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 5573              		.loc 1 1301 0
 5574 0280 244B     		ldr	r3, .L433
 5575 0282 9B79     		ldrb	r3, [r3, #6]
 5576 0284 DBB2     		uxtb	r3, r3
 5577 0286 1A1C     		mov	r2, r3
 5578 0288 0223     		mov	r3, #2
 5579 028a 1340     		and	r3, r2
 5580 028c 01D1     		bne	.L415
 5581              		.loc 1 1301 0 is_stmt 0 discriminator 1
 5582 028e 2323     		mov	r3, #35
 5583 0290 70E0     		b	.L397
 5584              	.L415:
1302:../Sources/mcg.c ****   }
1303:../Sources/mcg.c **** 
1304:../Sources/mcg.c **** // wait for Reference clock Status bit to clear
1305:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5585              		.loc 1 1305 0 is_stmt 1
 5586 0292 3B1C     		mov	r3, r7
 5587 0294 1433     		add	r3, r3, #20
 5588 0296 0022     		mov	r2, #0
 5589 0298 1A80     		strh	r2, [r3]
 5590 029a 0DE0     		b	.L420
 5591              	.L423:
1306:../Sources/mcg.c ****   {
1307:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 5592              		.loc 1 1307 0
 5593 029c 1D4B     		ldr	r3, .L433
 5594 029e 9B79     		ldrb	r3, [r3, #6]
 5595 02a0 DBB2     		uxtb	r3, r3
 5596 02a2 1A1C     		mov	r2, r3
 5597 02a4 1023     		mov	r3, #16
 5598 02a6 1340     		and	r3, r2
 5599 02a8 0ED0     		beq	.L431
 5600              	.L421:
1305:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5601              		.loc 1 1305 0
 5602 02aa 3B1C     		mov	r3, r7
 5603 02ac 1433     		add	r3, r3, #20
 5604 02ae 3A1C     		mov	r2, r7
 5605 02b0 1432     		add	r2, r2, #20
 5606 02b2 1288     		ldrh	r2, [r2]
 5607 02b4 0132     		add	r2, r2, #1
 5608 02b6 1A80     		strh	r2, [r3]
 5609              	.L420:
1305:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5610              		.loc 1 1305 0 is_stmt 0 discriminator 1
 5611 02b8 3B1C     		mov	r3, r7
 5612 02ba 1433     		add	r3, r3, #20
 5613 02bc 0021     		mov	r1, #0
 5614 02be 5A5E     		ldrsh	r2, [r3, r1]
 5615 02c0 214B     		ldr	r3, .L433+52
 5616 02c2 9A42     		cmp	r2, r3
 5617 02c4 EADD     		ble	.L423
 5618 02c6 00E0     		b	.L422
 5619              	.L431:
 5620              		.loc 1 1307 0 is_stmt 1
 5621 02c8 C046     		mov	r8, r8
 5622              	.L422:
1308:../Sources/mcg.c ****   }
1309:../Sources/mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 5623              		.loc 1 1309 0
 5624 02ca 124B     		ldr	r3, .L433
 5625 02cc 9B79     		ldrb	r3, [r3, #6]
 5626 02ce DBB2     		uxtb	r3, r3
 5627 02d0 1A1C     		mov	r2, r3
 5628 02d2 1023     		mov	r3, #16
 5629 02d4 1340     		and	r3, r2
 5630 02d6 01D0     		beq	.L424
 5631              		.loc 1 1309 0 is_stmt 0 discriminator 1
 5632 02d8 1123     		mov	r3, #17
 5633 02da 4BE0     		b	.L397
 5634              	.L424:
1310:../Sources/mcg.c ****   
1311:../Sources/mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
1312:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5635              		.loc 1 1312 0 is_stmt 1
 5636 02dc 3B1C     		mov	r3, r7
 5637 02de 1433     		add	r3, r3, #20
 5638 02e0 0022     		mov	r2, #0
 5639 02e2 1A80     		strh	r2, [r3]
 5640 02e4 0EE0     		b	.L425
 5641              	.L428:
1313:../Sources/mcg.c ****   {
1314:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 5642              		.loc 1 1314 0
 5643 02e6 0B4B     		ldr	r3, .L433
 5644 02e8 9B79     		ldrb	r3, [r3, #6]
 5645 02ea DBB2     		uxtb	r3, r3
 5646 02ec 1A1C     		mov	r2, r3
 5647 02ee 0C23     		mov	r3, #12
 5648 02f0 1340     		and	r3, r2
 5649 02f2 9B08     		lsr	r3, r3, #2
 5650 02f4 2AD0     		beq	.L432
 5651              	.L426:
1312:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5652              		.loc 1 1312 0
 5653 02f6 3B1C     		mov	r3, r7
 5654 02f8 1433     		add	r3, r3, #20
 5655 02fa 3A1C     		mov	r2, r7
 5656 02fc 1432     		add	r2, r2, #20
 5657 02fe 1288     		ldrh	r2, [r2]
 5658 0300 0132     		add	r2, r2, #1
 5659 0302 1A80     		strh	r2, [r3]
 5660              	.L425:
1312:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5661              		.loc 1 1312 0 is_stmt 0 discriminator 1
 5662 0304 3B1C     		mov	r3, r7
 5663 0306 1433     		add	r3, r3, #20
 5664 0308 0021     		mov	r1, #0
 5665 030a 5A5E     		ldrsh	r2, [r3, r1]
 5666 030c 0E4B     		ldr	r3, .L433+52
 5667 030e 9A42     		cmp	r2, r3
 5668 0310 E9DD     		ble	.L428
 5669 0312 1CE0     		b	.L427
 5670              	.L434:
 5671              		.align	2
 5672              	.L433:
 5673 0314 00400640 		.word	1074151424
 5674 0318 80F0FA02 		.word	50000000
 5675 031c 2F750000 		.word	29999
 5676 0320 409C0000 		.word	40000
 5677 0324 BFC62D00 		.word	2999999
 5678 0328 0048E801 		.word	32000000
 5679 032c 00127A00 		.word	8000000
 5680 0330 D0121300 		.word	1250000
 5681 0334 A0252600 		.word	2500000
 5682 0338 404B4C00 		.word	5000000
 5683 033c 80969800 		.word	10000000
 5684 0340 002D3101 		.word	20000000
 5685 0344 0F270000 		.word	9999
 5686 0348 CF070000 		.word	1999
 5687              	.L432:
 5688              		.loc 1 1314 0 is_stmt 1
 5689 034c C046     		mov	r8, r8
 5690              	.L427:
1315:../Sources/mcg.c ****   }
1316:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is reall
 5691              		.loc 1 1316 0
 5692 034e 0B4B     		ldr	r3, .L435
 5693 0350 9B79     		ldrb	r3, [r3, #6]
 5694 0352 DBB2     		uxtb	r3, r3
 5695 0354 1A1C     		mov	r2, r3
 5696 0356 0C23     		mov	r3, #12
 5697 0358 1340     		and	r3, r2
 5698 035a 9B08     		lsr	r3, r3, #2
 5699 035c 01D0     		beq	.L429
 5700              		.loc 1 1316 0 is_stmt 0 discriminator 1
 5701 035e 1823     		mov	r3, #24
 5702 0360 08E0     		b	.L397
 5703              	.L429:
1317:../Sources/mcg.c ****  
1318:../Sources/mcg.c **** // Now in FEE  
1319:../Sources/mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1320:../Sources/mcg.c **** // It is enabled here but can be removed if this is not required.
1321:../Sources/mcg.c **** // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and BLP
1322:../Sources/mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 5704              		.loc 1 1322 0 is_stmt 1
 5705 0362 064B     		ldr	r3, .L435
 5706 0364 054A     		ldr	r2, .L435
 5707 0366 5279     		ldrb	r2, [r2, #5]
 5708 0368 D2B2     		uxtb	r2, r2
 5709 036a 2021     		mov	r1, #32
 5710 036c 0A43     		orr	r2, r1
 5711 036e D2B2     		uxtb	r2, r2
 5712 0370 5A71     		strb	r2, [r3, #5]
1323:../Sources/mcg.c ****   
1324:../Sources/mcg.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 5713              		.loc 1 1324 0
 5714 0372 FB68     		ldr	r3, [r7, #12]
 5715              	.L397:
1325:../Sources/mcg.c **** } //fbi_fee
 5716              		.loc 1 1325 0
 5717 0374 181C     		mov	r0, r3
 5718 0376 BD46     		mov	sp, r7
 5719 0378 06B0     		add	sp, sp, #24
 5720              		@ sp needed for prologue
 5721 037a 80BD     		pop	{r7, pc}
 5722              	.L436:
 5723              		.align	2
 5724              	.L435:
 5725 037c 00400640 		.word	1074151424
 5726              		.cfi_endproc
 5727              	.LFE18:
 5729              		.section	.text.fee_fbi,"ax",%progbits
 5730              		.align	2
 5731              		.global	fee_fbi
 5732              		.code	16
 5733              		.thumb_func
 5735              	fee_fbi:
 5736              	.LFB19:
1326:../Sources/mcg.c **** 
1327:../Sources/mcg.c **** 
1328:../Sources/mcg.c **** int fee_fbi(int irc_freq, unsigned char irc_select)
1329:../Sources/mcg.c **** { 
 5737              		.loc 1 1329 0
 5738              		.cfi_startproc
 5739 0000 80B5     		push	{r7, lr}
 5740              	.LCFI57:
 5741              		.cfi_def_cfa_offset 8
 5742              		.cfi_offset 7, -8
 5743              		.cfi_offset 14, -4
 5744 0002 84B0     		sub	sp, sp, #16
 5745              	.LCFI58:
 5746              		.cfi_def_cfa_offset 24
 5747 0004 00AF     		add	r7, sp, #0
 5748              	.LCFI59:
 5749              		.cfi_def_cfa_register 7
 5750 0006 7860     		str	r0, [r7, #4]
 5751 0008 0A1C     		mov	r2, r1
 5752 000a FB1C     		add	r3, r7, #3
 5753 000c 1A70     		strb	r2, [r3]
1330:../Sources/mcg.c ****   unsigned char fcrdiv_val;
1331:../Sources/mcg.c ****   short i;
1332:../Sources/mcg.c ****   
1333:../Sources/mcg.c **** // Check MCG is in FEE mode
1334:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5754              		.loc 1 1334 0
 5755 000e 894B     		ldr	r3, .L472
 5756 0010 9B79     		ldrb	r3, [r3, #6]
 5757 0012 DBB2     		uxtb	r3, r3
 5758 0014 1A1C     		mov	r2, r3
 5759 0016 0C23     		mov	r3, #12
 5760 0018 1340     		and	r3, r2
 5761 001a 9B08     		lsr	r3, r3, #2
 5762 001c 0DD1     		bne	.L438
1335:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 5763              		.loc 1 1335 0 discriminator 1
 5764 001e 854B     		ldr	r3, .L472
 5765 0020 9B79     		ldrb	r3, [r3, #6]
 5766 0022 DBB2     		uxtb	r3, r3
 5767 0024 1A1C     		mov	r2, r3
 5768 0026 1023     		mov	r3, #16
 5769 0028 1340     		and	r3, r2
1334:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5770              		.loc 1 1334 0 discriminator 1
 5771 002a 06D1     		bne	.L438
1336:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 5772              		.loc 1 1336 0 discriminator 1
 5773 002c 814B     		ldr	r3, .L472
 5774 002e 9B79     		ldrb	r3, [r3, #6]
 5775 0030 DBB2     		uxtb	r3, r3
 5776 0032 1A1C     		mov	r2, r3
 5777 0034 2023     		mov	r3, #32
 5778 0036 1340     		and	r3, r2
1334:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 5779              		.loc 1 1334 0 discriminator 1
 5780 0038 01D0     		beq	.L439
 5781              	.L438:
1337:../Sources/mcg.c ****   {
1338:../Sources/mcg.c ****     return 0x2;                                                     // return error code
 5782              		.loc 1 1338 0
 5783 003a 0223     		mov	r3, #2
 5784 003c F6E0     		b	.L440
 5785              	.L439:
1339:../Sources/mcg.c ****   }
1340:../Sources/mcg.c ****   
1341:../Sources/mcg.c ****   // Check that the irc frequency matches the selected IRC 
1342:../Sources/mcg.c ****   if (!(irc_select))
 5786              		.loc 1 1342 0
 5787 003e FB1C     		add	r3, r7, #3
 5788 0040 1B78     		ldrb	r3, [r3]
 5789 0042 002B     		cmp	r3, #0
 5790 0044 09D1     		bne	.L441
1343:../Sources/mcg.c ****   {    
1344:../Sources/mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 5791              		.loc 1 1344 0
 5792 0046 7A68     		ldr	r2, [r7, #4]
 5793 0048 7B4B     		ldr	r3, .L472+4
 5794 004a 9A42     		cmp	r2, r3
 5795 004c 03DD     		ble	.L442
 5796              		.loc 1 1344 0 is_stmt 0 discriminator 2
 5797 004e 7A68     		ldr	r2, [r7, #4]
 5798 0050 7A4B     		ldr	r3, .L472+8
 5799 0052 9A42     		cmp	r2, r3
 5800 0054 0BDD     		ble	.L443
 5801              	.L442:
 5802              		.loc 1 1344 0 discriminator 1
 5803 0056 3123     		mov	r3, #49
 5804 0058 E8E0     		b	.L440
 5805              	.L441:
1345:../Sources/mcg.c ****   }
1346:../Sources/mcg.c ****   else
1347:../Sources/mcg.c ****   {
1348:../Sources/mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 5806              		.loc 1 1348 0 is_stmt 1
 5807 005a 7A68     		ldr	r2, [r7, #4]
 5808 005c 784B     		ldr	r3, .L472+12
 5809 005e 9A42     		cmp	r2, r3
 5810 0060 03DD     		ble	.L444
 5811              		.loc 1 1348 0 is_stmt 0 discriminator 2
 5812 0062 7A68     		ldr	r2, [r7, #4]
 5813 0064 774B     		ldr	r3, .L472+16
 5814 0066 9A42     		cmp	r2, r3
 5815 0068 01DD     		ble	.L443
 5816              	.L444:
 5817              		.loc 1 1348 0 discriminator 1
 5818 006a 3223     		mov	r3, #50
 5819 006c DEE0     		b	.L440
 5820              	.L443:
1349:../Sources/mcg.c ****   }
1350:../Sources/mcg.c ****   
1351:../Sources/mcg.c **** // Select the required IRC
1352:../Sources/mcg.c ****   if (irc_select)
 5821              		.loc 1 1352 0 is_stmt 1
 5822 006e FB1C     		add	r3, r7, #3
 5823 0070 1B78     		ldrb	r3, [r3]
 5824 0072 002B     		cmp	r3, #0
 5825 0074 08D0     		beq	.L445
1353:../Sources/mcg.c ****   {
1354:../Sources/mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 5826              		.loc 1 1354 0
 5827 0076 6F4B     		ldr	r3, .L472
 5828 0078 6E4A     		ldr	r2, .L472
 5829 007a 5278     		ldrb	r2, [r2, #1]
 5830 007c D2B2     		uxtb	r2, r2
 5831 007e 0121     		mov	r1, #1
 5832 0080 0A43     		orr	r2, r1
 5833 0082 D2B2     		uxtb	r2, r2
 5834 0084 5A70     		strb	r2, [r3, #1]
 5835 0086 07E0     		b	.L446
 5836              	.L445:
1355:../Sources/mcg.c ****   }
1356:../Sources/mcg.c ****   else
1357:../Sources/mcg.c ****   {
1358:../Sources/mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 5837              		.loc 1 1358 0
 5838 0088 6A4B     		ldr	r3, .L472
 5839 008a 6A4A     		ldr	r2, .L472
 5840 008c 5278     		ldrb	r2, [r2, #1]
 5841 008e D2B2     		uxtb	r2, r2
 5842 0090 0121     		mov	r1, #1
 5843 0092 8A43     		bic	r2, r1
 5844 0094 D2B2     		uxtb	r2, r2
 5845 0096 5A70     		strb	r2, [r3, #1]
 5846              	.L446:
1359:../Sources/mcg.c ****   }
1360:../Sources/mcg.c ****   
1361:../Sources/mcg.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
1362:../Sources/mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 5847              		.loc 1 1362 0
 5848 0098 664B     		ldr	r3, .L472
 5849 009a 664A     		ldr	r2, .L472
 5850 009c 5279     		ldrb	r2, [r2, #5]
 5851 009e D2B2     		uxtb	r2, r2
 5852 00a0 2021     		mov	r1, #32
 5853 00a2 8A43     		bic	r2, r1
 5854 00a4 D2B2     		uxtb	r2, r2
 5855 00a6 5A71     		strb	r2, [r3, #5]
1363:../Sources/mcg.c ****   
1364:../Sources/mcg.c **** // Select the IRC as the CLKS mux selection
1365:../Sources/mcg.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 5856              		.loc 1 1365 0
 5857 00a8 624B     		ldr	r3, .L472
 5858 00aa 624A     		ldr	r2, .L472
 5859 00ac 1278     		ldrb	r2, [r2]
 5860 00ae D2B2     		uxtb	r2, r2
 5861 00b0 4421     		mov	r1, #68
 5862 00b2 0A43     		orr	r2, r1
 5863 00b4 D2B2     		uxtb	r2, r2
 5864 00b6 1A70     		strb	r2, [r3]
1366:../Sources/mcg.c ****  
1367:../Sources/mcg.c **** // wait until internal reference switches to requested irc.
1368:../Sources/mcg.c ****   if (!(irc_select))
 5865              		.loc 1 1368 0
 5866 00b8 FB1C     		add	r3, r7, #3
 5867 00ba 1B78     		ldrb	r3, [r3]
 5868 00bc 002B     		cmp	r3, #0
 5869 00be 26D1     		bne	.L447
1369:../Sources/mcg.c ****   {
1370:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 5870              		.loc 1 1370 0
 5871 00c0 3B1C     		mov	r3, r7
 5872 00c2 0E33     		add	r3, r3, #14
 5873 00c4 0022     		mov	r2, #0
 5874 00c6 1A80     		strh	r2, [r3]
 5875 00c8 0DE0     		b	.L448
 5876              	.L451:
1371:../Sources/mcg.c ****     {
1372:../Sources/mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 5877              		.loc 1 1372 0
 5878 00ca 5A4B     		ldr	r3, .L472
 5879 00cc 9B79     		ldrb	r3, [r3, #6]
 5880 00ce DBB2     		uxtb	r3, r3
 5881 00d0 1A1C     		mov	r2, r3
 5882 00d2 0123     		mov	r3, #1
 5883 00d4 1340     		and	r3, r2
 5884 00d6 0ED0     		beq	.L468
 5885              	.L449:
1370:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 5886              		.loc 1 1370 0
 5887 00d8 3B1C     		mov	r3, r7
 5888 00da 0E33     		add	r3, r3, #14
 5889 00dc 3A1C     		mov	r2, r7
 5890 00de 0E32     		add	r2, r2, #14
 5891 00e0 1288     		ldrh	r2, [r2]
 5892 00e2 0132     		add	r2, r2, #1
 5893 00e4 1A80     		strh	r2, [r3]
 5894              	.L448:
1370:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 5895              		.loc 1 1370 0 is_stmt 0 discriminator 1
 5896 00e6 3B1C     		mov	r3, r7
 5897 00e8 0E33     		add	r3, r3, #14
 5898 00ea 0021     		mov	r1, #0
 5899 00ec 5A5E     		ldrsh	r2, [r3, r1]
 5900 00ee 564B     		ldr	r3, .L472+20
 5901 00f0 9A42     		cmp	r2, r3
 5902 00f2 EADD     		ble	.L451
 5903 00f4 00E0     		b	.L450
 5904              	.L468:
 5905              		.loc 1 1372 0 is_stmt 1
 5906 00f6 C046     		mov	r8, r8
 5907              	.L450:
1373:../Sources/mcg.c ****     }
1374:../Sources/mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 5908              		.loc 1 1374 0
 5909 00f8 4E4B     		ldr	r3, .L472
 5910 00fa 9B79     		ldrb	r3, [r3, #6]
 5911 00fc DBB2     		uxtb	r3, r3
 5912 00fe 1A1C     		mov	r2, r3
 5913 0100 0123     		mov	r3, #1
 5914 0102 1340     		and	r3, r2
 5915 0104 DBB2     		uxtb	r3, r3
 5916 0106 002B     		cmp	r3, #0
 5917 0108 28D0     		beq	.L452
 5918              		.loc 1 1374 0 is_stmt 0 discriminator 1
 5919 010a 1323     		mov	r3, #19
 5920 010c 8EE0     		b	.L440
 5921              	.L447:
1375:../Sources/mcg.c ****   }
1376:../Sources/mcg.c ****   else
1377:../Sources/mcg.c ****   {
1378:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 5922              		.loc 1 1378 0 is_stmt 1
 5923 010e 3B1C     		mov	r3, r7
 5924 0110 0E33     		add	r3, r3, #14
 5925 0112 0022     		mov	r2, #0
 5926 0114 1A80     		strh	r2, [r3]
 5927 0116 0FE0     		b	.L453
 5928              	.L456:
1379:../Sources/mcg.c ****     {
1380:../Sources/mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 5929              		.loc 1 1380 0
 5930 0118 464B     		ldr	r3, .L472
 5931 011a 9B79     		ldrb	r3, [r3, #6]
 5932 011c DBB2     		uxtb	r3, r3
 5933 011e 1A1C     		mov	r2, r3
 5934 0120 0123     		mov	r3, #1
 5935 0122 1340     		and	r3, r2
 5936 0124 DBB2     		uxtb	r3, r3
 5937 0126 002B     		cmp	r3, #0
 5938 0128 0ED1     		bne	.L469
 5939              	.L454:
1378:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 5940              		.loc 1 1378 0
 5941 012a 3B1C     		mov	r3, r7
 5942 012c 0E33     		add	r3, r3, #14
 5943 012e 3A1C     		mov	r2, r7
 5944 0130 0E32     		add	r2, r2, #14
 5945 0132 1288     		ldrh	r2, [r2]
 5946 0134 0132     		add	r2, r2, #1
 5947 0136 1A80     		strh	r2, [r3]
 5948              	.L453:
1378:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 5949              		.loc 1 1378 0 is_stmt 0 discriminator 1
 5950 0138 3B1C     		mov	r3, r7
 5951 013a 0E33     		add	r3, r3, #14
 5952 013c 0021     		mov	r1, #0
 5953 013e 5A5E     		ldrsh	r2, [r3, r1]
 5954 0140 414B     		ldr	r3, .L472+20
 5955 0142 9A42     		cmp	r2, r3
 5956 0144 E8DD     		ble	.L456
 5957 0146 00E0     		b	.L455
 5958              	.L469:
 5959              		.loc 1 1380 0 is_stmt 1
 5960 0148 C046     		mov	r8, r8
 5961              	.L455:
1381:../Sources/mcg.c ****     }
1382:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 5962              		.loc 1 1382 0
 5963 014a 3A4B     		ldr	r3, .L472
 5964 014c 9B79     		ldrb	r3, [r3, #6]
 5965 014e DBB2     		uxtb	r3, r3
 5966 0150 1A1C     		mov	r2, r3
 5967 0152 0123     		mov	r3, #1
 5968 0154 1340     		and	r3, r2
 5969 0156 01D1     		bne	.L452
 5970              		.loc 1 1382 0 is_stmt 0 discriminator 1
 5971 0158 1423     		mov	r3, #20
 5972 015a 67E0     		b	.L440
 5973              	.L452:
1383:../Sources/mcg.c ****   }
1384:../Sources/mcg.c ****   
1385:../Sources/mcg.c **** // Wait for clock status bits to update
1386:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5974              		.loc 1 1386 0 is_stmt 1
 5975 015c 3B1C     		mov	r3, r7
 5976 015e 0E33     		add	r3, r3, #14
 5977 0160 0022     		mov	r2, #0
 5978 0162 1A80     		strh	r2, [r3]
 5979 0164 0FE0     		b	.L457
 5980              	.L460:
1387:../Sources/mcg.c ****   {
1388:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 5981              		.loc 1 1388 0
 5982 0166 334B     		ldr	r3, .L472
 5983 0168 9B79     		ldrb	r3, [r3, #6]
 5984 016a DBB2     		uxtb	r3, r3
 5985 016c 1A1C     		mov	r2, r3
 5986 016e 0C23     		mov	r3, #12
 5987 0170 1340     		and	r3, r2
 5988 0172 9B08     		lsr	r3, r3, #2
 5989 0174 012B     		cmp	r3, #1
 5990 0176 0ED0     		beq	.L470
 5991              	.L458:
1386:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5992              		.loc 1 1386 0
 5993 0178 3B1C     		mov	r3, r7
 5994 017a 0E33     		add	r3, r3, #14
 5995 017c 3A1C     		mov	r2, r7
 5996 017e 0E32     		add	r2, r2, #14
 5997 0180 1288     		ldrh	r2, [r2]
 5998 0182 0132     		add	r2, r2, #1
 5999 0184 1A80     		strh	r2, [r3]
 6000              	.L457:
1386:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6001              		.loc 1 1386 0 is_stmt 0 discriminator 1
 6002 0186 3B1C     		mov	r3, r7
 6003 0188 0E33     		add	r3, r3, #14
 6004 018a 0021     		mov	r1, #0
 6005 018c 5A5E     		ldrsh	r2, [r3, r1]
 6006 018e 2E4B     		ldr	r3, .L472+20
 6007 0190 9A42     		cmp	r2, r3
 6008 0192 E8DD     		ble	.L460
 6009 0194 00E0     		b	.L459
 6010              	.L470:
 6011              		.loc 1 1388 0 is_stmt 1
 6012 0196 C046     		mov	r8, r8
 6013              	.L459:
1389:../Sources/mcg.c ****   }
1390:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 6014              		.loc 1 1390 0
 6015 0198 264B     		ldr	r3, .L472
 6016 019a 9B79     		ldrb	r3, [r3, #6]
 6017 019c DBB2     		uxtb	r3, r3
 6018 019e 1A1C     		mov	r2, r3
 6019 01a0 0C23     		mov	r3, #12
 6020 01a2 1340     		and	r3, r2
 6021 01a4 9B08     		lsr	r3, r3, #2
 6022 01a6 012B     		cmp	r3, #1
 6023 01a8 01D0     		beq	.L461
 6024              		.loc 1 1390 0 is_stmt 0 discriminator 1
 6025 01aa 1923     		mov	r3, #25
 6026 01ac 3EE0     		b	.L440
 6027              	.L461:
1391:../Sources/mcg.c ****   
1392:../Sources/mcg.c **** // wait for Reference clock Status bit to set
1393:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6028              		.loc 1 1393 0 is_stmt 1
 6029 01ae 3B1C     		mov	r3, r7
 6030 01b0 0E33     		add	r3, r3, #14
 6031 01b2 0022     		mov	r2, #0
 6032 01b4 1A80     		strh	r2, [r3]
 6033 01b6 0DE0     		b	.L462
 6034              	.L465:
1394:../Sources/mcg.c ****   {
1395:../Sources/mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 6035              		.loc 1 1395 0
 6036 01b8 1E4B     		ldr	r3, .L472
 6037 01ba 9B79     		ldrb	r3, [r3, #6]
 6038 01bc DBB2     		uxtb	r3, r3
 6039 01be 1A1C     		mov	r2, r3
 6040 01c0 1023     		mov	r3, #16
 6041 01c2 1340     		and	r3, r2
 6042 01c4 0ED1     		bne	.L471
 6043              	.L463:
1393:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6044              		.loc 1 1393 0
 6045 01c6 3B1C     		mov	r3, r7
 6046 01c8 0E33     		add	r3, r3, #14
 6047 01ca 3A1C     		mov	r2, r7
 6048 01cc 0E32     		add	r2, r2, #14
 6049 01ce 1288     		ldrh	r2, [r2]
 6050 01d0 0132     		add	r2, r2, #1
 6051 01d2 1A80     		strh	r2, [r3]
 6052              	.L462:
1393:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6053              		.loc 1 1393 0 is_stmt 0 discriminator 1
 6054 01d4 3B1C     		mov	r3, r7
 6055 01d6 0E33     		add	r3, r3, #14
 6056 01d8 0021     		mov	r1, #0
 6057 01da 5A5E     		ldrsh	r2, [r3, r1]
 6058 01dc 1A4B     		ldr	r3, .L472+20
 6059 01de 9A42     		cmp	r2, r3
 6060 01e0 EADD     		ble	.L465
 6061 01e2 00E0     		b	.L464
 6062              	.L471:
 6063              		.loc 1 1395 0 is_stmt 1
 6064 01e4 C046     		mov	r8, r8
 6065              	.L464:
1396:../Sources/mcg.c ****   }
1397:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 6066              		.loc 1 1397 0
 6067 01e6 134B     		ldr	r3, .L472
 6068 01e8 9B79     		ldrb	r3, [r3, #6]
 6069 01ea DBB2     		uxtb	r3, r3
 6070 01ec 1A1C     		mov	r2, r3
 6071 01ee 1023     		mov	r3, #16
 6072 01f0 1340     		and	r3, r2
 6073 01f2 01D1     		bne	.L466
 6074              		.loc 1 1397 0 is_stmt 0 discriminator 1
 6075 01f4 1223     		mov	r3, #18
 6076 01f6 19E0     		b	.L440
 6077              	.L466:
1398:../Sources/mcg.c ****   
1399:../Sources/mcg.c **** // Now in FBI mode
1400:../Sources/mcg.c ****   if (irc_select)
 6078              		.loc 1 1400 0 is_stmt 1
 6079 01f8 FB1C     		add	r3, r7, #3
 6080 01fa 1B78     		ldrb	r3, [r3]
 6081 01fc 002B     		cmp	r3, #0
 6082 01fe 14D0     		beq	.L467
1401:../Sources/mcg.c ****   {
1402:../Sources/mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 6083              		.loc 1 1402 0
 6084 0200 0C4B     		ldr	r3, .L472
 6085 0202 1B7A     		ldrb	r3, [r3, #8]
 6086 0204 DBB2     		uxtb	r3, r3
 6087 0206 1A1C     		mov	r2, r3
 6088 0208 0E23     		mov	r3, #14
 6089 020a 1340     		and	r3, r2
 6090 020c 5B08     		lsr	r3, r3, #1
 6091 020e 0122     		mov	r2, #1
 6092 0210 9A40     		lsl	r2, r2, r3
 6093 0212 3B1C     		mov	r3, r7
 6094 0214 0D33     		add	r3, r3, #13
 6095 0216 1A70     		strb	r2, [r3]
1403:../Sources/mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 6096              		.loc 1 1403 0
 6097 0218 3B1C     		mov	r3, r7
 6098 021a 0D33     		add	r3, r3, #13
 6099 021c 1B78     		ldrb	r3, [r3]
 6100 021e 7868     		ldr	r0, [r7, #4]
 6101 0220 191C     		mov	r1, r3
 6102 0222 FFF7FEFF 		bl	__aeabi_idiv
 6103 0226 031C     		mov	r3, r0
 6104 0228 00E0     		b	.L440
 6105              	.L467:
1404:../Sources/mcg.c ****   }
1405:../Sources/mcg.c ****   else
1406:../Sources/mcg.c ****   {
1407:../Sources/mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 6106              		.loc 1 1407 0
 6107 022a 7B68     		ldr	r3, [r7, #4]
 6108              	.L440:
1408:../Sources/mcg.c ****   }
1409:../Sources/mcg.c **** } // fee_fbi 
 6109              		.loc 1 1409 0
 6110 022c 181C     		mov	r0, r3
 6111 022e BD46     		mov	sp, r7
 6112 0230 04B0     		add	sp, sp, #16
 6113              		@ sp needed for prologue
 6114 0232 80BD     		pop	{r7, pc}
 6115              	.L473:
 6116              		.align	2
 6117              	.L472:
 6118 0234 00400640 		.word	1074151424
 6119 0238 117A0000 		.word	31249
 6120 023c 97980000 		.word	39063
 6121 0240 BFC62D00 		.word	2999999
 6122 0244 404B4C00 		.word	5000000
 6123 0248 CF070000 		.word	1999
 6124              		.cfi_endproc
 6125              	.LFE19:
 6127              		.section	.text.fbi_fei,"ax",%progbits
 6128              		.align	2
 6129              		.global	fbi_fei
 6130              		.code	16
 6131              		.thumb_func
 6133              	fbi_fei:
 6134              	.LFB20:
1410:../Sources/mcg.c **** 
1411:../Sources/mcg.c **** 
1412:../Sources/mcg.c **** int fbi_fei(int slow_irc_freq)
1413:../Sources/mcg.c **** {
 6135              		.loc 1 1413 0
 6136              		.cfi_startproc
 6137 0000 80B5     		push	{r7, lr}
 6138              	.LCFI60:
 6139              		.cfi_def_cfa_offset 8
 6140              		.cfi_offset 7, -8
 6141              		.cfi_offset 14, -4
 6142 0002 86B0     		sub	sp, sp, #24
 6143              	.LCFI61:
 6144              		.cfi_def_cfa_offset 32
 6145 0004 00AF     		add	r7, sp, #0
 6146              	.LCFI62:
 6147              		.cfi_def_cfa_register 7
 6148 0006 7860     		str	r0, [r7, #4]
1414:../Sources/mcg.c ****   unsigned char temp_reg;
1415:../Sources/mcg.c ****   short i;
1416:../Sources/mcg.c ****   int mcg_out;
1417:../Sources/mcg.c **** 
1418:../Sources/mcg.c **** // check if in FBI mode
1419:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 6149              		.loc 1 1419 0
 6150 0008 524B     		ldr	r3, .L493
 6151 000a 9B79     		ldrb	r3, [r3, #6]
 6152 000c DBB2     		uxtb	r3, r3
 6153 000e 1A1C     		mov	r2, r3
 6154 0010 0C23     		mov	r3, #12
 6155 0012 1340     		and	r3, r2
 6156 0014 9B08     		lsr	r3, r3, #2
 6157 0016 012B     		cmp	r3, #1
 6158 0018 14D1     		bne	.L475
1420:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 6159              		.loc 1 1420 0 discriminator 1
 6160 001a 4E4B     		ldr	r3, .L493
 6161 001c 9B79     		ldrb	r3, [r3, #6]
 6162 001e DBB2     		uxtb	r3, r3
 6163 0020 1A1C     		mov	r2, r3
 6164 0022 1023     		mov	r3, #16
 6165 0024 1340     		and	r3, r2
1419:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 6166              		.loc 1 1419 0 discriminator 1
 6167 0026 0DD0     		beq	.L475
1421:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 6168              		.loc 1 1421 0
 6169 0028 4A4B     		ldr	r3, .L493
 6170 002a 9B79     		ldrb	r3, [r3, #6]
 6171 002c DBB2     		uxtb	r3, r3
 6172 002e 1A1C     		mov	r2, r3
 6173 0030 2023     		mov	r3, #32
 6174 0032 1340     		and	r3, r2
1420:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 6175              		.loc 1 1420 0
 6176 0034 06D1     		bne	.L475
1422:../Sources/mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 6177              		.loc 1 1422 0
 6178 0036 474B     		ldr	r3, .L493
 6179 0038 5B78     		ldrb	r3, [r3, #1]
 6180 003a DBB2     		uxtb	r3, r3
 6181 003c 1A1C     		mov	r2, r3
 6182 003e 0223     		mov	r3, #2
 6183 0040 1340     		and	r3, r2
1419:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 6184              		.loc 1 1419 0
 6185 0042 01D0     		beq	.L476
 6186              	.L475:
1423:../Sources/mcg.c ****   {  
1424:../Sources/mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 6187              		.loc 1 1424 0
 6188 0044 0323     		mov	r3, #3
 6189 0046 81E0     		b	.L477
 6190              	.L476:
1425:../Sources/mcg.c ****   }
1426:../Sources/mcg.c **** 
1427:../Sources/mcg.c **** // Check IRC frequency is within spec.
1428:../Sources/mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 6191              		.loc 1 1428 0
 6192 0048 7A68     		ldr	r2, [r7, #4]
 6193 004a 434B     		ldr	r3, .L493+4
 6194 004c 9A42     		cmp	r2, r3
 6195 004e 03DD     		ble	.L478
 6196              		.loc 1 1428 0 is_stmt 0 discriminator 1
 6197 0050 7A68     		ldr	r2, [r7, #4]
 6198 0052 424B     		ldr	r3, .L493+8
 6199 0054 9A42     		cmp	r2, r3
 6200 0056 01DD     		ble	.L479
 6201              	.L478:
1429:../Sources/mcg.c ****   {
1430:../Sources/mcg.c ****     return 0x31;
 6202              		.loc 1 1430 0 is_stmt 1
 6203 0058 3123     		mov	r3, #49
 6204 005a 77E0     		b	.L477
 6205              	.L479:
1431:../Sources/mcg.c ****   }
1432:../Sources/mcg.c **** 
1433:../Sources/mcg.c **** // Check resulting FLL frequency 
1434:../Sources/mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
 6206              		.loc 1 1434 0
 6207 005c 7B68     		ldr	r3, [r7, #4]
 6208 005e 181C     		mov	r0, r3
 6209 0060 FFF7FEFF 		bl	fll_freq
 6210 0064 031C     		mov	r3, r0
 6211 0066 3B61     		str	r3, [r7, #16]
1435:../Sources/mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 6212              		.loc 1 1435 0
 6213 0068 3B69     		ldr	r3, [r7, #16]
 6214 006a 3B2B     		cmp	r3, #59
 6215 006c 01DC     		bgt	.L480
 6216              		.loc 1 1435 0 is_stmt 0 discriminator 1
 6217 006e 3B69     		ldr	r3, [r7, #16]
 6218 0070 6CE0     		b	.L477
 6219              	.L480:
1436:../Sources/mcg.c ****   
1437:../Sources/mcg.c **** // Change the CLKS mux to select the FLL output as MCGOUT  
1438:../Sources/mcg.c ****   temp_reg = MCG_C1;
 6220              		.loc 1 1438 0 is_stmt 1
 6221 0072 384A     		ldr	r2, .L493
 6222 0074 3B1C     		mov	r3, r7
 6223 0076 0F33     		add	r3, r3, #15
 6224 0078 1278     		ldrb	r2, [r2]
 6225 007a 1A70     		strb	r2, [r3]
1439:../Sources/mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
 6226              		.loc 1 1439 0
 6227 007c 3B1C     		mov	r3, r7
 6228 007e 0F33     		add	r3, r3, #15
 6229 0080 3A1C     		mov	r2, r7
 6230 0082 0F32     		add	r2, r2, #15
 6231 0084 1178     		ldrb	r1, [r2]
 6232 0086 3F22     		mov	r2, #63
 6233 0088 0A40     		and	r2, r1
 6234 008a 1A70     		strb	r2, [r3]
1440:../Sources/mcg.c ****   temp_reg |= MCG_C1_CLKS(0); // select FLL as MCGOUT
 6235              		.loc 1 1440 0
 6236 008c 3B1C     		mov	r3, r7
 6237 008e 0F33     		add	r3, r3, #15
 6238 0090 3A1C     		mov	r2, r7
 6239 0092 0F32     		add	r2, r2, #15
 6240 0094 1278     		ldrb	r2, [r2]
 6241 0096 1A70     		strb	r2, [r3]
1441:../Sources/mcg.c ****   temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
 6242              		.loc 1 1441 0
 6243 0098 3B1C     		mov	r3, r7
 6244 009a 0F33     		add	r3, r3, #15
 6245 009c 3A1C     		mov	r2, r7
 6246 009e 0F32     		add	r2, r2, #15
 6247 00a0 1278     		ldrb	r2, [r2]
 6248 00a2 0421     		mov	r1, #4
 6249 00a4 0A43     		orr	r2, r1
 6250 00a6 1A70     		strb	r2, [r3]
1442:../Sources/mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 6251              		.loc 1 1442 0
 6252 00a8 2A4B     		ldr	r3, .L493
 6253 00aa 3A1C     		mov	r2, r7
 6254 00ac 0F32     		add	r2, r2, #15
 6255 00ae 1278     		ldrb	r2, [r2]
 6256 00b0 1A70     		strb	r2, [r3]
1443:../Sources/mcg.c ****   
1444:../Sources/mcg.c **** // wait for Reference clock Status bit to clear
1445:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6257              		.loc 1 1445 0
 6258 00b2 3B1C     		mov	r3, r7
 6259 00b4 1633     		add	r3, r3, #22
 6260 00b6 0022     		mov	r2, #0
 6261 00b8 1A80     		strh	r2, [r3]
 6262 00ba 0DE0     		b	.L481
 6263              	.L484:
1446:../Sources/mcg.c ****   {
1447:../Sources/mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 6264              		.loc 1 1447 0
 6265 00bc 254B     		ldr	r3, .L493
 6266 00be 9B79     		ldrb	r3, [r3, #6]
 6267 00c0 DBB2     		uxtb	r3, r3
 6268 00c2 1A1C     		mov	r2, r3
 6269 00c4 1023     		mov	r3, #16
 6270 00c6 1340     		and	r3, r2
 6271 00c8 0ED1     		bne	.L491
 6272              	.L482:
1445:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6273              		.loc 1 1445 0
 6274 00ca 3B1C     		mov	r3, r7
 6275 00cc 1633     		add	r3, r3, #22
 6276 00ce 3A1C     		mov	r2, r7
 6277 00d0 1632     		add	r2, r2, #22
 6278 00d2 1288     		ldrh	r2, [r2]
 6279 00d4 0132     		add	r2, r2, #1
 6280 00d6 1A80     		strh	r2, [r3]
 6281              	.L481:
1445:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6282              		.loc 1 1445 0 is_stmt 0 discriminator 1
 6283 00d8 3B1C     		mov	r3, r7
 6284 00da 1633     		add	r3, r3, #22
 6285 00dc 0021     		mov	r1, #0
 6286 00de 5A5E     		ldrsh	r2, [r3, r1]
 6287 00e0 1F4B     		ldr	r3, .L493+12
 6288 00e2 9A42     		cmp	r2, r3
 6289 00e4 EADD     		ble	.L484
 6290 00e6 00E0     		b	.L483
 6291              	.L491:
 6292              		.loc 1 1447 0 is_stmt 1
 6293 00e8 C046     		mov	r8, r8
 6294              	.L483:
1448:../Sources/mcg.c ****   }
1449:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 6295              		.loc 1 1449 0
 6296 00ea 1A4B     		ldr	r3, .L493
 6297 00ec 9B79     		ldrb	r3, [r3, #6]
 6298 00ee DBB2     		uxtb	r3, r3
 6299 00f0 1A1C     		mov	r2, r3
 6300 00f2 1023     		mov	r3, #16
 6301 00f4 1340     		and	r3, r2
 6302 00f6 01D1     		bne	.L485
 6303              		.loc 1 1449 0 is_stmt 0 discriminator 1
 6304 00f8 1223     		mov	r3, #18
 6305 00fa 27E0     		b	.L477
 6306              	.L485:
1450:../Sources/mcg.c ****   
1451:../Sources/mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
1452:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6307              		.loc 1 1452 0 is_stmt 1
 6308 00fc 3B1C     		mov	r3, r7
 6309 00fe 1633     		add	r3, r3, #22
 6310 0100 0022     		mov	r2, #0
 6311 0102 1A80     		strh	r2, [r3]
 6312 0104 0EE0     		b	.L486
 6313              	.L489:
1453:../Sources/mcg.c ****   {
1454:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 6314              		.loc 1 1454 0
 6315 0106 134B     		ldr	r3, .L493
 6316 0108 9B79     		ldrb	r3, [r3, #6]
 6317 010a DBB2     		uxtb	r3, r3
 6318 010c 1A1C     		mov	r2, r3
 6319 010e 0C23     		mov	r3, #12
 6320 0110 1340     		and	r3, r2
 6321 0112 9B08     		lsr	r3, r3, #2
 6322 0114 0ED0     		beq	.L492
 6323              	.L487:
1452:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6324              		.loc 1 1452 0
 6325 0116 3B1C     		mov	r3, r7
 6326 0118 1633     		add	r3, r3, #22
 6327 011a 3A1C     		mov	r2, r7
 6328 011c 1632     		add	r2, r2, #22
 6329 011e 1288     		ldrh	r2, [r2]
 6330 0120 0132     		add	r2, r2, #1
 6331 0122 1A80     		strh	r2, [r3]
 6332              	.L486:
1452:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6333              		.loc 1 1452 0 is_stmt 0 discriminator 1
 6334 0124 3B1C     		mov	r3, r7
 6335 0126 1633     		add	r3, r3, #22
 6336 0128 0021     		mov	r1, #0
 6337 012a 5A5E     		ldrsh	r2, [r3, r1]
 6338 012c 0C4B     		ldr	r3, .L493+12
 6339 012e 9A42     		cmp	r2, r3
 6340 0130 E9DD     		ble	.L489
 6341 0132 00E0     		b	.L488
 6342              	.L492:
 6343              		.loc 1 1454 0 is_stmt 1
 6344 0134 C046     		mov	r8, r8
 6345              	.L488:
1455:../Sources/mcg.c ****   }
1456:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 6346              		.loc 1 1456 0
 6347 0136 074B     		ldr	r3, .L493
 6348 0138 9B79     		ldrb	r3, [r3, #6]
 6349 013a DBB2     		uxtb	r3, r3
 6350 013c 1A1C     		mov	r2, r3
 6351 013e 0C23     		mov	r3, #12
 6352 0140 1340     		and	r3, r2
 6353 0142 9B08     		lsr	r3, r3, #2
 6354 0144 01D0     		beq	.L490
 6355              		.loc 1 1456 0 is_stmt 0 discriminator 1
 6356 0146 1823     		mov	r3, #24
 6357 0148 00E0     		b	.L477
 6358              	.L490:
1457:../Sources/mcg.c **** 
1458:../Sources/mcg.c **** // Now in FEI mode
1459:../Sources/mcg.c ****   return mcg_out;  
 6359              		.loc 1 1459 0 is_stmt 1
 6360 014a 3B69     		ldr	r3, [r7, #16]
 6361              	.L477:
1460:../Sources/mcg.c **** } // fbi_fei
 6362              		.loc 1 1460 0
 6363 014c 181C     		mov	r0, r3
 6364 014e BD46     		mov	sp, r7
 6365 0150 06B0     		add	sp, sp, #24
 6366              		@ sp needed for prologue
 6367 0152 80BD     		pop	{r7, pc}
 6368              	.L494:
 6369              		.align	2
 6370              	.L493:
 6371 0154 00400640 		.word	1074151424
 6372 0158 117A0000 		.word	31249
 6373 015c 97980000 		.word	39063
 6374 0160 CF070000 		.word	1999
 6375              		.cfi_endproc
 6376              	.LFE20:
 6378              		.section	.text.fei_fbi,"ax",%progbits
 6379              		.align	2
 6380              		.global	fei_fbi
 6381              		.code	16
 6382              		.thumb_func
 6384              	fei_fbi:
 6385              	.LFB21:
1461:../Sources/mcg.c **** 
1462:../Sources/mcg.c **** 
1463:../Sources/mcg.c **** int fei_fbi(int irc_freq, unsigned char irc_select)
1464:../Sources/mcg.c **** {
 6386              		.loc 1 1464 0
 6387              		.cfi_startproc
 6388 0000 80B5     		push	{r7, lr}
 6389              	.LCFI63:
 6390              		.cfi_def_cfa_offset 8
 6391              		.cfi_offset 7, -8
 6392              		.cfi_offset 14, -4
 6393 0002 84B0     		sub	sp, sp, #16
 6394              	.LCFI64:
 6395              		.cfi_def_cfa_offset 24
 6396 0004 00AF     		add	r7, sp, #0
 6397              	.LCFI65:
 6398              		.cfi_def_cfa_register 7
 6399 0006 7860     		str	r0, [r7, #4]
 6400 0008 0A1C     		mov	r2, r1
 6401 000a FB1C     		add	r3, r7, #3
 6402 000c 1A70     		strb	r2, [r3]
1465:../Sources/mcg.c ****   unsigned char temp_reg;
1466:../Sources/mcg.c ****   unsigned char fcrdiv_val;
1467:../Sources/mcg.c ****   short i;
1468:../Sources/mcg.c ****   
1469:../Sources/mcg.c **** // Check MCG is in FEI mode
1470:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6403              		.loc 1 1470 0
 6404 000e 7C4B     		ldr	r3, .L524
 6405 0010 9B79     		ldrb	r3, [r3, #6]
 6406 0012 DBB2     		uxtb	r3, r3
 6407 0014 1A1C     		mov	r2, r3
 6408 0016 0C23     		mov	r3, #12
 6409 0018 1340     		and	r3, r2
 6410 001a 9B08     		lsr	r3, r3, #2
 6411 001c 0DD1     		bne	.L496
1471:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 6412              		.loc 1 1471 0 discriminator 1
 6413 001e 784B     		ldr	r3, .L524
 6414 0020 9B79     		ldrb	r3, [r3, #6]
 6415 0022 DBB2     		uxtb	r3, r3
 6416 0024 1A1C     		mov	r2, r3
 6417 0026 1023     		mov	r3, #16
 6418 0028 1340     		and	r3, r2
1470:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6419              		.loc 1 1470 0 discriminator 1
 6420 002a 06D0     		beq	.L496
1472:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 6421              		.loc 1 1472 0 discriminator 1
 6422 002c 744B     		ldr	r3, .L524
 6423 002e 9B79     		ldrb	r3, [r3, #6]
 6424 0030 DBB2     		uxtb	r3, r3
 6425 0032 1A1C     		mov	r2, r3
 6426 0034 2023     		mov	r3, #32
 6427 0036 1340     		and	r3, r2
1470:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6428              		.loc 1 1470 0 discriminator 1
 6429 0038 01D0     		beq	.L497
 6430              	.L496:
1473:../Sources/mcg.c ****   {
1474:../Sources/mcg.c ****     return 0x1;                                                       // return error code
 6431              		.loc 1 1474 0
 6432 003a 0123     		mov	r3, #1
 6433 003c DBE0     		b	.L498
 6434              	.L497:
1475:../Sources/mcg.c ****   } 
1476:../Sources/mcg.c **** 
1477:../Sources/mcg.c **** // Check that the irc frequency matches the selected IRC 
1478:../Sources/mcg.c ****   if (!(irc_select))
 6435              		.loc 1 1478 0
 6436 003e FB1C     		add	r3, r7, #3
 6437 0040 1B78     		ldrb	r3, [r3]
 6438 0042 002B     		cmp	r3, #0
 6439 0044 09D1     		bne	.L499
1479:../Sources/mcg.c ****   {    
1480:../Sources/mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 6440              		.loc 1 1480 0
 6441 0046 7A68     		ldr	r2, [r7, #4]
 6442 0048 6E4B     		ldr	r3, .L524+4
 6443 004a 9A42     		cmp	r2, r3
 6444 004c 03DD     		ble	.L500
 6445              		.loc 1 1480 0 is_stmt 0 discriminator 2
 6446 004e 7A68     		ldr	r2, [r7, #4]
 6447 0050 6D4B     		ldr	r3, .L524+8
 6448 0052 9A42     		cmp	r2, r3
 6449 0054 0BDD     		ble	.L501
 6450              	.L500:
 6451              		.loc 1 1480 0 discriminator 1
 6452 0056 3123     		mov	r3, #49
 6453 0058 CDE0     		b	.L498
 6454              	.L499:
1481:../Sources/mcg.c ****   }
1482:../Sources/mcg.c ****   else
1483:../Sources/mcg.c ****   {
1484:../Sources/mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 6455              		.loc 1 1484 0 is_stmt 1
 6456 005a 7A68     		ldr	r2, [r7, #4]
 6457 005c 6B4B     		ldr	r3, .L524+12
 6458 005e 9A42     		cmp	r2, r3
 6459 0060 03DD     		ble	.L502
 6460              		.loc 1 1484 0 is_stmt 0 discriminator 2
 6461 0062 7A68     		ldr	r2, [r7, #4]
 6462 0064 6A4B     		ldr	r3, .L524+16
 6463 0066 9A42     		cmp	r2, r3
 6464 0068 01DD     		ble	.L501
 6465              	.L502:
 6466              		.loc 1 1484 0 discriminator 1
 6467 006a 3223     		mov	r3, #50
 6468 006c C3E0     		b	.L498
 6469              	.L501:
1485:../Sources/mcg.c ****   }
1486:../Sources/mcg.c ****   
1487:../Sources/mcg.c **** // Select the desired IRC
1488:../Sources/mcg.c ****   if (irc_select)
 6470              		.loc 1 1488 0 is_stmt 1
 6471 006e FB1C     		add	r3, r7, #3
 6472 0070 1B78     		ldrb	r3, [r3]
 6473 0072 002B     		cmp	r3, #0
 6474 0074 08D0     		beq	.L503
1489:../Sources/mcg.c ****   {
1490:../Sources/mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
 6475              		.loc 1 1490 0
 6476 0076 624B     		ldr	r3, .L524
 6477 0078 614A     		ldr	r2, .L524
 6478 007a 5278     		ldrb	r2, [r2, #1]
 6479 007c D2B2     		uxtb	r2, r2
 6480 007e 0121     		mov	r1, #1
 6481 0080 0A43     		orr	r2, r1
 6482 0082 D2B2     		uxtb	r2, r2
 6483 0084 5A70     		strb	r2, [r3, #1]
 6484 0086 07E0     		b	.L504
 6485              	.L503:
1491:../Sources/mcg.c ****   }
1492:../Sources/mcg.c ****   else
1493:../Sources/mcg.c ****   {
1494:../Sources/mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
 6486              		.loc 1 1494 0
 6487 0088 5D4B     		ldr	r3, .L524
 6488 008a 5D4A     		ldr	r2, .L524
 6489 008c 5278     		ldrb	r2, [r2, #1]
 6490 008e D2B2     		uxtb	r2, r2
 6491 0090 0121     		mov	r1, #1
 6492 0092 8A43     		bic	r2, r1
 6493 0094 D2B2     		uxtb	r2, r2
 6494 0096 5A70     		strb	r2, [r3, #1]
 6495              	.L504:
1495:../Sources/mcg.c ****   }
1496:../Sources/mcg.c ****   
1497:../Sources/mcg.c **** // Change the CLKS mux to select the IRC as the MCGOUT
1498:../Sources/mcg.c ****   temp_reg = MCG_C1;
 6496              		.loc 1 1498 0
 6497 0098 594A     		ldr	r2, .L524
 6498 009a 3B1C     		mov	r3, r7
 6499 009c 0D33     		add	r3, r3, #13
 6500 009e 1278     		ldrb	r2, [r2]
 6501 00a0 1A70     		strb	r2, [r3]
1499:../Sources/mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 6502              		.loc 1 1499 0
 6503 00a2 3B1C     		mov	r3, r7
 6504 00a4 0D33     		add	r3, r3, #13
 6505 00a6 3A1C     		mov	r2, r7
 6506 00a8 0D32     		add	r2, r2, #13
 6507 00aa 1178     		ldrb	r1, [r2]
 6508 00ac 3F22     		mov	r2, #63
 6509 00ae 0A40     		and	r2, r1
 6510 00b0 1A70     		strb	r2, [r3]
1500:../Sources/mcg.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 6511              		.loc 1 1500 0
 6512 00b2 3B1C     		mov	r3, r7
 6513 00b4 0D33     		add	r3, r3, #13
 6514 00b6 3A1C     		mov	r2, r7
 6515 00b8 0D32     		add	r2, r2, #13
 6516 00ba 1278     		ldrb	r2, [r2]
 6517 00bc 4021     		mov	r1, #64
 6518 00be 0A43     		orr	r2, r1
 6519 00c0 1A70     		strb	r2, [r3]
1501:../Sources/mcg.c ****   MCG_C1 = temp_reg;
 6520              		.loc 1 1501 0
 6521 00c2 4F4B     		ldr	r3, .L524
 6522 00c4 3A1C     		mov	r2, r7
 6523 00c6 0D32     		add	r2, r2, #13
 6524 00c8 1278     		ldrb	r2, [r2]
 6525 00ca 1A70     		strb	r2, [r3]
1502:../Sources/mcg.c **** 
1503:../Sources/mcg.c **** // wait until internal reference switches to requested irc.
1504:../Sources/mcg.c ****   if (!(irc_select))
 6526              		.loc 1 1504 0
 6527 00cc FB1C     		add	r3, r7, #3
 6528 00ce 1B78     		ldrb	r3, [r3]
 6529 00d0 002B     		cmp	r3, #0
 6530 00d2 26D1     		bne	.L505
1505:../Sources/mcg.c ****   {
1506:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 6531              		.loc 1 1506 0
 6532 00d4 3B1C     		mov	r3, r7
 6533 00d6 0E33     		add	r3, r3, #14
 6534 00d8 0022     		mov	r2, #0
 6535 00da 1A80     		strh	r2, [r3]
 6536 00dc 0DE0     		b	.L506
 6537              	.L509:
1507:../Sources/mcg.c ****     {
1508:../Sources/mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 6538              		.loc 1 1508 0
 6539 00de 484B     		ldr	r3, .L524
 6540 00e0 9B79     		ldrb	r3, [r3, #6]
 6541 00e2 DBB2     		uxtb	r3, r3
 6542 00e4 1A1C     		mov	r2, r3
 6543 00e6 0123     		mov	r3, #1
 6544 00e8 1340     		and	r3, r2
 6545 00ea 0ED0     		beq	.L521
 6546              	.L507:
1506:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 6547              		.loc 1 1506 0
 6548 00ec 3B1C     		mov	r3, r7
 6549 00ee 0E33     		add	r3, r3, #14
 6550 00f0 3A1C     		mov	r2, r7
 6551 00f2 0E32     		add	r2, r2, #14
 6552 00f4 1288     		ldrh	r2, [r2]
 6553 00f6 0132     		add	r2, r2, #1
 6554 00f8 1A80     		strh	r2, [r3]
 6555              	.L506:
1506:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 6556              		.loc 1 1506 0 is_stmt 0 discriminator 1
 6557 00fa 3B1C     		mov	r3, r7
 6558 00fc 0E33     		add	r3, r3, #14
 6559 00fe 0021     		mov	r1, #0
 6560 0100 5A5E     		ldrsh	r2, [r3, r1]
 6561 0102 444B     		ldr	r3, .L524+20
 6562 0104 9A42     		cmp	r2, r3
 6563 0106 EADD     		ble	.L509
 6564 0108 00E0     		b	.L508
 6565              	.L521:
 6566              		.loc 1 1508 0 is_stmt 1
 6567 010a C046     		mov	r8, r8
 6568              	.L508:
1509:../Sources/mcg.c ****     }
1510:../Sources/mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 6569              		.loc 1 1510 0
 6570 010c 3C4B     		ldr	r3, .L524
 6571 010e 9B79     		ldrb	r3, [r3, #6]
 6572 0110 DBB2     		uxtb	r3, r3
 6573 0112 1A1C     		mov	r2, r3
 6574 0114 0123     		mov	r3, #1
 6575 0116 1340     		and	r3, r2
 6576 0118 DBB2     		uxtb	r3, r3
 6577 011a 002B     		cmp	r3, #0
 6578 011c 28D0     		beq	.L510
 6579              		.loc 1 1510 0 is_stmt 0 discriminator 1
 6580 011e 1323     		mov	r3, #19
 6581 0120 69E0     		b	.L498
 6582              	.L505:
1511:../Sources/mcg.c ****   }
1512:../Sources/mcg.c ****   else
1513:../Sources/mcg.c ****   {
1514:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 6583              		.loc 1 1514 0 is_stmt 1
 6584 0122 3B1C     		mov	r3, r7
 6585 0124 0E33     		add	r3, r3, #14
 6586 0126 0022     		mov	r2, #0
 6587 0128 1A80     		strh	r2, [r3]
 6588 012a 0FE0     		b	.L511
 6589              	.L514:
1515:../Sources/mcg.c ****     {
1516:../Sources/mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 6590              		.loc 1 1516 0
 6591 012c 344B     		ldr	r3, .L524
 6592 012e 9B79     		ldrb	r3, [r3, #6]
 6593 0130 DBB2     		uxtb	r3, r3
 6594 0132 1A1C     		mov	r2, r3
 6595 0134 0123     		mov	r3, #1
 6596 0136 1340     		and	r3, r2
 6597 0138 DBB2     		uxtb	r3, r3
 6598 013a 002B     		cmp	r3, #0
 6599 013c 0ED1     		bne	.L522
 6600              	.L512:
1514:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 6601              		.loc 1 1514 0
 6602 013e 3B1C     		mov	r3, r7
 6603 0140 0E33     		add	r3, r3, #14
 6604 0142 3A1C     		mov	r2, r7
 6605 0144 0E32     		add	r2, r2, #14
 6606 0146 1288     		ldrh	r2, [r2]
 6607 0148 0132     		add	r2, r2, #1
 6608 014a 1A80     		strh	r2, [r3]
 6609              	.L511:
1514:../Sources/mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 6610              		.loc 1 1514 0 is_stmt 0 discriminator 1
 6611 014c 3B1C     		mov	r3, r7
 6612 014e 0E33     		add	r3, r3, #14
 6613 0150 0021     		mov	r1, #0
 6614 0152 5A5E     		ldrsh	r2, [r3, r1]
 6615 0154 2F4B     		ldr	r3, .L524+20
 6616 0156 9A42     		cmp	r2, r3
 6617 0158 E8DD     		ble	.L514
 6618 015a 00E0     		b	.L513
 6619              	.L522:
 6620              		.loc 1 1516 0 is_stmt 1
 6621 015c C046     		mov	r8, r8
 6622              	.L513:
1517:../Sources/mcg.c ****     }
1518:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 6623              		.loc 1 1518 0
 6624 015e 284B     		ldr	r3, .L524
 6625 0160 9B79     		ldrb	r3, [r3, #6]
 6626 0162 DBB2     		uxtb	r3, r3
 6627 0164 1A1C     		mov	r2, r3
 6628 0166 0123     		mov	r3, #1
 6629 0168 1340     		and	r3, r2
 6630 016a 01D1     		bne	.L510
 6631              		.loc 1 1518 0 is_stmt 0 discriminator 1
 6632 016c 1423     		mov	r3, #20
 6633 016e 42E0     		b	.L498
 6634              	.L510:
1519:../Sources/mcg.c ****   }
1520:../Sources/mcg.c ****   
1521:../Sources/mcg.c **** // Wait for clock status bits to update
1522:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6635              		.loc 1 1522 0 is_stmt 1
 6636 0170 3B1C     		mov	r3, r7
 6637 0172 0E33     		add	r3, r3, #14
 6638 0174 0022     		mov	r2, #0
 6639 0176 1A80     		strh	r2, [r3]
 6640 0178 0FE0     		b	.L515
 6641              	.L518:
1523:../Sources/mcg.c ****   {
1524:../Sources/mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 6642              		.loc 1 1524 0
 6643 017a 214B     		ldr	r3, .L524
 6644 017c 9B79     		ldrb	r3, [r3, #6]
 6645 017e DBB2     		uxtb	r3, r3
 6646 0180 1A1C     		mov	r2, r3
 6647 0182 0C23     		mov	r3, #12
 6648 0184 1340     		and	r3, r2
 6649 0186 9B08     		lsr	r3, r3, #2
 6650 0188 012B     		cmp	r3, #1
 6651 018a 0ED0     		beq	.L523
 6652              	.L516:
1522:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6653              		.loc 1 1522 0
 6654 018c 3B1C     		mov	r3, r7
 6655 018e 0E33     		add	r3, r3, #14
 6656 0190 3A1C     		mov	r2, r7
 6657 0192 0E32     		add	r2, r2, #14
 6658 0194 1288     		ldrh	r2, [r2]
 6659 0196 0132     		add	r2, r2, #1
 6660 0198 1A80     		strh	r2, [r3]
 6661              	.L515:
1522:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 6662              		.loc 1 1522 0 is_stmt 0 discriminator 1
 6663 019a 3B1C     		mov	r3, r7
 6664 019c 0E33     		add	r3, r3, #14
 6665 019e 0021     		mov	r1, #0
 6666 01a0 5A5E     		ldrsh	r2, [r3, r1]
 6667 01a2 1C4B     		ldr	r3, .L524+20
 6668 01a4 9A42     		cmp	r2, r3
 6669 01a6 E8DD     		ble	.L518
 6670 01a8 00E0     		b	.L517
 6671              	.L523:
 6672              		.loc 1 1524 0 is_stmt 1
 6673 01aa C046     		mov	r8, r8
 6674              	.L517:
1525:../Sources/mcg.c ****   }
1526:../Sources/mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 6675              		.loc 1 1526 0
 6676 01ac 144B     		ldr	r3, .L524
 6677 01ae 9B79     		ldrb	r3, [r3, #6]
 6678 01b0 DBB2     		uxtb	r3, r3
 6679 01b2 1A1C     		mov	r2, r3
 6680 01b4 0C23     		mov	r3, #12
 6681 01b6 1340     		and	r3, r2
 6682 01b8 9B08     		lsr	r3, r3, #2
 6683 01ba 012B     		cmp	r3, #1
 6684 01bc 01D0     		beq	.L519
 6685              		.loc 1 1526 0 is_stmt 0 discriminator 1
 6686 01be 1923     		mov	r3, #25
 6687 01c0 19E0     		b	.L498
 6688              	.L519:
1527:../Sources/mcg.c ****   
1528:../Sources/mcg.c **** // Now in FBI mode
1529:../Sources/mcg.c ****   if (irc_select)
 6689              		.loc 1 1529 0 is_stmt 1
 6690 01c2 FB1C     		add	r3, r7, #3
 6691 01c4 1B78     		ldrb	r3, [r3]
 6692 01c6 002B     		cmp	r3, #0
 6693 01c8 14D0     		beq	.L520
1530:../Sources/mcg.c ****   {
1531:../Sources/mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 6694              		.loc 1 1531 0
 6695 01ca 0D4B     		ldr	r3, .L524
 6696 01cc 1B7A     		ldrb	r3, [r3, #8]
 6697 01ce DBB2     		uxtb	r3, r3
 6698 01d0 1A1C     		mov	r2, r3
 6699 01d2 0E23     		mov	r3, #14
 6700 01d4 1340     		and	r3, r2
 6701 01d6 5B08     		lsr	r3, r3, #1
 6702 01d8 0122     		mov	r2, #1
 6703 01da 9A40     		lsl	r2, r2, r3
 6704 01dc 3B1C     		mov	r3, r7
 6705 01de 0C33     		add	r3, r3, #12
 6706 01e0 1A70     		strb	r2, [r3]
1532:../Sources/mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 6707              		.loc 1 1532 0
 6708 01e2 3B1C     		mov	r3, r7
 6709 01e4 0C33     		add	r3, r3, #12
 6710 01e6 1B78     		ldrb	r3, [r3]
 6711 01e8 7868     		ldr	r0, [r7, #4]
 6712 01ea 191C     		mov	r1, r3
 6713 01ec FFF7FEFF 		bl	__aeabi_idiv
 6714 01f0 031C     		mov	r3, r0
 6715 01f2 00E0     		b	.L498
 6716              	.L520:
1533:../Sources/mcg.c ****   }
1534:../Sources/mcg.c ****   else
1535:../Sources/mcg.c ****   {
1536:../Sources/mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 6717              		.loc 1 1536 0
 6718 01f4 7B68     		ldr	r3, [r7, #4]
 6719              	.L498:
1537:../Sources/mcg.c ****   }   
1538:../Sources/mcg.c **** } // fei_fbi
 6720              		.loc 1 1538 0
 6721 01f6 181C     		mov	r0, r3
 6722 01f8 BD46     		mov	sp, r7
 6723 01fa 04B0     		add	sp, sp, #16
 6724              		@ sp needed for prologue
 6725 01fc 80BD     		pop	{r7, pc}
 6726              	.L525:
 6727 01fe C046     		.align	2
 6728              	.L524:
 6729 0200 00400640 		.word	1074151424
 6730 0204 117A0000 		.word	31249
 6731 0208 97980000 		.word	39063
 6732 020c BFC62D00 		.word	2999999
 6733 0210 404B4C00 		.word	5000000
 6734 0214 CF070000 		.word	1999
 6735              		.cfi_endproc
 6736              	.LFE21:
 6738              		.section	.text.fei_fee,"ax",%progbits
 6739              		.align	2
 6740              		.global	fei_fee
 6741              		.code	16
 6742              		.thumb_func
 6744              	fei_fee:
 6745              	.LFB22:
1539:../Sources/mcg.c **** 
1540:../Sources/mcg.c **** 
1541:../Sources/mcg.c **** /********************************************************************/
1542:../Sources/mcg.c **** /* Functon name : fei_fee
1543:../Sources/mcg.c ****  *
1544:../Sources/mcg.c ****  * Mode transition: FEI to FEE mode
1545:../Sources/mcg.c ****  *
1546:../Sources/mcg.c ****  * This function transitions the MCG from FEI mode to FEE mode. This is
1547:../Sources/mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1548:../Sources/mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1549:../Sources/mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
1550:../Sources/mcg.c ****  *
1551:../Sources/mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
1552:../Sources/mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
1553:../Sources/mcg.c ****  *                           for the crystal oscillator. This has no meaning if an 
1554:../Sources/mcg.c ****  *                           external clock is used.
1555:../Sources/mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
1556:../Sources/mcg.c ****  *
1557:../Sources/mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
1558:../Sources/mcg.c ****  */
1559:../Sources/mcg.c **** int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1560:../Sources/mcg.c **** {
 6746              		.loc 1 1560 0
 6747              		.cfi_startproc
 6748 0000 80B5     		push	{r7, lr}
 6749              	.LCFI66:
 6750              		.cfi_def_cfa_offset 8
 6751              		.cfi_offset 7, -8
 6752              		.cfi_offset 14, -4
 6753 0002 86B0     		sub	sp, sp, #24
 6754              	.LCFI67:
 6755              		.cfi_def_cfa_offset 32
 6756 0004 00AF     		add	r7, sp, #0
 6757              	.LCFI68:
 6758              		.cfi_def_cfa_register 7
 6759 0006 7860     		str	r0, [r7, #4]
 6760 0008 FB1C     		add	r3, r7, #3
 6761 000a 1970     		strb	r1, [r3]
 6762 000c BB1C     		add	r3, r7, #2
 6763 000e 1A70     		strb	r2, [r3]
1561:../Sources/mcg.c ****   unsigned char frdiv_val;
1562:../Sources/mcg.c ****   unsigned char temp_reg;
1563:../Sources/mcg.c ****  // short i;
1564:../Sources/mcg.c ****   int mcg_out, fll_ref_freq, i;
1565:../Sources/mcg.c ****   
1566:../Sources/mcg.c **** // check if in FEI mode
1567:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6764              		.loc 1 1567 0
 6765 0010 AC4B     		ldr	r3, .L559
 6766 0012 9B79     		ldrb	r3, [r3, #6]
 6767 0014 DBB2     		uxtb	r3, r3
 6768 0016 1A1C     		mov	r2, r3
 6769 0018 0C23     		mov	r3, #12
 6770 001a 1340     		and	r3, r2
 6771 001c 9B08     		lsr	r3, r3, #2
 6772 001e 0DD1     		bne	.L527
1568:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 6773              		.loc 1 1568 0 discriminator 1
 6774 0020 A84B     		ldr	r3, .L559
 6775 0022 9B79     		ldrb	r3, [r3, #6]
 6776 0024 DBB2     		uxtb	r3, r3
 6777 0026 1A1C     		mov	r2, r3
 6778 0028 1023     		mov	r3, #16
 6779 002a 1340     		and	r3, r2
1567:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6780              		.loc 1 1567 0 discriminator 1
 6781 002c 06D0     		beq	.L527
1569:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 6782              		.loc 1 1569 0 discriminator 1
 6783 002e A54B     		ldr	r3, .L559
 6784 0030 9B79     		ldrb	r3, [r3, #6]
 6785 0032 DBB2     		uxtb	r3, r3
 6786 0034 1A1C     		mov	r2, r3
 6787 0036 2023     		mov	r3, #32
 6788 0038 1340     		and	r3, r2
1567:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 6789              		.loc 1 1567 0 discriminator 1
 6790 003a 01D0     		beq	.L528
 6791              	.L527:
1570:../Sources/mcg.c ****   {
1571:../Sources/mcg.c ****     return 0x1;                                                     // return error code
 6792              		.loc 1 1571 0
 6793 003c 0123     		mov	r3, #1
 6794 003e 3CE1     		b	.L529
 6795              	.L528:
1572:../Sources/mcg.c ****   }
1573:../Sources/mcg.c **** 
1574:../Sources/mcg.c **** // check external frequency is less than the maximum frequency
1575:../Sources/mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 6796              		.loc 1 1575 0
 6797 0040 7A68     		ldr	r2, [r7, #4]
 6798 0042 A14B     		ldr	r3, .L559+4
 6799 0044 9A42     		cmp	r2, r3
 6800 0046 01DD     		ble	.L530
 6801              		.loc 1 1575 0 is_stmt 0 discriminator 1
 6802 0048 2123     		mov	r3, #33
 6803 004a 36E1     		b	.L529
 6804              	.L530:
1576:../Sources/mcg.c ****   
1577:../Sources/mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
1578:../Sources/mcg.c ****   if (erefs_val)
 6805              		.loc 1 1578 0 is_stmt 1
 6806 004c BB1C     		add	r3, r7, #2
 6807 004e 1B78     		ldrb	r3, [r3]
 6808 0050 002B     		cmp	r3, #0
 6809 0052 11D0     		beq	.L531
1579:../Sources/mcg.c ****   {
1580:../Sources/mcg.c ****     if ((crystal_val < 30000) ||
 6810              		.loc 1 1580 0
 6811 0054 7A68     		ldr	r2, [r7, #4]
 6812 0056 9D4B     		ldr	r3, .L559+8
 6813 0058 9A42     		cmp	r2, r3
 6814 005a 0BDD     		ble	.L532
 6815              		.loc 1 1580 0 is_stmt 0 discriminator 1
 6816 005c 7A68     		ldr	r2, [r7, #4]
 6817 005e 9C4B     		ldr	r3, .L559+12
 6818 0060 9A42     		cmp	r2, r3
 6819 0062 03DD     		ble	.L533
1581:../Sources/mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 6820              		.loc 1 1581 0 is_stmt 1
 6821 0064 7A68     		ldr	r2, [r7, #4]
 6822 0066 9B4B     		ldr	r3, .L559+16
 6823 0068 9A42     		cmp	r2, r3
 6824 006a 03DD     		ble	.L532
 6825              	.L533:
 6826              		.loc 1 1581 0 is_stmt 0 discriminator 1
 6827 006c 7A68     		ldr	r2, [r7, #4]
 6828 006e 9A4B     		ldr	r3, .L559+20
 6829 0070 9A42     		cmp	r2, r3
 6830 0072 01DD     		ble	.L531
 6831              	.L532:
1582:../Sources/mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 6832              		.loc 1 1582 0 is_stmt 1
 6833 0074 2223     		mov	r3, #34
 6834 0076 20E1     		b	.L529
 6835              	.L531:
1583:../Sources/mcg.c ****   }
1584:../Sources/mcg.c **** 
1585:../Sources/mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1586:../Sources/mcg.c ****   if (hgo_val > 0)
 6836              		.loc 1 1586 0
 6837 0078 FB1C     		add	r3, r7, #3
 6838 007a 1B78     		ldrb	r3, [r3]
 6839 007c 002B     		cmp	r3, #0
 6840 007e 02D0     		beq	.L534
1587:../Sources/mcg.c ****   {
1588:../Sources/mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 6841              		.loc 1 1588 0
 6842 0080 FB1C     		add	r3, r7, #3
 6843 0082 0122     		mov	r2, #1
 6844 0084 1A70     		strb	r2, [r3]
 6845              	.L534:
1589:../Sources/mcg.c ****   }
1590:../Sources/mcg.c **** 
1591:../Sources/mcg.c **** // configure the MCG_C2 register
1592:../Sources/mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1593:../Sources/mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
1594:../Sources/mcg.c ****   temp_reg = MCG_C2;
 6846              		.loc 1 1594 0
 6847 0086 8F4A     		ldr	r2, .L559
 6848 0088 3B1C     		mov	r3, r7
 6849 008a 1633     		add	r3, r3, #22
 6850 008c 5278     		ldrb	r2, [r2, #1]
 6851 008e 1A70     		strb	r2, [r3]
1595:../Sources/mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 6852              		.loc 1 1595 0
 6853 0090 3B1C     		mov	r3, r7
 6854 0092 1633     		add	r3, r3, #22
 6855 0094 3A1C     		mov	r2, r7
 6856 0096 1632     		add	r2, r2, #22
 6857 0098 1278     		ldrb	r2, [r2]
 6858 009a 3C21     		mov	r1, #60
 6859 009c 8A43     		bic	r2, r1
 6860 009e 1A70     		strb	r2, [r3]
1596:../Sources/mcg.c ****   if (crystal_val <= 40000)
 6861              		.loc 1 1596 0
 6862 00a0 7A68     		ldr	r2, [r7, #4]
 6863 00a2 8B4B     		ldr	r3, .L559+12
 6864 00a4 9A42     		cmp	r2, r3
 6865 00a6 11DC     		bgt	.L535
1597:../Sources/mcg.c ****   {
1598:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 6866              		.loc 1 1598 0
 6867 00a8 FB1C     		add	r3, r7, #3
 6868 00aa 1B78     		ldrb	r3, [r3]
 6869 00ac DB00     		lsl	r3, r3, #3
 6870 00ae DAB2     		uxtb	r2, r3
 6871 00b0 BB1C     		add	r3, r7, #2
 6872 00b2 1B78     		ldrb	r3, [r3]
 6873 00b4 9B00     		lsl	r3, r3, #2
 6874 00b6 DBB2     		uxtb	r3, r3
 6875 00b8 1343     		orr	r3, r2
 6876 00ba D9B2     		uxtb	r1, r3
 6877 00bc 3B1C     		mov	r3, r7
 6878 00be 1633     		add	r3, r3, #22
 6879 00c0 3A1C     		mov	r2, r7
 6880 00c2 1632     		add	r2, r2, #22
 6881 00c4 1278     		ldrb	r2, [r2]
 6882 00c6 0A43     		orr	r2, r1
 6883 00c8 1A70     		strb	r2, [r3]
 6884 00ca 2CE0     		b	.L536
 6885              	.L535:
1599:../Sources/mcg.c ****   }
1600:../Sources/mcg.c ****   else if (crystal_val <= 8000000)
 6886              		.loc 1 1600 0
 6887 00cc 7A68     		ldr	r2, [r7, #4]
 6888 00ce 834B     		ldr	r3, .L559+24
 6889 00d0 9A42     		cmp	r2, r3
 6890 00d2 14DC     		bgt	.L537
1601:../Sources/mcg.c ****   {
1602:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 6891              		.loc 1 1602 0
 6892 00d4 FB1C     		add	r3, r7, #3
 6893 00d6 1B78     		ldrb	r3, [r3]
 6894 00d8 DB00     		lsl	r3, r3, #3
 6895 00da DAB2     		uxtb	r2, r3
 6896 00dc BB1C     		add	r3, r7, #2
 6897 00de 1B78     		ldrb	r3, [r3]
 6898 00e0 9B00     		lsl	r3, r3, #2
 6899 00e2 DBB2     		uxtb	r3, r3
 6900 00e4 1343     		orr	r3, r2
 6901 00e6 DAB2     		uxtb	r2, r3
 6902 00e8 3B1C     		mov	r3, r7
 6903 00ea 1633     		add	r3, r3, #22
 6904 00ec 1B78     		ldrb	r3, [r3]
 6905 00ee 1343     		orr	r3, r2
 6906 00f0 DAB2     		uxtb	r2, r3
 6907 00f2 3B1C     		mov	r3, r7
 6908 00f4 1633     		add	r3, r3, #22
 6909 00f6 1021     		mov	r1, #16
 6910 00f8 0A43     		orr	r2, r1
 6911 00fa 1A70     		strb	r2, [r3]
 6912 00fc 13E0     		b	.L536
 6913              	.L537:
1603:../Sources/mcg.c ****   }
1604:../Sources/mcg.c ****   else
1605:../Sources/mcg.c ****   {
1606:../Sources/mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 6914              		.loc 1 1606 0
 6915 00fe FB1C     		add	r3, r7, #3
 6916 0100 1B78     		ldrb	r3, [r3]
 6917 0102 DB00     		lsl	r3, r3, #3
 6918 0104 DAB2     		uxtb	r2, r3
 6919 0106 BB1C     		add	r3, r7, #2
 6920 0108 1B78     		ldrb	r3, [r3]
 6921 010a 9B00     		lsl	r3, r3, #2
 6922 010c DBB2     		uxtb	r3, r3
 6923 010e 1343     		orr	r3, r2
 6924 0110 DAB2     		uxtb	r2, r3
 6925 0112 3B1C     		mov	r3, r7
 6926 0114 1633     		add	r3, r3, #22
 6927 0116 1B78     		ldrb	r3, [r3]
 6928 0118 1343     		orr	r3, r2
 6929 011a DAB2     		uxtb	r2, r3
 6930 011c 3B1C     		mov	r3, r7
 6931 011e 1633     		add	r3, r3, #22
 6932 0120 2021     		mov	r1, #32
 6933 0122 0A43     		orr	r2, r1
 6934 0124 1A70     		strb	r2, [r3]
 6935              	.L536:
1607:../Sources/mcg.c ****   }
1608:../Sources/mcg.c ****   MCG_C2 = temp_reg;
 6936              		.loc 1 1608 0
 6937 0126 674B     		ldr	r3, .L559
 6938 0128 3A1C     		mov	r2, r7
 6939 012a 1632     		add	r2, r2, #22
 6940 012c 1278     		ldrb	r2, [r2]
 6941 012e 5A70     		strb	r2, [r3, #1]
1609:../Sources/mcg.c **** 
1610:../Sources/mcg.c **** // determine FRDIV based on reference clock frequency
1611:../Sources/mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1612:../Sources/mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 6942              		.loc 1 1612 0
 6943 0130 7A68     		ldr	r2, [r7, #4]
 6944 0132 6B4B     		ldr	r3, .L559+28
 6945 0134 9A42     		cmp	r2, r3
 6946 0136 04DC     		bgt	.L538
 6947              		.loc 1 1612 0 is_stmt 0 discriminator 1
 6948 0138 3B1C     		mov	r3, r7
 6949 013a 1733     		add	r3, r3, #23
 6950 013c 0022     		mov	r2, #0
 6951 013e 1A70     		strb	r2, [r3]
 6952 0140 27E0     		b	.L539
 6953              	.L538:
1613:../Sources/mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 6954              		.loc 1 1613 0 is_stmt 1
 6955 0142 7A68     		ldr	r2, [r7, #4]
 6956 0144 674B     		ldr	r3, .L559+32
 6957 0146 9A42     		cmp	r2, r3
 6958 0148 04DC     		bgt	.L540
 6959              		.loc 1 1613 0 is_stmt 0 discriminator 1
 6960 014a 3B1C     		mov	r3, r7
 6961 014c 1733     		add	r3, r3, #23
 6962 014e 0122     		mov	r2, #1
 6963 0150 1A70     		strb	r2, [r3]
 6964 0152 1EE0     		b	.L539
 6965              	.L540:
1614:../Sources/mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 6966              		.loc 1 1614 0 is_stmt 1
 6967 0154 7A68     		ldr	r2, [r7, #4]
 6968 0156 644B     		ldr	r3, .L559+36
 6969 0158 9A42     		cmp	r2, r3
 6970 015a 04DC     		bgt	.L541
 6971              		.loc 1 1614 0 is_stmt 0 discriminator 1
 6972 015c 3B1C     		mov	r3, r7
 6973 015e 1733     		add	r3, r3, #23
 6974 0160 0222     		mov	r2, #2
 6975 0162 1A70     		strb	r2, [r3]
 6976 0164 15E0     		b	.L539
 6977              	.L541:
1615:../Sources/mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 6978              		.loc 1 1615 0 is_stmt 1
 6979 0166 7A68     		ldr	r2, [r7, #4]
 6980 0168 604B     		ldr	r3, .L559+40
 6981 016a 9A42     		cmp	r2, r3
 6982 016c 04DC     		bgt	.L542
 6983              		.loc 1 1615 0 is_stmt 0 discriminator 1
 6984 016e 3B1C     		mov	r3, r7
 6985 0170 1733     		add	r3, r3, #23
 6986 0172 0322     		mov	r2, #3
 6987 0174 1A70     		strb	r2, [r3]
 6988 0176 0CE0     		b	.L539
 6989              	.L542:
1616:../Sources/mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 6990              		.loc 1 1616 0 is_stmt 1
 6991 0178 7A68     		ldr	r2, [r7, #4]
 6992 017a 5D4B     		ldr	r3, .L559+44
 6993 017c 9A42     		cmp	r2, r3
 6994 017e 04DC     		bgt	.L543
 6995              		.loc 1 1616 0 is_stmt 0 discriminator 1
 6996 0180 3B1C     		mov	r3, r7
 6997 0182 1733     		add	r3, r3, #23
 6998 0184 0422     		mov	r2, #4
 6999 0186 1A70     		strb	r2, [r3]
 7000 0188 03E0     		b	.L539
 7001              	.L543:
1617:../Sources/mcg.c ****   else {frdiv_val = 5;}
 7002              		.loc 1 1617 0 is_stmt 1
 7003 018a 3B1C     		mov	r3, r7
 7004 018c 1733     		add	r3, r3, #23
 7005 018e 0522     		mov	r2, #5
 7006 0190 1A70     		strb	r2, [r3]
 7007              	.L539:
1618:../Sources/mcg.c ****    
1619:../Sources/mcg.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
1620:../Sources/mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 7008              		.loc 1 1620 0
 7009 0192 4C4B     		ldr	r3, .L559
 7010 0194 5B78     		ldrb	r3, [r3, #1]
 7011 0196 DBB2     		uxtb	r3, r3
 7012 0198 1A1C     		mov	r2, r3
 7013 019a 3023     		mov	r3, #48
 7014 019c 1340     		and	r3, r2
 7015 019e 1B09     		lsr	r3, r3, #4
 7016 01a0 0DD0     		beq	.L544
1621:../Sources/mcg.c ****   {
1622:../Sources/mcg.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 7017              		.loc 1 1622 0
 7018 01a2 3B1C     		mov	r3, r7
 7019 01a4 1733     		add	r3, r3, #23
 7020 01a6 1B78     		ldrb	r3, [r3]
 7021 01a8 2022     		mov	r2, #32
 7022 01aa 111C     		mov	r1, r2
 7023 01ac 9940     		lsl	r1, r1, r3
 7024 01ae 0B1C     		mov	r3, r1
 7025 01b0 7868     		ldr	r0, [r7, #4]
 7026 01b2 191C     		mov	r1, r3
 7027 01b4 FFF7FEFF 		bl	__aeabi_idiv
 7028 01b8 031C     		mov	r3, r0
 7029 01ba 3B61     		str	r3, [r7, #16]
 7030 01bc 0CE0     		b	.L545
 7031              	.L544:
1623:../Sources/mcg.c ****   }
1624:../Sources/mcg.c ****   else
1625:../Sources/mcg.c ****   {
1626:../Sources/mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 7032              		.loc 1 1626 0
 7033 01be 3B1C     		mov	r3, r7
 7034 01c0 1733     		add	r3, r3, #23
 7035 01c2 1B78     		ldrb	r3, [r3]
 7036 01c4 0122     		mov	r2, #1
 7037 01c6 111C     		mov	r1, r2
 7038 01c8 9940     		lsl	r1, r1, r3
 7039 01ca 0B1C     		mov	r3, r1
 7040 01cc 7868     		ldr	r0, [r7, #4]
 7041 01ce 191C     		mov	r1, r3
 7042 01d0 FFF7FEFF 		bl	__aeabi_idiv
 7043 01d4 031C     		mov	r3, r0
 7044 01d6 3B61     		str	r3, [r7, #16]
 7045              	.L545:
1627:../Sources/mcg.c ****   }
1628:../Sources/mcg.c ****   
1629:../Sources/mcg.c **** // Check resulting FLL frequency 
1630:../Sources/mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 7046              		.loc 1 1630 0
 7047 01d8 3B69     		ldr	r3, [r7, #16]
 7048 01da 181C     		mov	r0, r3
 7049 01dc FFF7FEFF 		bl	fll_freq
 7050 01e0 031C     		mov	r3, r0
 7051 01e2 BB60     		str	r3, [r7, #8]
1631:../Sources/mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 7052              		.loc 1 1631 0
 7053 01e4 BB68     		ldr	r3, [r7, #8]
 7054 01e6 3B2B     		cmp	r3, #59
 7055 01e8 01DC     		bgt	.L546
 7056              		.loc 1 1631 0 is_stmt 0 discriminator 1
 7057 01ea BB68     		ldr	r3, [r7, #8]
 7058 01ec 65E0     		b	.L529
 7059              	.L546:
1632:../Sources/mcg.c ****   
1633:../Sources/mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1634:../Sources/mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1635:../Sources/mcg.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1636:../Sources/mcg.c ****   temp_reg = MCG_C1;
 7060              		.loc 1 1636 0 is_stmt 1
 7061 01ee 354A     		ldr	r2, .L559
 7062 01f0 3B1C     		mov	r3, r7
 7063 01f2 1633     		add	r3, r3, #22
 7064 01f4 1278     		ldrb	r2, [r2]
 7065 01f6 1A70     		strb	r2, [r3]
1637:../Sources/mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 7066              		.loc 1 1637 0
 7067 01f8 3B1C     		mov	r3, r7
 7068 01fa 1633     		add	r3, r3, #22
 7069 01fc 3A1C     		mov	r2, r7
 7070 01fe 1632     		add	r2, r2, #22
 7071 0200 1178     		ldrb	r1, [r2]
 7072 0202 0322     		mov	r2, #3
 7073 0204 0A40     		and	r2, r1
 7074 0206 1A70     		strb	r2, [r3]
1638:../Sources/mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 7075              		.loc 1 1638 0
 7076 0208 3B1C     		mov	r3, r7
 7077 020a 1733     		add	r3, r3, #23
 7078 020c 1B78     		ldrb	r3, [r3]
 7079 020e DB00     		lsl	r3, r3, #3
 7080 0210 DAB2     		uxtb	r2, r3
 7081 0212 3823     		mov	r3, #56
 7082 0214 1340     		and	r3, r2
 7083 0216 D9B2     		uxtb	r1, r3
 7084 0218 3B1C     		mov	r3, r7
 7085 021a 1633     		add	r3, r3, #22
 7086 021c 3A1C     		mov	r2, r7
 7087 021e 1632     		add	r2, r2, #22
 7088 0220 1278     		ldrb	r2, [r2]
 7089 0222 0A43     		orr	r2, r1
 7090 0224 1A70     		strb	r2, [r3]
1639:../Sources/mcg.c ****   MCG_C1 = temp_reg;
 7091              		.loc 1 1639 0
 7092 0226 274B     		ldr	r3, .L559
 7093 0228 3A1C     		mov	r2, r7
 7094 022a 1632     		add	r2, r2, #22
 7095 022c 1278     		ldrb	r2, [r2]
 7096 022e 1A70     		strb	r2, [r3]
1640:../Sources/mcg.c **** 
1641:../Sources/mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
1642:../Sources/mcg.c ****   if (erefs_val)
 7097              		.loc 1 1642 0
 7098 0230 BB1C     		add	r3, r7, #2
 7099 0232 1B78     		ldrb	r3, [r3]
 7100 0234 002B     		cmp	r3, #0
 7101 0236 1BD0     		beq	.L547
1643:../Sources/mcg.c ****   {
1644:../Sources/mcg.c ****     for (i = 0 ; i < 20000000 ; i++)
 7102              		.loc 1 1644 0
 7103 0238 0023     		mov	r3, #0
 7104 023a FB60     		str	r3, [r7, #12]
 7105 023c 09E0     		b	.L548
 7106              	.L551:
1645:../Sources/mcg.c ****     {
1646:../Sources/mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 7107              		.loc 1 1646 0
 7108 023e 214B     		ldr	r3, .L559
 7109 0240 9B79     		ldrb	r3, [r3, #6]
 7110 0242 DBB2     		uxtb	r3, r3
 7111 0244 1A1C     		mov	r2, r3
 7112 0246 0223     		mov	r3, #2
 7113 0248 1340     		and	r3, r2
 7114 024a 07D1     		bne	.L557
 7115              	.L549:
1644:../Sources/mcg.c ****     for (i = 0 ; i < 20000000 ; i++)
 7116              		.loc 1 1644 0
 7117 024c FB68     		ldr	r3, [r7, #12]
 7118 024e 0133     		add	r3, r3, #1
 7119 0250 FB60     		str	r3, [r7, #12]
 7120              	.L548:
1644:../Sources/mcg.c ****     for (i = 0 ; i < 20000000 ; i++)
 7121              		.loc 1 1644 0 is_stmt 0 discriminator 1
 7122 0252 FA68     		ldr	r2, [r7, #12]
 7123 0254 274B     		ldr	r3, .L559+48
 7124 0256 9A42     		cmp	r2, r3
 7125 0258 F1DD     		ble	.L551
 7126 025a 00E0     		b	.L550
 7127              	.L557:
 7128              		.loc 1 1646 0 is_stmt 1
 7129 025c C046     		mov	r8, r8
 7130              	.L550:
1647:../Sources/mcg.c ****     }
1648:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 7131              		.loc 1 1648 0
 7132 025e 194B     		ldr	r3, .L559
 7133 0260 9B79     		ldrb	r3, [r3, #6]
 7134 0262 DBB2     		uxtb	r3, r3
 7135 0264 1A1C     		mov	r2, r3
 7136 0266 0223     		mov	r3, #2
 7137 0268 1340     		and	r3, r2
 7138 026a 01D1     		bne	.L547
 7139              		.loc 1 1648 0 is_stmt 0 discriminator 1
 7140 026c 2323     		mov	r3, #35
 7141 026e 24E0     		b	.L529
 7142              	.L547:
1649:../Sources/mcg.c ****   }
1650:../Sources/mcg.c **** 
1651:../Sources/mcg.c **** // wait for Reference clock Status bit to clear
1652:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 7143              		.loc 1 1652 0 is_stmt 1
 7144 0270 0023     		mov	r3, #0
 7145 0272 FB60     		str	r3, [r7, #12]
 7146 0274 09E0     		b	.L552
 7147              	.L555:
1653:../Sources/mcg.c ****   {
1654:../Sources/mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 7148              		.loc 1 1654 0
 7149 0276 134B     		ldr	r3, .L559
 7150 0278 9B79     		ldrb	r3, [r3, #6]
 7151 027a DBB2     		uxtb	r3, r3
 7152 027c 1A1C     		mov	r2, r3
 7153 027e 1023     		mov	r3, #16
 7154 0280 1340     		and	r3, r2
 7155 0282 07D0     		beq	.L558
 7156              	.L553:
1652:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 7157              		.loc 1 1652 0
 7158 0284 FB68     		ldr	r3, [r7, #12]
 7159 0286 0133     		add	r3, r3, #1
 7160 0288 FB60     		str	r3, [r7, #12]
 7161              	.L552:
1652:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 7162              		.loc 1 1652 0 is_stmt 0 discriminator 1
 7163 028a FA68     		ldr	r2, [r7, #12]
 7164 028c 1A4B     		ldr	r3, .L559+52
 7165 028e 9A42     		cmp	r2, r3
 7166 0290 F1DD     		ble	.L555
 7167 0292 00E0     		b	.L554
 7168              	.L558:
 7169              		.loc 1 1654 0 is_stmt 1
 7170 0294 C046     		mov	r8, r8
 7171              	.L554:
1655:../Sources/mcg.c ****   }
1656:../Sources/mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 7172              		.loc 1 1656 0
 7173 0296 0B4B     		ldr	r3, .L559
 7174 0298 9B79     		ldrb	r3, [r3, #6]
 7175 029a DBB2     		uxtb	r3, r3
 7176 029c 1A1C     		mov	r2, r3
 7177 029e 1023     		mov	r3, #16
 7178 02a0 1340     		and	r3, r2
 7179 02a2 01D0     		beq	.L556
 7180              		.loc 1 1656 0 is_stmt 0 discriminator 1
 7181 02a4 1123     		mov	r3, #17
 7182 02a6 08E0     		b	.L529
 7183              	.L556:
1657:../Sources/mcg.c ****   
1658:../Sources/mcg.c **** // Now in FBE  
1659:../Sources/mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1660:../Sources/mcg.c **** // It is enabled here but can be removed if this is not required.
1661:../Sources/mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 7184              		.loc 1 1661 0 is_stmt 1
 7185 02a8 064B     		ldr	r3, .L559
 7186 02aa 064A     		ldr	r2, .L559
 7187 02ac 5279     		ldrb	r2, [r2, #5]
 7188 02ae D2B2     		uxtb	r2, r2
 7189 02b0 2021     		mov	r1, #32
 7190 02b2 0A43     		orr	r2, r1
 7191 02b4 D2B2     		uxtb	r2, r2
 7192 02b6 5A71     		strb	r2, [r3, #5]
1662:../Sources/mcg.c ****   
1663:../Sources/mcg.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 7193              		.loc 1 1663 0
 7194 02b8 BB68     		ldr	r3, [r7, #8]
 7195              	.L529:
1664:../Sources/mcg.c **** } // fei_fee
 7196              		.loc 1 1664 0
 7197 02ba 181C     		mov	r0, r3
 7198 02bc BD46     		mov	sp, r7
 7199 02be 06B0     		add	sp, sp, #24
 7200              		@ sp needed for prologue
 7201 02c0 80BD     		pop	{r7, pc}
 7202              	.L560:
 7203 02c2 C046     		.align	2
 7204              	.L559:
 7205 02c4 00400640 		.word	1074151424
 7206 02c8 80F0FA02 		.word	50000000
 7207 02cc 2F750000 		.word	29999
 7208 02d0 409C0000 		.word	40000
 7209 02d4 BFC62D00 		.word	2999999
 7210 02d8 0048E801 		.word	32000000
 7211 02dc 00127A00 		.word	8000000
 7212 02e0 D0121300 		.word	1250000
 7213 02e4 A0252600 		.word	2500000
 7214 02e8 404B4C00 		.word	5000000
 7215 02ec 80969800 		.word	10000000
 7216 02f0 002D3101 		.word	20000000
 7217 02f4 FF2C3101 		.word	19999999
 7218 02f8 CF070000 		.word	1999
 7219              		.cfi_endproc
 7220              	.LFE22:
 7222              		.section	.text.fee_fei,"ax",%progbits
 7223              		.align	2
 7224              		.global	fee_fei
 7225              		.code	16
 7226              		.thumb_func
 7228              	fee_fei:
 7229              	.LFB23:
1665:../Sources/mcg.c **** 
1666:../Sources/mcg.c **** 
1667:../Sources/mcg.c **** int fee_fei(int slow_irc_freq)
1668:../Sources/mcg.c **** {
 7230              		.loc 1 1668 0
 7231              		.cfi_startproc
 7232 0000 80B5     		push	{r7, lr}
 7233              	.LCFI69:
 7234              		.cfi_def_cfa_offset 8
 7235              		.cfi_offset 7, -8
 7236              		.cfi_offset 14, -4
 7237 0002 84B0     		sub	sp, sp, #16
 7238              	.LCFI70:
 7239              		.cfi_def_cfa_offset 24
 7240 0004 00AF     		add	r7, sp, #0
 7241              	.LCFI71:
 7242              		.cfi_def_cfa_register 7
 7243 0006 7860     		str	r0, [r7, #4]
1669:../Sources/mcg.c ****   short i;
1670:../Sources/mcg.c ****   int mcg_out;
1671:../Sources/mcg.c **** 
1672:../Sources/mcg.c **** // Check MCG is in FEE mode
1673:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 7244              		.loc 1 1673 0
 7245 0008 334B     		ldr	r3, .L574
 7246 000a 9B79     		ldrb	r3, [r3, #6]
 7247 000c DBB2     		uxtb	r3, r3
 7248 000e 1A1C     		mov	r2, r3
 7249 0010 0C23     		mov	r3, #12
 7250 0012 1340     		and	r3, r2
 7251 0014 9B08     		lsr	r3, r3, #2
 7252 0016 0DD1     		bne	.L562
1674:../Sources/mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 7253              		.loc 1 1674 0 discriminator 1
 7254 0018 2F4B     		ldr	r3, .L574
 7255 001a 9B79     		ldrb	r3, [r3, #6]
 7256 001c DBB2     		uxtb	r3, r3
 7257 001e 1A1C     		mov	r2, r3
 7258 0020 1023     		mov	r3, #16
 7259 0022 1340     		and	r3, r2
1673:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 7260              		.loc 1 1673 0 discriminator 1
 7261 0024 06D1     		bne	.L562
1675:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 7262              		.loc 1 1675 0 discriminator 1
 7263 0026 2C4B     		ldr	r3, .L574
 7264 0028 9B79     		ldrb	r3, [r3, #6]
 7265 002a DBB2     		uxtb	r3, r3
 7266 002c 1A1C     		mov	r2, r3
 7267 002e 2023     		mov	r3, #32
 7268 0030 1340     		and	r3, r2
1673:../Sources/mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 7269              		.loc 1 1673 0 discriminator 1
 7270 0032 01D0     		beq	.L563
 7271              	.L562:
1676:../Sources/mcg.c ****   {
1677:../Sources/mcg.c ****     return 0x2;                                                     // return error code
 7272              		.loc 1 1677 0
 7273 0034 0223     		mov	r3, #2
 7274 0036 4AE0     		b	.L564
 7275              	.L563:
1678:../Sources/mcg.c ****   } 
1679:../Sources/mcg.c ****       
1680:../Sources/mcg.c **** // Check IRC frequency is within spec.
1681:../Sources/mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 7276              		.loc 1 1681 0
 7277 0038 7A68     		ldr	r2, [r7, #4]
 7278 003a 284B     		ldr	r3, .L574+4
 7279 003c 9A42     		cmp	r2, r3
 7280 003e 03DD     		ble	.L565
 7281              		.loc 1 1681 0 is_stmt 0 discriminator 1
 7282 0040 7A68     		ldr	r2, [r7, #4]
 7283 0042 274B     		ldr	r3, .L574+8
 7284 0044 9A42     		cmp	r2, r3
 7285 0046 01DD     		ble	.L566
 7286              	.L565:
1682:../Sources/mcg.c ****   {
1683:../Sources/mcg.c ****     return 0x31;
 7287              		.loc 1 1683 0 is_stmt 1
 7288 0048 3123     		mov	r3, #49
 7289 004a 40E0     		b	.L564
 7290              	.L566:
1684:../Sources/mcg.c ****   }
1685:../Sources/mcg.c **** 
1686:../Sources/mcg.c ****   // Check resulting FLL frequency 
1687:../Sources/mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
 7291              		.loc 1 1687 0
 7292 004c 7B68     		ldr	r3, [r7, #4]
 7293 004e 181C     		mov	r0, r3
 7294 0050 FFF7FEFF 		bl	fll_freq
 7295 0054 031C     		mov	r3, r0
 7296 0056 BB60     		str	r3, [r7, #8]
1688:../Sources/mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 7297              		.loc 1 1688 0
 7298 0058 BB68     		ldr	r3, [r7, #8]
 7299 005a 3B2B     		cmp	r3, #59
 7300 005c 01DC     		bgt	.L567
 7301              		.loc 1 1688 0 is_stmt 0 discriminator 1
 7302 005e BB68     		ldr	r3, [r7, #8]
 7303 0060 35E0     		b	.L564
 7304              	.L567:
1689:../Sources/mcg.c ****   
1690:../Sources/mcg.c **** // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trigger
1691:../Sources/mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 7305              		.loc 1 1691 0 is_stmt 1
 7306 0062 1D4B     		ldr	r3, .L574
 7307 0064 1C4A     		ldr	r2, .L574
 7308 0066 5279     		ldrb	r2, [r2, #5]
 7309 0068 D2B2     		uxtb	r2, r2
 7310 006a 2021     		mov	r1, #32
 7311 006c 8A43     		bic	r2, r1
 7312 006e D2B2     		uxtb	r2, r2
 7313 0070 5A71     		strb	r2, [r3, #5]
1692:../Sources/mcg.c **** 
1693:../Sources/mcg.c **** // Change FLL reference clock from external to internal by setting IREFS bit
1694:../Sources/mcg.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 7314              		.loc 1 1694 0
 7315 0072 194B     		ldr	r3, .L574
 7316 0074 184A     		ldr	r2, .L574
 7317 0076 1278     		ldrb	r2, [r2]
 7318 0078 D2B2     		uxtb	r2, r2
 7319 007a 0421     		mov	r1, #4
 7320 007c 0A43     		orr	r2, r1
 7321 007e D2B2     		uxtb	r2, r2
 7322 0080 1A70     		strb	r2, [r3]
1695:../Sources/mcg.c ****   
1696:../Sources/mcg.c **** // wait for Reference clock to switch to internal reference 
1697:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 7323              		.loc 1 1697 0
 7324 0082 3B1C     		mov	r3, r7
 7325 0084 0E33     		add	r3, r3, #14
 7326 0086 0022     		mov	r2, #0
 7327 0088 1A80     		strh	r2, [r3]
 7328 008a 0DE0     		b	.L568
 7329              	.L571:
1698:../Sources/mcg.c ****   {
1699:../Sources/mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 7330              		.loc 1 1699 0
 7331 008c 124B     		ldr	r3, .L574
 7332 008e 9B79     		ldrb	r3, [r3, #6]
 7333 0090 DBB2     		uxtb	r3, r3
 7334 0092 1A1C     		mov	r2, r3
 7335 0094 1023     		mov	r3, #16
 7336 0096 1340     		and	r3, r2
 7337 0098 0ED1     		bne	.L573
 7338              	.L569:
1697:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 7339              		.loc 1 1697 0
 7340 009a 3B1C     		mov	r3, r7
 7341 009c 0E33     		add	r3, r3, #14
 7342 009e 3A1C     		mov	r2, r7
 7343 00a0 0E32     		add	r2, r2, #14
 7344 00a2 1288     		ldrh	r2, [r2]
 7345 00a4 0132     		add	r2, r2, #1
 7346 00a6 1A80     		strh	r2, [r3]
 7347              	.L568:
1697:../Sources/mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 7348              		.loc 1 1697 0 is_stmt 0 discriminator 1
 7349 00a8 3B1C     		mov	r3, r7
 7350 00aa 0E33     		add	r3, r3, #14
 7351 00ac 0021     		mov	r1, #0
 7352 00ae 5A5E     		ldrsh	r2, [r3, r1]
 7353 00b0 0C4B     		ldr	r3, .L574+12
 7354 00b2 9A42     		cmp	r2, r3
 7355 00b4 EADD     		ble	.L571
 7356 00b6 00E0     		b	.L570
 7357              	.L573:
 7358              		.loc 1 1699 0 is_stmt 1
 7359 00b8 C046     		mov	r8, r8
 7360              	.L570:
1700:../Sources/mcg.c ****   }
1701:../Sources/mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 7361              		.loc 1 1701 0
 7362 00ba 074B     		ldr	r3, .L574
 7363 00bc 9B79     		ldrb	r3, [r3, #6]
 7364 00be DBB2     		uxtb	r3, r3
 7365 00c0 1A1C     		mov	r2, r3
 7366 00c2 1023     		mov	r3, #16
 7367 00c4 1340     		and	r3, r2
 7368 00c6 01D1     		bne	.L572
 7369              		.loc 1 1701 0 is_stmt 0 discriminator 1
 7370 00c8 1223     		mov	r3, #18
 7371 00ca 00E0     		b	.L564
 7372              	.L572:
1702:../Sources/mcg.c ****   
1703:../Sources/mcg.c **** // Now in FEI mode  
1704:../Sources/mcg.c ****   return mcg_out;  
 7373              		.loc 1 1704 0 is_stmt 1
 7374 00cc BB68     		ldr	r3, [r7, #8]
 7375              	.L564:
1705:../Sources/mcg.c **** } // fee_fei
 7376              		.loc 1 1705 0
 7377 00ce 181C     		mov	r0, r3
 7378 00d0 BD46     		mov	sp, r7
 7379 00d2 04B0     		add	sp, sp, #16
 7380              		@ sp needed for prologue
 7381 00d4 80BD     		pop	{r7, pc}
 7382              	.L575:
 7383 00d6 C046     		.align	2
 7384              	.L574:
 7385 00d8 00400640 		.word	1074151424
 7386 00dc 117A0000 		.word	31249
 7387 00e0 97980000 		.word	39063
 7388 00e4 CF070000 		.word	1999
 7389              		.cfi_endproc
 7390              	.LFE23:
 7392              		.global	__aeabi_uidiv
 7393              		.global	__aeabi_i2f
 7394              		.global	__aeabi_fdiv
 7395              		.global	__aeabi_fmul
 7396              		.global	__aeabi_f2uiz
 7397              		.section	.text.atc,"ax",%progbits
 7398              		.align	2
 7399              		.global	atc
 7400              		.code	16
 7401              		.thumb_func
 7403              	atc:
 7404              	.LFB24:
1706:../Sources/mcg.c **** 
1707:../Sources/mcg.c **** 
1708:../Sources/mcg.c **** 
1709:../Sources/mcg.c **** unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq)
1710:../Sources/mcg.c **** {
 7405              		.loc 1 1710 0
 7406              		.cfi_startproc
 7407 0000 90B5     		push	{r4, r7, lr}
 7408              	.LCFI72:
 7409              		.cfi_def_cfa_offset 12
 7410              		.cfi_offset 4, -12
 7411              		.cfi_offset 7, -8
 7412              		.cfi_offset 14, -4
 7413 0002 8BB0     		sub	sp, sp, #44
 7414              	.LCFI73:
 7415              		.cfi_def_cfa_offset 56
 7416 0004 00AF     		add	r7, sp, #0
 7417              	.LCFI74:
 7418              		.cfi_def_cfa_register 7
 7419 0006 B960     		str	r1, [r7, #8]
 7420 0008 7A60     		str	r2, [r7, #4]
 7421 000a 3B1C     		mov	r3, r7
 7422 000c 0F33     		add	r3, r3, #15
 7423 000e 021C     		add	r2, r0, #0
 7424 0010 1A70     		strb	r2, [r3]
1711:../Sources/mcg.c ****   unsigned char mcg_mode;
1712:../Sources/mcg.c ****   unsigned short atcv;
1713:../Sources/mcg.c ****   int bus_clock_freq;
1714:../Sources/mcg.c ****   int  bus_clk_div_val;
1715:../Sources/mcg.c ****   int orig_div;
1716:../Sources/mcg.c ****   int temp_reg;
1717:../Sources/mcg.c ****   
1718:../Sources/mcg.c ****   if (irc_select > 0) // force irc to 1 if greater than 0
 7425              		.loc 1 1718 0
 7426 0012 3B1C     		mov	r3, r7
 7427 0014 0F33     		add	r3, r3, #15
 7428 0016 1B78     		ldrb	r3, [r3]
 7429 0018 002B     		cmp	r3, #0
 7430 001a 03D0     		beq	.L577
1719:../Sources/mcg.c ****   {
1720:../Sources/mcg.c ****     irc_select = 1;
 7431              		.loc 1 1720 0
 7432 001c 3B1C     		mov	r3, r7
 7433 001e 0F33     		add	r3, r3, #15
 7434 0020 0122     		mov	r2, #1
 7435 0022 1A70     		strb	r2, [r3]
 7436              	.L577:
1721:../Sources/mcg.c ****   }
1722:../Sources/mcg.c ****   
1723:../Sources/mcg.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
 7437              		.loc 1 1723 0
 7438 0024 3C1C     		mov	r4, r7
 7439 0026 2534     		add	r4, r4, #37
 7440 0028 FFF7FEFF 		bl	what_mcg_mode
 7441 002c 031C     		mov	r3, r0
 7442 002e 2370     		strb	r3, [r4]
1724:../Sources/mcg.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 7443              		.loc 1 1724 0
 7444 0030 3B1C     		mov	r3, r7
 7445 0032 2533     		add	r3, r3, #37
 7446 0034 1B78     		ldrb	r3, [r3]
 7447 0036 082B     		cmp	r3, #8
 7448 0038 0BD0     		beq	.L578
 7449              		.loc 1 1724 0 is_stmt 0 discriminator 1
 7450 003a 3B1C     		mov	r3, r7
 7451 003c 2533     		add	r3, r3, #37
 7452 003e 1B78     		ldrb	r3, [r3]
 7453 0040 072B     		cmp	r3, #7
 7454 0042 06D0     		beq	.L578
 7455 0044 3B1C     		mov	r3, r7
 7456 0046 2533     		add	r3, r3, #37
 7457 0048 1B78     		ldrb	r3, [r3]
 7458 004a 052B     		cmp	r3, #5
 7459 004c 01D0     		beq	.L578
1725:../Sources/mcg.c ****   {
1726:../Sources/mcg.c ****     return 1; // return error code if not in PEE, PBE or FBE modes
 7460              		.loc 1 1726 0 is_stmt 1
 7461 004e 0123     		mov	r3, #1
 7462 0050 10E1     		b	.L579
 7463              	.L578:
1727:../Sources/mcg.c ****   }
1728:../Sources/mcg.c ****   
1729:../Sources/mcg.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 7464              		.loc 1 1729 0
 7465 0052 8A4A     		ldr	r2, .L594
 7466 0054 8A4B     		ldr	r3, .L594+4
 7467 0056 D358     		ldr	r3, [r2, r3]
 7468 0058 3B62     		str	r3, [r7, #32]
1730:../Sources/mcg.c ****   
1731:../Sources/mcg.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 7469              		.loc 1 1731 0
 7470 005a 7B68     		ldr	r3, [r7, #4]
 7471 005c 181C     		mov	r0, r3
 7472 005e 8949     		ldr	r1, .L594+8
 7473 0060 FFF7FEFF 		bl	__aeabi_idiv
 7474 0064 031C     		mov	r3, r0
 7475 0066 FB61     		str	r3, [r7, #28]
1732:../Sources/mcg.c ****   temp_reg = SIM_CLKDIV1;
 7476              		.loc 1 1732 0
 7477 0068 844A     		ldr	r2, .L594
 7478 006a 854B     		ldr	r3, .L594+4
 7479 006c D358     		ldr	r3, [r2, r3]
 7480 006e BB61     		str	r3, [r7, #24]
1733:../Sources/mcg.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
 7481              		.loc 1 1733 0
 7482 0070 BA69     		ldr	r2, [r7, #24]
 7483 0072 854B     		ldr	r3, .L594+12
 7484 0074 1340     		and	r3, r2
 7485 0076 BB61     		str	r3, [r7, #24]
1734:../Sources/mcg.c ****   // set all bus and flash dividers to same value to ensure clocking restrictions are met
1735:../Sources/mcg.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 7486              		.loc 1 1735 0
 7487 0078 FB69     		ldr	r3, [r7, #28]
 7488 007a 1A04     		lsl	r2, r3, #16
 7489 007c E023     		mov	r3, #224
 7490 007e DB02     		lsl	r3, r3, #11
 7491 0080 1A40     		and	r2, r3
 7492 0082 BB69     		ldr	r3, [r7, #24]
 7493 0084 1343     		orr	r3, r2
 7494 0086 BB61     		str	r3, [r7, #24]
1736:../Sources/mcg.c ****   SIM_CLKDIV1 = temp_reg; // set actual dividers
 7495              		.loc 1 1736 0
 7496 0088 7C4A     		ldr	r2, .L594
 7497 008a B969     		ldr	r1, [r7, #24]
 7498 008c 7C4B     		ldr	r3, .L594+4
 7499 008e D150     		str	r1, [r2, r3]
1737:../Sources/mcg.c ****   
1738:../Sources/mcg.c ****   bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same
 7500              		.loc 1 1738 0
 7501 0090 7A68     		ldr	r2, [r7, #4]
 7502 0092 7A49     		ldr	r1, .L594
 7503 0094 7A4B     		ldr	r3, .L594+4
 7504 0096 CB58     		ldr	r3, [r1, r3]
 7505 0098 1B0C     		lsr	r3, r3, #16
 7506 009a 0133     		add	r3, r3, #1
 7507 009c 101C     		mov	r0, r2
 7508 009e 191C     		mov	r1, r3
 7509 00a0 FFF7FEFF 		bl	__aeabi_uidiv
 7510 00a4 031C     		mov	r3, r0
 7511 00a6 7B61     		str	r3, [r7, #20]
1739:../Sources/mcg.c ****   if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
 7512              		.loc 1 1739 0
 7513 00a8 7A69     		ldr	r2, [r7, #20]
 7514 00aa 784B     		ldr	r3, .L594+16
 7515 00ac 9A42     		cmp	r2, r3
 7516 00ae 03DD     		ble	.L580
 7517              		.loc 1 1739 0 is_stmt 0 discriminator 1
 7518 00b0 7A69     		ldr	r2, [r7, #20]
 7519 00b2 744B     		ldr	r3, .L594+8
 7520 00b4 9A42     		cmp	r2, r3
 7521 00b6 05DD     		ble	.L581
 7522              	.L580:
1740:../Sources/mcg.c ****   {
1741:../Sources/mcg.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7523              		.loc 1 1741 0 is_stmt 1
 7524 00b8 704A     		ldr	r2, .L594
 7525 00ba 396A     		ldr	r1, [r7, #32]
 7526 00bc 704B     		ldr	r3, .L594+4
 7527 00be D150     		str	r1, [r2, r3]
1742:../Sources/mcg.c ****     return 3; // error, bus clock frequency is not within 8MHz to 16MHz
 7528              		.loc 1 1742 0
 7529 00c0 0323     		mov	r3, #3
 7530 00c2 D7E0     		b	.L579
 7531              	.L581:
1743:../Sources/mcg.c ****   }
1744:../Sources/mcg.c ****                 
1745:../Sources/mcg.c ****   if(!irc_select) //determine if slow or fast IRC to be trimmed
 7532              		.loc 1 1745 0
 7533 00c4 3B1C     		mov	r3, r7
 7534 00c6 0F33     		add	r3, r3, #15
 7535 00c8 1B78     		ldrb	r3, [r3]
 7536 00ca 002B     		cmp	r3, #0
 7537 00cc 13D1     		bne	.L582
1746:../Sources/mcg.c ****   {
1747:../Sources/mcg.c ****     if (irc_freq < 31250) // check frequency is above min spec.
 7538              		.loc 1 1747 0
 7539 00ce BA68     		ldr	r2, [r7, #8]
 7540 00d0 6F4B     		ldr	r3, .L594+20
 7541 00d2 9A42     		cmp	r2, r3
 7542 00d4 05DC     		bgt	.L583
1748:../Sources/mcg.c ****     {
1749:../Sources/mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7543              		.loc 1 1749 0
 7544 00d6 694A     		ldr	r2, .L594
 7545 00d8 396A     		ldr	r1, [r7, #32]
 7546 00da 694B     		ldr	r3, .L594+4
 7547 00dc D150     		str	r1, [r2, r3]
1750:../Sources/mcg.c ****       return 4;
 7548              		.loc 1 1750 0
 7549 00de 0423     		mov	r3, #4
 7550 00e0 C8E0     		b	.L579
 7551              	.L583:
1751:../Sources/mcg.c ****     }
1752:../Sources/mcg.c ****     if (irc_freq > 39062) // check frequency is below max spec.
 7552              		.loc 1 1752 0
 7553 00e2 BA68     		ldr	r2, [r7, #8]
 7554 00e4 6B4B     		ldr	r3, .L594+24
 7555 00e6 9A42     		cmp	r2, r3
 7556 00e8 19DD     		ble	.L584
1753:../Sources/mcg.c ****     {
1754:../Sources/mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7557              		.loc 1 1754 0
 7558 00ea 644A     		ldr	r2, .L594
 7559 00ec 396A     		ldr	r1, [r7, #32]
 7560 00ee 644B     		ldr	r3, .L594+4
 7561 00f0 D150     		str	r1, [r2, r3]
1755:../Sources/mcg.c ****       return 5;
 7562              		.loc 1 1755 0
 7563 00f2 0523     		mov	r3, #5
 7564 00f4 BEE0     		b	.L579
 7565              	.L582:
1756:../Sources/mcg.c ****     }         
1757:../Sources/mcg.c ****   }
1758:../Sources/mcg.c ****   else
1759:../Sources/mcg.c ****   {
1760:../Sources/mcg.c ****     if (irc_freq < 3000000) // check frequency is above min spec.
 7566              		.loc 1 1760 0
 7567 00f6 BA68     		ldr	r2, [r7, #8]
 7568 00f8 674B     		ldr	r3, .L594+28
 7569 00fa 9A42     		cmp	r2, r3
 7570 00fc 05DC     		bgt	.L585
1761:../Sources/mcg.c ****     {
1762:../Sources/mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7571              		.loc 1 1762 0
 7572 00fe 5F4A     		ldr	r2, .L594
 7573 0100 396A     		ldr	r1, [r7, #32]
 7574 0102 5F4B     		ldr	r3, .L594+4
 7575 0104 D150     		str	r1, [r2, r3]
1763:../Sources/mcg.c ****       return 6;
 7576              		.loc 1 1763 0
 7577 0106 0623     		mov	r3, #6
 7578 0108 B4E0     		b	.L579
 7579              	.L585:
1764:../Sources/mcg.c ****     }
1765:../Sources/mcg.c ****     if (irc_freq > 5000000) // check frequency is below max spec.
 7580              		.loc 1 1765 0
 7581 010a BA68     		ldr	r2, [r7, #8]
 7582 010c 634B     		ldr	r3, .L594+32
 7583 010e 9A42     		cmp	r2, r3
 7584 0110 05DD     		ble	.L584
1766:../Sources/mcg.c ****     {
1767:../Sources/mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7585              		.loc 1 1767 0
 7586 0112 5A4A     		ldr	r2, .L594
 7587 0114 396A     		ldr	r1, [r7, #32]
 7588 0116 5A4B     		ldr	r3, .L594+4
 7589 0118 D150     		str	r1, [r2, r3]
1768:../Sources/mcg.c ****       return 7;
 7590              		.loc 1 1768 0
 7591 011a 0723     		mov	r3, #7
 7592 011c AAE0     		b	.L579
 7593              	.L584:
1769:../Sources/mcg.c ****     }            
1770:../Sources/mcg.c ****   } // if
1771:../Sources/mcg.c ****         
1772:../Sources/mcg.c **** // Set up autocal registers, must use floating point calculation
1773:../Sources/mcg.c ****   if (irc_select) 
 7594              		.loc 1 1773 0
 7595 011e 3B1C     		mov	r3, r7
 7596 0120 0F33     		add	r3, r3, #15
 7597 0122 1B78     		ldrb	r3, [r3]
 7598 0124 002B     		cmp	r3, #0
 7599 0126 1ED0     		beq	.L586
1774:../Sources/mcg.c ****     atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
 7600              		.loc 1 1774 0
 7601 0128 7869     		ldr	r0, [r7, #20]
 7602 012a FFF7FEFF 		bl	__aeabi_i2f
 7603 012e 041C     		add	r4, r0, #0
 7604 0130 B868     		ldr	r0, [r7, #8]
 7605 0132 FFF7FEFF 		bl	__aeabi_i2f
 7606 0136 031C     		add	r3, r0, #0
 7607 0138 201C     		add	r0, r4, #0
 7608 013a 191C     		add	r1, r3, #0
 7609 013c FFF7FEFF 		bl	__aeabi_fdiv
 7610 0140 031C     		add	r3, r0, #0
 7611 0142 181C     		add	r0, r3, #0
 7612 0144 5649     		ldr	r1, .L594+36
 7613 0146 FFF7FEFF 		bl	__aeabi_fmul
 7614 014a 031C     		add	r3, r0, #0
 7615 014c 181C     		add	r0, r3, #0
 7616 014e 5549     		ldr	r1, .L594+40
 7617 0150 FFF7FEFF 		bl	__aeabi_fmul
 7618 0154 031C     		add	r3, r0, #0
 7619 0156 3C1C     		mov	r4, r7
 7620 0158 2634     		add	r4, r4, #38
 7621 015a 181C     		add	r0, r3, #0
 7622 015c FFF7FEFF 		bl	__aeabi_f2uiz
 7623 0160 031C     		mov	r3, r0
 7624 0162 2380     		strh	r3, [r4]
 7625 0164 18E0     		b	.L587
 7626              	.L586:
1775:../Sources/mcg.c ****   else
1776:../Sources/mcg.c ****     atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
 7627              		.loc 1 1776 0
 7628 0166 7869     		ldr	r0, [r7, #20]
 7629 0168 FFF7FEFF 		bl	__aeabi_i2f
 7630 016c 041C     		add	r4, r0, #0
 7631 016e B868     		ldr	r0, [r7, #8]
 7632 0170 FFF7FEFF 		bl	__aeabi_i2f
 7633 0174 031C     		add	r3, r0, #0
 7634 0176 201C     		add	r0, r4, #0
 7635 0178 191C     		add	r1, r3, #0
 7636 017a FFF7FEFF 		bl	__aeabi_fdiv
 7637 017e 031C     		add	r3, r0, #0
 7638 0180 181C     		add	r0, r3, #0
 7639 0182 4749     		ldr	r1, .L594+36
 7640 0184 FFF7FEFF 		bl	__aeabi_fmul
 7641 0188 031C     		add	r3, r0, #0
 7642 018a 3C1C     		mov	r4, r7
 7643 018c 2634     		add	r4, r4, #38
 7644 018e 181C     		add	r0, r3, #0
 7645 0190 FFF7FEFF 		bl	__aeabi_f2uiz
 7646 0194 031C     		mov	r3, r0
 7647 0196 2380     		strh	r3, [r4]
 7648              	.L587:
1777:../Sources/mcg.c ****         
1778:../Sources/mcg.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
 7649              		.loc 1 1778 0
 7650 0198 434B     		ldr	r3, .L594+44
 7651 019a 3A1C     		mov	r2, r7
 7652 019c 2632     		add	r2, r2, #38
 7653 019e 1288     		ldrh	r2, [r2]
 7654 01a0 D2B2     		uxtb	r2, r2
 7655 01a2 DA72     		strb	r2, [r3, #11]
1779:../Sources/mcg.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 7656              		.loc 1 1779 0
 7657 01a4 404B     		ldr	r3, .L594+44
 7658 01a6 3A1C     		mov	r2, r7
 7659 01a8 2632     		add	r2, r2, #38
 7660 01aa 1288     		ldrh	r2, [r2]
 7661 01ac 120A     		lsr	r2, r2, #8
 7662 01ae 92B2     		uxth	r2, r2
 7663 01b0 D2B2     		uxtb	r2, r2
 7664 01b2 9A72     		strb	r2, [r3, #10]
1780:../Sources/mcg.c **** 
1781:../Sources/mcg.c **** // Enable autocal
1782:../Sources/mcg.c ****   MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
 7665              		.loc 1 1782 0
 7666 01b4 3C4B     		ldr	r3, .L594+44
 7667 01b6 3C4A     		ldr	r2, .L594+44
 7668 01b8 127A     		ldrb	r2, [r2, #8]
 7669 01ba D1B2     		uxtb	r1, r2
 7670 01bc 1F22     		mov	r2, #31
 7671 01be 0A40     		and	r2, r1
 7672 01c0 D2B2     		uxtb	r2, r2
 7673 01c2 1A72     		strb	r2, [r3, #8]
1783:../Sources/mcg.c ****   temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enabl
 7674              		.loc 1 1783 0
 7675 01c4 3B1C     		mov	r3, r7
 7676 01c6 0F33     		add	r3, r3, #15
 7677 01c8 1B78     		ldrb	r3, [r3]
 7678 01ca 9B01     		lsl	r3, r3, #6
 7679 01cc 8022     		mov	r2, #128
 7680 01ce 1343     		orr	r3, r2
 7681 01d0 BB61     		str	r3, [r7, #24]
1784:../Sources/mcg.c ****   MCG_SC |= temp_reg;
 7682              		.loc 1 1784 0
 7683 01d2 354B     		ldr	r3, .L594+44
 7684 01d4 344A     		ldr	r2, .L594+44
 7685 01d6 127A     		ldrb	r2, [r2, #8]
 7686 01d8 D2B2     		uxtb	r2, r2
 7687 01da D1B2     		uxtb	r1, r2
 7688 01dc BA69     		ldr	r2, [r7, #24]
 7689 01de D2B2     		uxtb	r2, r2
 7690 01e0 0A43     		orr	r2, r1
 7691 01e2 D2B2     		uxtb	r2, r2
 7692 01e4 D2B2     		uxtb	r2, r2
 7693 01e6 1A72     		strb	r2, [r3, #8]
1785:../Sources/mcg.c ****         
1786:../Sources/mcg.c ****   while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
 7694              		.loc 1 1786 0
 7695 01e8 C046     		mov	r8, r8
 7696              	.L588:
 7697              		.loc 1 1786 0 is_stmt 0 discriminator 1
 7698 01ea 2F4B     		ldr	r3, .L594+44
 7699 01ec 1B7A     		ldrb	r3, [r3, #8]
 7700 01ee DBB2     		uxtb	r3, r3
 7701 01f0 DBB2     		uxtb	r3, r3
 7702 01f2 5BB2     		sxtb	r3, r3
 7703 01f4 002B     		cmp	r3, #0
 7704 01f6 F8DB     		blt	.L588
1787:../Sources/mcg.c ****         
1788:../Sources/mcg.c ****   if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
 7705              		.loc 1 1788 0 is_stmt 1
 7706 01f8 2B4B     		ldr	r3, .L594+44
 7707 01fa 1B7A     		ldrb	r3, [r3, #8]
 7708 01fc DBB2     		uxtb	r3, r3
 7709 01fe 1A1C     		mov	r2, r3
 7710 0200 2023     		mov	r3, #32
 7711 0202 1340     		and	r3, r2
 7712 0204 05D0     		beq	.L589
1789:../Sources/mcg.c ****   {
1790:../Sources/mcg.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7713              		.loc 1 1790 0
 7714 0206 1D4A     		ldr	r2, .L594
 7715 0208 396A     		ldr	r1, [r7, #32]
 7716 020a 1D4B     		ldr	r3, .L594+4
 7717 020c D150     		str	r1, [r2, r3]
1791:../Sources/mcg.c ****     return 8;
 7718              		.loc 1 1791 0
 7719 020e 0823     		mov	r3, #8
 7720 0210 30E0     		b	.L579
 7721              	.L589:
1792:../Sources/mcg.c ****   } 
1793:../Sources/mcg.c ****   else 
1794:../Sources/mcg.c ****   {      
1795:../Sources/mcg.c ****     if (!irc_select)
 7722              		.loc 1 1795 0
 7723 0212 3B1C     		mov	r3, r7
 7724 0214 0F33     		add	r3, r3, #15
 7725 0216 1B78     		ldrb	r3, [r3]
 7726 0218 002B     		cmp	r3, #0
 7727 021a 0FD1     		bne	.L590
1796:../Sources/mcg.c ****     {
1797:../Sources/mcg.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 7728              		.loc 1 1797 0
 7729 021c 224B     		ldr	r3, .L594+44
 7730 021e 9B78     		ldrb	r3, [r3, #2]
 7731 0220 DBB2     		uxtb	r3, r3
 7732 0222 FF2B     		cmp	r3, #255
 7733 0224 04D0     		beq	.L591
 7734              		.loc 1 1797 0 is_stmt 0 discriminator 1
 7735 0226 204B     		ldr	r3, .L594+44
 7736 0228 9B78     		ldrb	r3, [r3, #2]
 7737 022a DBB2     		uxtb	r3, r3
 7738 022c 002B     		cmp	r3, #0
 7739 022e 1CD1     		bne	.L592
 7740              	.L591:
1798:../Sources/mcg.c ****       {
1799:../Sources/mcg.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7741              		.loc 1 1799 0 is_stmt 1
 7742 0230 124A     		ldr	r2, .L594
 7743 0232 396A     		ldr	r1, [r7, #32]
 7744 0234 124B     		ldr	r3, .L594+4
 7745 0236 D150     		str	r1, [r2, r3]
1800:../Sources/mcg.c ****         return 9;
 7746              		.loc 1 1800 0
 7747 0238 0923     		mov	r3, #9
 7748 023a 1BE0     		b	.L579
 7749              	.L590:
1801:../Sources/mcg.c ****       }
1802:../Sources/mcg.c ****     }
1803:../Sources/mcg.c ****     else
1804:../Sources/mcg.c ****     {
1805:../Sources/mcg.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 7750              		.loc 1 1805 0
 7751 023c 1A4B     		ldr	r3, .L594+44
 7752 023e DB78     		ldrb	r3, [r3, #3]
 7753 0240 DBB2     		uxtb	r3, r3
 7754 0242 1A1C     		mov	r2, r3
 7755 0244 1E23     		mov	r3, #30
 7756 0246 1340     		and	r3, r2
 7757 0248 5B08     		lsr	r3, r3, #1
 7758 024a 0F2B     		cmp	r3, #15
 7759 024c 07D0     		beq	.L593
1806:../Sources/mcg.c ****           (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
 7760              		.loc 1 1806 0 discriminator 1
 7761 024e 164B     		ldr	r3, .L594+44
 7762 0250 DB78     		ldrb	r3, [r3, #3]
 7763 0252 DBB2     		uxtb	r3, r3
 7764 0254 1A1C     		mov	r2, r3
 7765 0256 1E23     		mov	r3, #30
 7766 0258 1340     		and	r3, r2
 7767 025a 5B08     		lsr	r3, r3, #1
1805:../Sources/mcg.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 7768              		.loc 1 1805 0 discriminator 1
 7769 025c 05D1     		bne	.L592
 7770              	.L593:
1807:../Sources/mcg.c ****       {
1808:../Sources/mcg.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7771              		.loc 1 1808 0
 7772 025e 074A     		ldr	r2, .L594
 7773 0260 396A     		ldr	r1, [r7, #32]
 7774 0262 074B     		ldr	r3, .L594+4
 7775 0264 D150     		str	r1, [r2, r3]
1809:../Sources/mcg.c ****         return 10;
 7776              		.loc 1 1809 0
 7777 0266 0A23     		mov	r3, #10
 7778 0268 04E0     		b	.L579
 7779              	.L592:
1810:../Sources/mcg.c ****       }
1811:../Sources/mcg.c ****     }
1812:../Sources/mcg.c ****   }
1813:../Sources/mcg.c ****   SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 7780              		.loc 1 1813 0
 7781 026a 044A     		ldr	r2, .L594
 7782 026c 396A     		ldr	r1, [r7, #32]
 7783 026e 044B     		ldr	r3, .L594+4
 7784 0270 D150     		str	r1, [r2, r3]
1814:../Sources/mcg.c ****   return 0;
 7785              		.loc 1 1814 0
 7786 0272 0023     		mov	r3, #0
 7787              	.L579:
1815:../Sources/mcg.c **** }// atc
 7788              		.loc 1 1815 0
 7789 0274 181C     		mov	r0, r3
 7790 0276 BD46     		mov	sp, r7
 7791 0278 0BB0     		add	sp, sp, #44
 7792              		@ sp needed for prologue
 7793 027a 90BD     		pop	{r4, r7, pc}
 7794              	.L595:
 7795              		.align	2
 7796              	.L594:
 7797 027c 00700440 		.word	1074032640
 7798 0280 44100000 		.word	4164
 7799 0284 0024F400 		.word	16000000
 7800 0288 FFFFF8FF 		.word	-458753
 7801 028c FF117A00 		.word	7999999
 7802 0290 117A0000 		.word	31249
 7803 0294 96980000 		.word	39062
 7804 0298 BFC62D00 		.word	2999999
 7805 029c 404B4C00 		.word	5000000
 7806 02a0 0000A841 		.word	1101529088
 7807 02a4 00000043 		.word	1124073472
 7808 02a8 00400640 		.word	1074151424
 7809              		.cfi_endproc
 7810              	.LFE24:
 7812              		.section	.text.fll_freq,"ax",%progbits
 7813              		.align	2
 7814              		.global	fll_freq
 7815              		.code	16
 7816              		.thumb_func
 7818              	fll_freq:
 7819              	.LFB25:
1816:../Sources/mcg.c **** 
1817:../Sources/mcg.c **** 
1818:../Sources/mcg.c **** 
1819:../Sources/mcg.c **** 
1820:../Sources/mcg.c **** int fll_freq(int fll_ref)
1821:../Sources/mcg.c **** {
 7820              		.loc 1 1821 0
 7821              		.cfi_startproc
 7822 0000 80B5     		push	{r7, lr}
 7823              	.LCFI75:
 7824              		.cfi_def_cfa_offset 8
 7825              		.cfi_offset 7, -8
 7826              		.cfi_offset 14, -4
 7827 0002 84B0     		sub	sp, sp, #16
 7828              	.LCFI76:
 7829              		.cfi_def_cfa_offset 24
 7830 0004 00AF     		add	r7, sp, #0
 7831              	.LCFI77:
 7832              		.cfi_def_cfa_register 7
 7833 0006 7860     		str	r0, [r7, #4]
1822:../Sources/mcg.c ****   int fll_freq_hz;
1823:../Sources/mcg.c ****   
1824:../Sources/mcg.c ****   // Check that only allowed ranges have been selected
1825:../Sources/mcg.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 7834              		.loc 1 1825 0
 7835 0008 684B     		ldr	r3, .L634
 7836 000a DB78     		ldrb	r3, [r3, #3]
 7837 000c DBB2     		uxtb	r3, r3
 7838 000e 1A1C     		mov	r2, r3
 7839 0010 6023     		mov	r3, #96
 7840 0012 1340     		and	r3, r2
 7841 0014 5B09     		lsr	r3, r3, #5
 7842 0016 012B     		cmp	r3, #1
 7843 0018 01D9     		bls	.L597
1826:../Sources/mcg.c ****   {
1827:../Sources/mcg.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
 7844              		.loc 1 1827 0
 7845 001a 3B23     		mov	r3, #59
 7846 001c C2E0     		b	.L598
 7847              	.L597:
1828:../Sources/mcg.c ****   }
1829:../Sources/mcg.c ****   
1830:../Sources/mcg.c ****   if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
 7848              		.loc 1 1830 0
 7849 001e 634B     		ldr	r3, .L634
 7850 0020 DB78     		ldrb	r3, [r3, #3]
 7851 0022 DBB2     		uxtb	r3, r3
 7852 0024 DBB2     		uxtb	r3, r3
 7853 0026 5BB2     		sxtb	r3, r3
 7854 0028 002B     		cmp	r3, #0
 7855 002a 54DA     		bge	.L599
1831:../Sources/mcg.c ****   {
1832:../Sources/mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 7856              		.loc 1 1832 0
 7857 002c 5F4B     		ldr	r3, .L634
 7858 002e DB78     		ldrb	r3, [r3, #3]
 7859 0030 DBB2     		uxtb	r3, r3
 7860 0032 1A1C     		mov	r2, r3
 7861 0034 6023     		mov	r3, #96
 7862 0036 1340     		and	r3, r2
 7863 0038 5B09     		lsr	r3, r3, #5
 7864 003a 012B     		cmp	r3, #1
 7865 003c 17D0     		beq	.L602
 7866 003e 04D3     		bcc	.L601
 7867 0040 022B     		cmp	r3, #2
 7868 0042 26D0     		beq	.L603
 7869 0044 032B     		cmp	r3, #3
 7870 0046 35D0     		beq	.L604
 7871 0048 ABE0     		b	.L613
 7872              	.L601:
1833:../Sources/mcg.c ****     {
1834:../Sources/mcg.c ****     case 0:
1835:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 732);
 7873              		.loc 1 1835 0
 7874 004a 7B68     		ldr	r3, [r7, #4]
 7875 004c B722     		mov	r2, #183
 7876 004e 9200     		lsl	r2, r2, #2
 7877 0050 5343     		mul	r3, r2
 7878 0052 FB60     		str	r3, [r7, #12]
1836:../Sources/mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 7879              		.loc 1 1836 0
 7880 0054 FA68     		ldr	r2, [r7, #12]
 7881 0056 564B     		ldr	r3, .L634+4
 7882 0058 9A42     		cmp	r2, r3
 7883 005a 01DC     		bgt	.L605
 7884              		.loc 1 1836 0 is_stmt 0 discriminator 1
 7885 005c 3323     		mov	r3, #51
 7886 005e A1E0     		b	.L598
 7887              	.L605:
1837:../Sources/mcg.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
 7888              		.loc 1 1837 0 is_stmt 1
 7889 0060 FA68     		ldr	r2, [r7, #12]
 7890 0062 544B     		ldr	r3, .L634+8
 7891 0064 9A42     		cmp	r2, r3
 7892 0066 00DC     		bgt	.LCB7385
 7893 0068 8CE0     		b	.L626	@long jump
 7894              	.LCB7385:
 7895              		.loc 1 1837 0 is_stmt 0 discriminator 1
 7896 006a 3423     		mov	r3, #52
 7897 006c 9AE0     		b	.L598
 7898              	.L602:
1838:../Sources/mcg.c ****       break;
1839:../Sources/mcg.c ****     case 1:
1840:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 1464);
 7899              		.loc 1 1840 0 is_stmt 1
 7900 006e 7B68     		ldr	r3, [r7, #4]
 7901 0070 B722     		mov	r2, #183
 7902 0072 D200     		lsl	r2, r2, #3
 7903 0074 5343     		mul	r3, r2
 7904 0076 FB60     		str	r3, [r7, #12]
1841:../Sources/mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 7905              		.loc 1 1841 0
 7906 0078 FA68     		ldr	r2, [r7, #12]
 7907 007a 4F4B     		ldr	r3, .L634+12
 7908 007c 9A42     		cmp	r2, r3
 7909 007e 01DC     		bgt	.L607
 7910              		.loc 1 1841 0 is_stmt 0 discriminator 1
 7911 0080 3523     		mov	r3, #53
 7912 0082 8FE0     		b	.L598
 7913              	.L607:
1842:../Sources/mcg.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 7914              		.loc 1 1842 0 is_stmt 1
 7915 0084 FA68     		ldr	r2, [r7, #12]
 7916 0086 4D4B     		ldr	r3, .L634+16
 7917 0088 9A42     		cmp	r2, r3
 7918 008a 00DC     		bgt	.LCB7408
 7919 008c 7CE0     		b	.L627	@long jump
 7920              	.LCB7408:
 7921              		.loc 1 1842 0 is_stmt 0 discriminator 1
 7922 008e 3623     		mov	r3, #54
 7923 0090 88E0     		b	.L598
 7924              	.L603:
1843:../Sources/mcg.c ****       break;
1844:../Sources/mcg.c ****     case 2:
1845:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 2197);
 7925              		.loc 1 1845 0 is_stmt 1
 7926 0092 7B68     		ldr	r3, [r7, #4]
 7927 0094 4A4A     		ldr	r2, .L634+20
 7928 0096 5343     		mul	r3, r2
 7929 0098 FB60     		str	r3, [r7, #12]
1846:../Sources/mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 7930              		.loc 1 1846 0
 7931 009a FA68     		ldr	r2, [r7, #12]
 7932 009c 494B     		ldr	r3, .L634+24
 7933 009e 9A42     		cmp	r2, r3
 7934 00a0 01DC     		bgt	.L609
 7935              		.loc 1 1846 0 is_stmt 0 discriminator 1
 7936 00a2 3723     		mov	r3, #55
 7937 00a4 7EE0     		b	.L598
 7938              	.L609:
1847:../Sources/mcg.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 7939              		.loc 1 1847 0 is_stmt 1
 7940 00a6 FA68     		ldr	r2, [r7, #12]
 7941 00a8 474B     		ldr	r3, .L634+28
 7942 00aa 9A42     		cmp	r2, r3
 7943 00ac 00DC     		bgt	.LCB7430
 7944 00ae 6DE0     		b	.L628	@long jump
 7945              	.LCB7430:
 7946              		.loc 1 1847 0 is_stmt 0 discriminator 1
 7947 00b0 3823     		mov	r3, #56
 7948 00b2 77E0     		b	.L598
 7949              	.L604:
1848:../Sources/mcg.c ****       break;
1849:../Sources/mcg.c ****     case 3:
1850:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 2929);
 7950              		.loc 1 1850 0 is_stmt 1
 7951 00b4 7B68     		ldr	r3, [r7, #4]
 7952 00b6 454A     		ldr	r2, .L634+32
 7953 00b8 5343     		mul	r3, r2
 7954 00ba FB60     		str	r3, [r7, #12]
1851:../Sources/mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 7955              		.loc 1 1851 0
 7956 00bc FA68     		ldr	r2, [r7, #12]
 7957 00be 444B     		ldr	r3, .L634+36
 7958 00c0 9A42     		cmp	r2, r3
 7959 00c2 01DC     		bgt	.L611
 7960              		.loc 1 1851 0 is_stmt 0 discriminator 1
 7961 00c4 3923     		mov	r3, #57
 7962 00c6 6DE0     		b	.L598
 7963              	.L611:
1852:../Sources/mcg.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 7964              		.loc 1 1852 0 is_stmt 1
 7965 00c8 FA68     		ldr	r2, [r7, #12]
 7966 00ca 424B     		ldr	r3, .L634+40
 7967 00cc 9A42     		cmp	r2, r3
 7968 00ce 00DC     		bgt	.LCB7452
 7969 00d0 5EE0     		b	.L629	@long jump
 7970              	.LCB7452:
 7971              		.loc 1 1852 0 is_stmt 0 discriminator 1
 7972 00d2 3A23     		mov	r3, #58
 7973 00d4 66E0     		b	.L598
 7974              	.L599:
1853:../Sources/mcg.c ****       break;
1854:../Sources/mcg.c ****     }
1855:../Sources/mcg.c ****   }
1856:../Sources/mcg.c ****   else // if DMX32 = 0
1857:../Sources/mcg.c ****   {
1858:../Sources/mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 7975              		.loc 1 1858 0 is_stmt 1
 7976 00d6 354B     		ldr	r3, .L634
 7977 00d8 DB78     		ldrb	r3, [r3, #3]
 7978 00da DBB2     		uxtb	r3, r3
 7979 00dc 1A1C     		mov	r2, r3
 7980 00de 6023     		mov	r3, #96
 7981 00e0 1340     		and	r3, r2
 7982 00e2 5B09     		lsr	r3, r3, #5
 7983 00e4 012B     		cmp	r3, #1
 7984 00e6 17D0     		beq	.L615
 7985 00e8 04D3     		bcc	.L614
 7986 00ea 022B     		cmp	r3, #2
 7987 00ec 26D0     		beq	.L616
 7988 00ee 032B     		cmp	r3, #3
 7989 00f0 36D0     		beq	.L617
 7990 00f2 56E0     		b	.L613
 7991              	.L614:
1859:../Sources/mcg.c ****     {
1860:../Sources/mcg.c ****     case 0:
1861:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 640);
 7992              		.loc 1 1861 0
 7993 00f4 7A68     		ldr	r2, [r7, #4]
 7994 00f6 131C     		mov	r3, r2
 7995 00f8 9B00     		lsl	r3, r3, #2
 7996 00fa 9B18     		add	r3, r3, r2
 7997 00fc DB01     		lsl	r3, r3, #7
 7998 00fe FB60     		str	r3, [r7, #12]
1862:../Sources/mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 7999              		.loc 1 1862 0
 8000 0100 FA68     		ldr	r2, [r7, #12]
 8001 0102 2B4B     		ldr	r3, .L634+4
 8002 0104 9A42     		cmp	r2, r3
 8003 0106 01DC     		bgt	.L618
 8004              		.loc 1 1862 0 is_stmt 0 discriminator 1
 8005 0108 3323     		mov	r3, #51
 8006 010a 4BE0     		b	.L598
 8007              	.L618:
1863:../Sources/mcg.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
 8008              		.loc 1 1863 0 is_stmt 1
 8009 010c FA68     		ldr	r2, [r7, #12]
 8010 010e 294B     		ldr	r3, .L634+8
 8011 0110 9A42     		cmp	r2, r3
 8012 0112 3FDD     		ble	.L630
 8013              		.loc 1 1863 0 is_stmt 0 discriminator 1
 8014 0114 3423     		mov	r3, #52
 8015 0116 45E0     		b	.L598
 8016              	.L615:
1864:../Sources/mcg.c ****       break;
1865:../Sources/mcg.c ****     case 1:
1866:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 1280);
 8017              		.loc 1 1866 0 is_stmt 1
 8018 0118 7A68     		ldr	r2, [r7, #4]
 8019 011a 131C     		mov	r3, r2
 8020 011c 9B00     		lsl	r3, r3, #2
 8021 011e 9B18     		add	r3, r3, r2
 8022 0120 1B02     		lsl	r3, r3, #8
 8023 0122 FB60     		str	r3, [r7, #12]
1867:../Sources/mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 8024              		.loc 1 1867 0
 8025 0124 FA68     		ldr	r2, [r7, #12]
 8026 0126 244B     		ldr	r3, .L634+12
 8027 0128 9A42     		cmp	r2, r3
 8028 012a 01DC     		bgt	.L620
 8029              		.loc 1 1867 0 is_stmt 0 discriminator 1
 8030 012c 3523     		mov	r3, #53
 8031 012e 39E0     		b	.L598
 8032              	.L620:
1868:../Sources/mcg.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 8033              		.loc 1 1868 0 is_stmt 1
 8034 0130 FA68     		ldr	r2, [r7, #12]
 8035 0132 224B     		ldr	r3, .L634+16
 8036 0134 9A42     		cmp	r2, r3
 8037 0136 2FDD     		ble	.L631
 8038              		.loc 1 1868 0 is_stmt 0 discriminator 1
 8039 0138 3623     		mov	r3, #54
 8040 013a 33E0     		b	.L598
 8041              	.L616:
1869:../Sources/mcg.c ****       break;
1870:../Sources/mcg.c ****     case 2:
1871:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 1920);
 8042              		.loc 1 1871 0 is_stmt 1
 8043 013c 7A68     		ldr	r2, [r7, #4]
 8044 013e 131C     		mov	r3, r2
 8045 0140 1B01     		lsl	r3, r3, #4
 8046 0142 9B1A     		sub	r3, r3, r2
 8047 0144 DB01     		lsl	r3, r3, #7
 8048 0146 FB60     		str	r3, [r7, #12]
1872:../Sources/mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 8049              		.loc 1 1872 0
 8050 0148 FA68     		ldr	r2, [r7, #12]
 8051 014a 1E4B     		ldr	r3, .L634+24
 8052 014c 9A42     		cmp	r2, r3
 8053 014e 01DC     		bgt	.L622
 8054              		.loc 1 1872 0 is_stmt 0 discriminator 1
 8055 0150 3723     		mov	r3, #55
 8056 0152 27E0     		b	.L598
 8057              	.L622:
1873:../Sources/mcg.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 8058              		.loc 1 1873 0 is_stmt 1
 8059 0154 FA68     		ldr	r2, [r7, #12]
 8060 0156 1C4B     		ldr	r3, .L634+28
 8061 0158 9A42     		cmp	r2, r3
 8062 015a 1FDD     		ble	.L632
 8063              		.loc 1 1873 0 is_stmt 0 discriminator 1
 8064 015c 3823     		mov	r3, #56
 8065 015e 21E0     		b	.L598
 8066              	.L617:
1874:../Sources/mcg.c ****       break;
1875:../Sources/mcg.c ****     case 3:
1876:../Sources/mcg.c ****       fll_freq_hz = (fll_ref * 2560);
 8067              		.loc 1 1876 0 is_stmt 1
 8068 0160 7A68     		ldr	r2, [r7, #4]
 8069 0162 131C     		mov	r3, r2
 8070 0164 9B00     		lsl	r3, r3, #2
 8071 0166 9B18     		add	r3, r3, r2
 8072 0168 5B02     		lsl	r3, r3, #9
 8073 016a FB60     		str	r3, [r7, #12]
1877:../Sources/mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 8074              		.loc 1 1877 0
 8075 016c FA68     		ldr	r2, [r7, #12]
 8076 016e 184B     		ldr	r3, .L634+36
 8077 0170 9A42     		cmp	r2, r3
 8078 0172 01DC     		bgt	.L624
 8079              		.loc 1 1877 0 is_stmt 0 discriminator 1
 8080 0174 3923     		mov	r3, #57
 8081 0176 15E0     		b	.L598
 8082              	.L624:
1878:../Sources/mcg.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 8083              		.loc 1 1878 0 is_stmt 1
 8084 0178 FA68     		ldr	r2, [r7, #12]
 8085 017a 164B     		ldr	r3, .L634+40
 8086 017c 9A42     		cmp	r2, r3
 8087 017e 0FDD     		ble	.L633
 8088              		.loc 1 1878 0 is_stmt 0 discriminator 1
 8089 0180 3A23     		mov	r3, #58
 8090 0182 0FE0     		b	.L598
 8091              	.L626:
1838:../Sources/mcg.c ****       break;
 8092              		.loc 1 1838 0 is_stmt 1
 8093 0184 C046     		mov	r8, r8
 8094 0186 0CE0     		b	.L613
 8095              	.L627:
1843:../Sources/mcg.c ****       break;
 8096              		.loc 1 1843 0
 8097 0188 C046     		mov	r8, r8
 8098 018a 0AE0     		b	.L613
 8099              	.L628:
1848:../Sources/mcg.c ****       break;
 8100              		.loc 1 1848 0
 8101 018c C046     		mov	r8, r8
 8102 018e 08E0     		b	.L613
 8103              	.L629:
1853:../Sources/mcg.c ****       break;
 8104              		.loc 1 1853 0
 8105 0190 C046     		mov	r8, r8
 8106 0192 06E0     		b	.L613
 8107              	.L630:
1864:../Sources/mcg.c ****       break;
 8108              		.loc 1 1864 0
 8109 0194 C046     		mov	r8, r8
 8110 0196 04E0     		b	.L613
 8111              	.L631:
1869:../Sources/mcg.c ****       break;
 8112              		.loc 1 1869 0
 8113 0198 C046     		mov	r8, r8
 8114 019a 02E0     		b	.L613
 8115              	.L632:
1874:../Sources/mcg.c ****       break;
 8116              		.loc 1 1874 0
 8117 019c C046     		mov	r8, r8
 8118 019e 00E0     		b	.L613
 8119              	.L633:
1879:../Sources/mcg.c ****       break;
 8120              		.loc 1 1879 0
 8121 01a0 C046     		mov	r8, r8
 8122              	.L613:
1880:../Sources/mcg.c ****     }
1881:../Sources/mcg.c ****   }    
1882:../Sources/mcg.c ****   return fll_freq_hz;
 8123              		.loc 1 1882 0
 8124 01a2 FB68     		ldr	r3, [r7, #12]
 8125              	.L598:
1883:../Sources/mcg.c **** } // fll_freq
 8126              		.loc 1 1883 0
 8127 01a4 181C     		mov	r0, r3
 8128 01a6 BD46     		mov	sp, r7
 8129 01a8 04B0     		add	sp, sp, #16
 8130              		@ sp needed for prologue
 8131 01aa 80BD     		pop	{r7, pc}
 8132              	.L635:
 8133              		.align	2
 8134              	.L634:
 8135 01ac 00400640 		.word	1074151424
 8136 01b0 FF2C3101 		.word	19999999
 8137 01b4 40787D01 		.word	25000000
 8138 01b8 FF596202 		.word	39999999
 8139 01bc 80F0FA02 		.word	50000000
 8140 01c0 95080000 		.word	2197
 8141 01c4 FF869303 		.word	59999999
 8142 01c8 C0687804 		.word	75000000
 8143 01cc 710B0000 		.word	2929
 8144 01d0 FFB3C404 		.word	79999999
 8145 01d4 00E1F505 		.word	100000000
 8146              		.cfi_endproc
 8147              	.LFE25:
 8149              		.section	.text.what_mcg_mode,"ax",%progbits
 8150              		.align	2
 8151              		.global	what_mcg_mode
 8152              		.code	16
 8153              		.thumb_func
 8155              	what_mcg_mode:
 8156              	.LFB26:
1884:../Sources/mcg.c **** 
1885:../Sources/mcg.c **** 
1886:../Sources/mcg.c **** unsigned char what_mcg_mode(void)
1887:../Sources/mcg.c **** {
 8157              		.loc 1 1887 0
 8158              		.cfi_startproc
 8159 0000 80B5     		push	{r7, lr}
 8160              	.LCFI78:
 8161              		.cfi_def_cfa_offset 8
 8162              		.cfi_offset 7, -8
 8163              		.cfi_offset 14, -4
 8164 0002 00AF     		add	r7, sp, #0
 8165              	.LCFI79:
 8166              		.cfi_def_cfa_register 7
1888:../Sources/mcg.c ****   // check if in FEI mode
1889:../Sources/mcg.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 8167              		.loc 1 1889 0
 8168 0004 724B     		ldr	r3, .L646
 8169 0006 9B79     		ldrb	r3, [r3, #6]
 8170 0008 DBB2     		uxtb	r3, r3
 8171 000a 1A1C     		mov	r2, r3
 8172 000c 0C23     		mov	r3, #12
 8173 000e 1340     		and	r3, r2
 8174 0010 9B08     		lsr	r3, r3, #2
 8175 0012 0FD1     		bne	.L637
1890:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 8176              		.loc 1 1890 0 discriminator 1
 8177 0014 6E4B     		ldr	r3, .L646
 8178 0016 9B79     		ldrb	r3, [r3, #6]
 8179 0018 DBB2     		uxtb	r3, r3
 8180 001a 1A1C     		mov	r2, r3
 8181 001c 1023     		mov	r3, #16
 8182 001e 1340     		and	r3, r2
1889:../Sources/mcg.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 8183              		.loc 1 1889 0 discriminator 1
 8184 0020 08D0     		beq	.L637
1891:../Sources/mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has sele
 8185              		.loc 1 1891 0
 8186 0022 6B4B     		ldr	r3, .L646
 8187 0024 9B79     		ldrb	r3, [r3, #6]
 8188 0026 DBB2     		uxtb	r3, r3
 8189 0028 1A1C     		mov	r2, r3
 8190 002a 2023     		mov	r3, #32
 8191 002c 1340     		and	r3, r2
1890:../Sources/mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 8192              		.loc 1 1890 0
 8193 002e 01D1     		bne	.L637
1892:../Sources/mcg.c ****   {
1893:../Sources/mcg.c ****     return FEI;                                                          // return FEI code
 8194              		.loc 1 1893 0
 8195 0030 0323     		mov	r3, #3
 8196 0032 CAE0     		b	.L638
 8197              	.L637:
1894:../Sources/mcg.c ****   }
1895:../Sources/mcg.c ****   // Check MCG is in PEE mode
1896:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 8198              		.loc 1 1896 0
 8199 0034 664B     		ldr	r3, .L646
 8200 0036 9B79     		ldrb	r3, [r3, #6]
 8201 0038 DBB2     		uxtb	r3, r3
 8202 003a 1A1C     		mov	r2, r3
 8203 003c 0C23     		mov	r3, #12
 8204 003e 1340     		and	r3, r2
 8205 0040 9B08     		lsr	r3, r3, #2
 8206 0042 032B     		cmp	r3, #3
 8207 0044 0FD1     		bne	.L639
1897:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8208              		.loc 1 1897 0 discriminator 1
 8209 0046 624B     		ldr	r3, .L646
 8210 0048 9B79     		ldrb	r3, [r3, #6]
 8211 004a DBB2     		uxtb	r3, r3
 8212 004c 1A1C     		mov	r2, r3
 8213 004e 1023     		mov	r3, #16
 8214 0050 1340     		and	r3, r2
1896:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 8215              		.loc 1 1896 0 discriminator 1
 8216 0052 08D1     		bne	.L639
1898:../Sources/mcg.c ****           (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has sele
 8217              		.loc 1 1898 0
 8218 0054 5E4B     		ldr	r3, .L646
 8219 0056 9B79     		ldrb	r3, [r3, #6]
 8220 0058 DBB2     		uxtb	r3, r3
 8221 005a 1A1C     		mov	r2, r3
 8222 005c 2023     		mov	r3, #32
 8223 005e 1340     		and	r3, r2
1897:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8224              		.loc 1 1897 0
 8225 0060 01D0     		beq	.L639
1899:../Sources/mcg.c ****   {
1900:../Sources/mcg.c ****     return PEE;                                                          // return PEE code
 8226              		.loc 1 1900 0
 8227 0062 0823     		mov	r3, #8
 8228 0064 B1E0     		b	.L638
 8229              	.L639:
1901:../Sources/mcg.c ****   }
1902:../Sources/mcg.c ****   // Check MCG is in PBE mode
1903:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 8230              		.loc 1 1903 0
 8231 0066 5A4B     		ldr	r3, .L646
 8232 0068 9B79     		ldrb	r3, [r3, #6]
 8233 006a DBB2     		uxtb	r3, r3
 8234 006c 1A1C     		mov	r2, r3
 8235 006e 0C23     		mov	r3, #12
 8236 0070 1340     		and	r3, r2
 8237 0072 9B08     		lsr	r3, r3, #2
 8238 0074 022B     		cmp	r3, #2
 8239 0076 16D1     		bne	.L640
1904:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8240              		.loc 1 1904 0 discriminator 1
 8241 0078 554B     		ldr	r3, .L646
 8242 007a 9B79     		ldrb	r3, [r3, #6]
 8243 007c DBB2     		uxtb	r3, r3
 8244 007e 1A1C     		mov	r2, r3
 8245 0080 1023     		mov	r3, #16
 8246 0082 1340     		and	r3, r2
1903:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 8247              		.loc 1 1903 0 discriminator 1
 8248 0084 0FD1     		bne	.L640
1905:../Sources/mcg.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 8249              		.loc 1 1905 0
 8250 0086 524B     		ldr	r3, .L646
 8251 0088 9B79     		ldrb	r3, [r3, #6]
 8252 008a DBB2     		uxtb	r3, r3
 8253 008c 1A1C     		mov	r2, r3
 8254 008e 2023     		mov	r3, #32
 8255 0090 1340     		and	r3, r2
1904:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8256              		.loc 1 1904 0
 8257 0092 08D0     		beq	.L640
1906:../Sources/mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 8258              		.loc 1 1906 0
 8259 0094 4E4B     		ldr	r3, .L646
 8260 0096 5B78     		ldrb	r3, [r3, #1]
 8261 0098 DBB2     		uxtb	r3, r3
 8262 009a 1A1C     		mov	r2, r3
 8263 009c 0223     		mov	r3, #2
 8264 009e 1340     		and	r3, r2
1905:../Sources/mcg.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 8265              		.loc 1 1905 0
 8266 00a0 01D1     		bne	.L640
1907:../Sources/mcg.c ****   {
1908:../Sources/mcg.c ****     return PBE;                                                          // return PBE code
 8267              		.loc 1 1908 0
 8268 00a2 0723     		mov	r3, #7
 8269 00a4 91E0     		b	.L638
 8270              	.L640:
1909:../Sources/mcg.c ****   }
1910:../Sources/mcg.c ****   // Check MCG is in FBE mode
1911:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 8271              		.loc 1 1911 0
 8272 00a6 4A4B     		ldr	r3, .L646
 8273 00a8 9B79     		ldrb	r3, [r3, #6]
 8274 00aa DBB2     		uxtb	r3, r3
 8275 00ac 1A1C     		mov	r2, r3
 8276 00ae 0C23     		mov	r3, #12
 8277 00b0 1340     		and	r3, r2
 8278 00b2 9B08     		lsr	r3, r3, #2
 8279 00b4 022B     		cmp	r3, #2
 8280 00b6 16D1     		bne	.L641
1912:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8281              		.loc 1 1912 0 discriminator 1
 8282 00b8 454B     		ldr	r3, .L646
 8283 00ba 9B79     		ldrb	r3, [r3, #6]
 8284 00bc DBB2     		uxtb	r3, r3
 8285 00be 1A1C     		mov	r2, r3
 8286 00c0 1023     		mov	r3, #16
 8287 00c2 1340     		and	r3, r2
1911:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 8288              		.loc 1 1911 0 discriminator 1
 8289 00c4 0FD1     		bne	.L641
1913:../Sources/mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 8290              		.loc 1 1913 0
 8291 00c6 424B     		ldr	r3, .L646
 8292 00c8 9B79     		ldrb	r3, [r3, #6]
 8293 00ca DBB2     		uxtb	r3, r3
 8294 00cc 1A1C     		mov	r2, r3
 8295 00ce 2023     		mov	r3, #32
 8296 00d0 1340     		and	r3, r2
1912:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8297              		.loc 1 1912 0
 8298 00d2 08D1     		bne	.L641
1914:../Sources/mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 8299              		.loc 1 1914 0
 8300 00d4 3E4B     		ldr	r3, .L646
 8301 00d6 5B78     		ldrb	r3, [r3, #1]
 8302 00d8 DBB2     		uxtb	r3, r3
 8303 00da 1A1C     		mov	r2, r3
 8304 00dc 0223     		mov	r3, #2
 8305 00de 1340     		and	r3, r2
1913:../Sources/mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 8306              		.loc 1 1913 0
 8307 00e0 01D1     		bne	.L641
1915:../Sources/mcg.c ****   {
1916:../Sources/mcg.c ****     return FBE;                                                          // return FBE code
 8308              		.loc 1 1916 0
 8309 00e2 0523     		mov	r3, #5
 8310 00e4 71E0     		b	.L638
 8311              	.L641:
1917:../Sources/mcg.c ****   }
1918:../Sources/mcg.c ****   // Check MCG is in BLPE mode
1919:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 8312              		.loc 1 1919 0
 8313 00e6 3A4B     		ldr	r3, .L646
 8314 00e8 9B79     		ldrb	r3, [r3, #6]
 8315 00ea DBB2     		uxtb	r3, r3
 8316 00ec 1A1C     		mov	r2, r3
 8317 00ee 0C23     		mov	r3, #12
 8318 00f0 1340     		and	r3, r2
 8319 00f2 9B08     		lsr	r3, r3, #2
 8320 00f4 022B     		cmp	r3, #2
 8321 00f6 0FD1     		bne	.L642
1920:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8322              		.loc 1 1920 0 discriminator 1
 8323 00f8 354B     		ldr	r3, .L646
 8324 00fa 9B79     		ldrb	r3, [r3, #6]
 8325 00fc DBB2     		uxtb	r3, r3
 8326 00fe 1A1C     		mov	r2, r3
 8327 0100 1023     		mov	r3, #16
 8328 0102 1340     		and	r3, r2
1919:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 8329              		.loc 1 1919 0 discriminator 1
 8330 0104 08D1     		bne	.L642
1921:../Sources/mcg.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is
 8331              		.loc 1 1921 0
 8332 0106 324B     		ldr	r3, .L646
 8333 0108 5B78     		ldrb	r3, [r3, #1]
 8334 010a DBB2     		uxtb	r3, r3
 8335 010c 1A1C     		mov	r2, r3
 8336 010e 0223     		mov	r3, #2
 8337 0110 1340     		and	r3, r2
1920:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8338              		.loc 1 1920 0
 8339 0112 01D0     		beq	.L642
1922:../Sources/mcg.c ****   {
1923:../Sources/mcg.c ****     return BLPE;                                                         // return BLPE code
 8340              		.loc 1 1923 0
 8341 0114 0623     		mov	r3, #6
 8342 0116 58E0     		b	.L638
 8343              	.L642:
1924:../Sources/mcg.c ****   }
1925:../Sources/mcg.c ****   // check if in BLPI mode
1926:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 8344              		.loc 1 1926 0
 8345 0118 2D4B     		ldr	r3, .L646
 8346 011a 9B79     		ldrb	r3, [r3, #6]
 8347 011c DBB2     		uxtb	r3, r3
 8348 011e 1A1C     		mov	r2, r3
 8349 0120 0C23     		mov	r3, #12
 8350 0122 1340     		and	r3, r2
 8351 0124 9B08     		lsr	r3, r3, #2
 8352 0126 012B     		cmp	r3, #1
 8353 0128 16D1     		bne	.L643
1927:../Sources/mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 8354              		.loc 1 1927 0 discriminator 1
 8355 012a 294B     		ldr	r3, .L646
 8356 012c 9B79     		ldrb	r3, [r3, #6]
 8357 012e DBB2     		uxtb	r3, r3
 8358 0130 1A1C     		mov	r2, r3
 8359 0132 1023     		mov	r3, #16
 8360 0134 1340     		and	r3, r2
1926:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 8361              		.loc 1 1926 0 discriminator 1
 8362 0136 0FD0     		beq	.L643
1928:../Sources/mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 8363              		.loc 1 1928 0
 8364 0138 254B     		ldr	r3, .L646
 8365 013a 9B79     		ldrb	r3, [r3, #6]
 8366 013c DBB2     		uxtb	r3, r3
 8367 013e 1A1C     		mov	r2, r3
 8368 0140 2023     		mov	r3, #32
 8369 0142 1340     		and	r3, r2
1927:../Sources/mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 8370              		.loc 1 1927 0
 8371 0144 08D1     		bne	.L643
1929:../Sources/mcg.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
 8372              		.loc 1 1929 0
 8373 0146 224B     		ldr	r3, .L646
 8374 0148 5B78     		ldrb	r3, [r3, #1]
 8375 014a DBB2     		uxtb	r3, r3
 8376 014c 1A1C     		mov	r2, r3
 8377 014e 0223     		mov	r3, #2
 8378 0150 1340     		and	r3, r2
1928:../Sources/mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 8379              		.loc 1 1928 0
 8380 0152 01D0     		beq	.L643
1930:../Sources/mcg.c ****   {
1931:../Sources/mcg.c ****     return BLPI;                                                         // return BLPI code
 8381              		.loc 1 1931 0
 8382 0154 0123     		mov	r3, #1
 8383 0156 38E0     		b	.L638
 8384              	.L643:
1932:../Sources/mcg.c ****   }
1933:../Sources/mcg.c ****   // check if in FBI mode
1934:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 8385              		.loc 1 1934 0
 8386 0158 1D4B     		ldr	r3, .L646
 8387 015a 9B79     		ldrb	r3, [r3, #6]
 8388 015c DBB2     		uxtb	r3, r3
 8389 015e 1A1C     		mov	r2, r3
 8390 0160 0C23     		mov	r3, #12
 8391 0162 1340     		and	r3, r2
 8392 0164 9B08     		lsr	r3, r3, #2
 8393 0166 012B     		cmp	r3, #1
 8394 0168 16D1     		bne	.L644
1935:../Sources/mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 8395              		.loc 1 1935 0 discriminator 1
 8396 016a 194B     		ldr	r3, .L646
 8397 016c 9B79     		ldrb	r3, [r3, #6]
 8398 016e DBB2     		uxtb	r3, r3
 8399 0170 1A1C     		mov	r2, r3
 8400 0172 1023     		mov	r3, #16
 8401 0174 1340     		and	r3, r2
1934:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 8402              		.loc 1 1934 0 discriminator 1
 8403 0176 0FD0     		beq	.L644
1936:../Sources/mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 8404              		.loc 1 1936 0
 8405 0178 154B     		ldr	r3, .L646
 8406 017a 9B79     		ldrb	r3, [r3, #6]
 8407 017c DBB2     		uxtb	r3, r3
 8408 017e 1A1C     		mov	r2, r3
 8409 0180 2023     		mov	r3, #32
 8410 0182 1340     		and	r3, r2
1935:../Sources/mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 8411              		.loc 1 1935 0
 8412 0184 08D1     		bne	.L644
1937:../Sources/mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
 8413              		.loc 1 1937 0
 8414 0186 124B     		ldr	r3, .L646
 8415 0188 5B78     		ldrb	r3, [r3, #1]
 8416 018a DBB2     		uxtb	r3, r3
 8417 018c 1A1C     		mov	r2, r3
 8418 018e 0223     		mov	r3, #2
 8419 0190 1340     		and	r3, r2
1936:../Sources/mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 8420              		.loc 1 1936 0
 8421 0192 01D1     		bne	.L644
1938:../Sources/mcg.c ****   {  
1939:../Sources/mcg.c ****     return FBI;                                                          // return FBI code 
 8422              		.loc 1 1939 0
 8423 0194 0223     		mov	r3, #2
 8424 0196 18E0     		b	.L638
 8425              	.L644:
1940:../Sources/mcg.c ****   }
1941:../Sources/mcg.c ****   // Check MCG is in FEE mode
1942:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 8426              		.loc 1 1942 0
 8427 0198 0D4B     		ldr	r3, .L646
 8428 019a 9B79     		ldrb	r3, [r3, #6]
 8429 019c DBB2     		uxtb	r3, r3
 8430 019e 1A1C     		mov	r2, r3
 8431 01a0 0C23     		mov	r3, #12
 8432 01a2 1340     		and	r3, r2
 8433 01a4 9B08     		lsr	r3, r3, #2
 8434 01a6 0FD1     		bne	.L645
1943:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8435              		.loc 1 1943 0 discriminator 1
 8436 01a8 094B     		ldr	r3, .L646
 8437 01aa 9B79     		ldrb	r3, [r3, #6]
 8438 01ac DBB2     		uxtb	r3, r3
 8439 01ae 1A1C     		mov	r2, r3
 8440 01b0 1023     		mov	r3, #16
 8441 01b2 1340     		and	r3, r2
1942:../Sources/mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 8442              		.loc 1 1942 0 discriminator 1
 8443 01b4 08D1     		bne	.L645
1944:../Sources/mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has sele
 8444              		.loc 1 1944 0
 8445 01b6 064B     		ldr	r3, .L646
 8446 01b8 9B79     		ldrb	r3, [r3, #6]
 8447 01ba DBB2     		uxtb	r3, r3
 8448 01bc 1A1C     		mov	r2, r3
 8449 01be 2023     		mov	r3, #32
 8450 01c0 1340     		and	r3, r2
1943:../Sources/mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 8451              		.loc 1 1943 0
 8452 01c2 01D1     		bne	.L645
1945:../Sources/mcg.c ****   {
1946:../Sources/mcg.c ****     return FEE;                                                          // return FEE code
 8453              		.loc 1 1946 0
 8454 01c4 0423     		mov	r3, #4
 8455 01c6 00E0     		b	.L638
 8456              	.L645:
1947:../Sources/mcg.c ****   }
1948:../Sources/mcg.c ****   else
1949:../Sources/mcg.c ****   {
1950:../Sources/mcg.c ****     return 0;                                                            // error condition
 8457              		.loc 1 1950 0
 8458 01c8 0023     		mov	r3, #0
 8459              	.L638:
1951:../Sources/mcg.c ****   }
1952:../Sources/mcg.c **** } // what_mcg_mode
 8460              		.loc 1 1952 0
 8461 01ca 181C     		mov	r0, r3
 8462 01cc BD46     		mov	sp, r7
 8463              		@ sp needed for prologue
 8464 01ce 80BD     		pop	{r7, pc}
 8465              	.L647:
 8466              		.align	2
 8467              	.L646:
 8468 01d0 00400640 		.word	1074151424
 8469              		.cfi_endproc
 8470              	.LFE26:
 8472              		.section	.text.clk_monitor_0,"ax",%progbits
 8473              		.align	2
 8474              		.global	clk_monitor_0
 8475              		.code	16
 8476              		.thumb_func
 8478              	clk_monitor_0:
 8479              	.LFB27:
1953:../Sources/mcg.c **** 
1954:../Sources/mcg.c **** 
1955:../Sources/mcg.c **** /********************************************************************/
1956:../Sources/mcg.c **** /* Functon name : clk_monitor_0
1957:../Sources/mcg.c ****  *
1958:../Sources/mcg.c ****  * This function simply enables or disables the OSC 0 clock monitor. This is
1959:../Sources/mcg.c ****  * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to  
1960:../Sources/mcg.c ****  * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
1961:../Sources/mcg.c ****  * It MUST be disabled in all other modes or a reset may be generated. It must
1962:../Sources/mcg.c ****  * also be disabled if it is desired to enter VLPR from BLPE mode.
1963:../Sources/mcg.c ****  *
1964:../Sources/mcg.c ****  * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
1965:../Sources/mcg.c ****  *
1966:../Sources/mcg.c ****  * Return value : none
1967:../Sources/mcg.c ****  */
1968:../Sources/mcg.c **** void clk_monitor_0(unsigned char en_dis)
1969:../Sources/mcg.c **** {         
 8480              		.loc 1 1969 0
 8481              		.cfi_startproc
 8482 0000 80B5     		push	{r7, lr}
 8483              	.LCFI80:
 8484              		.cfi_def_cfa_offset 8
 8485              		.cfi_offset 7, -8
 8486              		.cfi_offset 14, -4
 8487 0002 82B0     		sub	sp, sp, #8
 8488              	.LCFI81:
 8489              		.cfi_def_cfa_offset 16
 8490 0004 00AF     		add	r7, sp, #0
 8491              	.LCFI82:
 8492              		.cfi_def_cfa_register 7
 8493 0006 021C     		mov	r2, r0
 8494 0008 FB1D     		add	r3, r7, #7
 8495 000a 1A70     		strb	r2, [r3]
1970:../Sources/mcg.c ****   if (en_dis)
 8496              		.loc 1 1970 0
 8497 000c FB1D     		add	r3, r7, #7
 8498 000e 1B78     		ldrb	r3, [r3]
 8499 0010 002B     		cmp	r3, #0
 8500 0012 08D0     		beq	.L649
1971:../Sources/mcg.c ****   {
1972:../Sources/mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;   
 8501              		.loc 1 1972 0
 8502 0014 094B     		ldr	r3, .L651
 8503 0016 094A     		ldr	r2, .L651
 8504 0018 5279     		ldrb	r2, [r2, #5]
 8505 001a D2B2     		uxtb	r2, r2
 8506 001c 2021     		mov	r1, #32
 8507 001e 0A43     		orr	r2, r1
 8508 0020 D2B2     		uxtb	r2, r2
 8509 0022 5A71     		strb	r2, [r3, #5]
 8510 0024 07E0     		b	.L648
 8511              	.L649:
1973:../Sources/mcg.c ****   }
1974:../Sources/mcg.c ****   else
1975:../Sources/mcg.c ****   {
1976:../Sources/mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 8512              		.loc 1 1976 0
 8513 0026 054B     		ldr	r3, .L651
 8514 0028 044A     		ldr	r2, .L651
 8515 002a 5279     		ldrb	r2, [r2, #5]
 8516 002c D2B2     		uxtb	r2, r2
 8517 002e 2021     		mov	r1, #32
 8518 0030 8A43     		bic	r2, r1
 8519 0032 D2B2     		uxtb	r2, r2
 8520 0034 5A71     		strb	r2, [r3, #5]
 8521              	.L648:
1977:../Sources/mcg.c ****   }
1978:../Sources/mcg.c **** }    // end clk_monitor_0
 8522              		.loc 1 1978 0
 8523 0036 BD46     		mov	sp, r7
 8524 0038 02B0     		add	sp, sp, #8
 8525              		@ sp needed for prologue
 8526 003a 80BD     		pop	{r7, pc}
 8527              	.L652:
 8528              		.align	2
 8529              	.L651:
 8530 003c 00400640 		.word	1074151424
 8531              		.cfi_endproc
 8532              	.LFE27:
 8534              		.section	.text.chk_for_resistor,"ax",%progbits
 8535              		.align	2
 8536              		.global	chk_for_resistor
 8537              		.code	16
 8538              		.thumb_func
 8540              	chk_for_resistor:
 8541              	.LFB28:
1979:../Sources/mcg.c **** 
1980:../Sources/mcg.c **** 
1981:../Sources/mcg.c **** /********************************************************************/
1982:../Sources/mcg.c **** /* Functon name : chk_for_resistor
1983:../Sources/mcg.c ****  *
1984:../Sources/mcg.c ****  * This function is specifically for the Freescale Tower and Freedom boards.
1985:../Sources/mcg.c ****  * It performs a simple check to determine if there is an 1M ohm external 
1986:../Sources/mcg.c ****  * feedback resistor connected between extal and xtal. It returns a 1 if the
1987:../Sources/mcg.c ****  * resistor is detected or a 0 if the resistor is not detected. This can be used
1988:../Sources/mcg.c ****  * by the calling routine to compare the test result with the value for HGO that
1989:../Sources/mcg.c ****  * is being used to configure the oscillator. This helps ensure the correct
1990:../Sources/mcg.c ****  * configuration is used.
1991:../Sources/mcg.c ****  *
1992:../Sources/mcg.c ****  * This check is used just to test for the presence of a 1M resistor, it MUST
1993:../Sources/mcg.c ****  * NOT be used in user code to automatically configure the oscillator HGO value.
1994:../Sources/mcg.c ****  *
1995:../Sources/mcg.c ****  * It simply configures the crystal pins as GPIO outputs, sets them both low,
1996:../Sources/mcg.c ****  * configures one as high and then configures the other as an input (no pull
1997:../Sources/mcg.c ****  * up). If the resistor is present then the input will be pulled high. This
1998:../Sources/mcg.c ****  * process is repeated for the pin functions reversed. Both conditions have 
1999:../Sources/mcg.c ****  * to result in the input being pulled high for the resistor to be identifiedas
2000:../Sources/mcg.c ****  * being present.
2001:../Sources/mcg.c ****  */
2002:../Sources/mcg.c **** unsigned char chk_for_resistor(void)
2003:../Sources/mcg.c **** {
 8542              		.loc 1 2003 0
 8543              		.cfi_startproc
 8544 0000 80B5     		push	{r7, lr}
 8545              	.LCFI83:
 8546              		.cfi_def_cfa_offset 8
 8547              		.cfi_offset 7, -8
 8548              		.cfi_offset 14, -4
 8549 0002 82B0     		sub	sp, sp, #8
 8550              	.LCFI84:
 8551              		.cfi_def_cfa_offset 16
 8552 0004 00AF     		add	r7, sp, #0
 8553              	.LCFI85:
 8554              		.cfi_def_cfa_register 7
2004:../Sources/mcg.c ****   unsigned char extal_high = 0;
 8555              		.loc 1 2004 0
 8556 0006 FB1D     		add	r3, r7, #7
 8557 0008 0022     		mov	r2, #0
 8558 000a 1A70     		strb	r2, [r3]
2005:../Sources/mcg.c ****   unsigned char xtal_high = 0;
 8559              		.loc 1 2005 0
 8560 000c BB1D     		add	r3, r7, #6
 8561 000e 0022     		mov	r2, #0
 8562 0010 1A70     		strb	r2, [r3]
2006:../Sources/mcg.c ****   short i;
2007:../Sources/mcg.c ****   
2008:../Sources/mcg.c ****   // Configure EXTAL (PTA18) and XTAL PTA(19) as GPIO driving Low, no pull enabled
2009:../Sources/mcg.c ****   FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 output data
 8563              		.loc 1 2009 0
 8564 0012 404B     		ldr	r3, .L662
 8565 0014 C022     		mov	r2, #192
 8566 0016 1203     		lsl	r2, r2, #12
 8567 0018 9A60     		str	r2, [r3, #8]
2010:../Sources/mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 8568              		.loc 1 2010 0
 8569 001a 3E4B     		ldr	r3, .L662
 8570 001c 3D4A     		ldr	r2, .L662
 8571 001e 5269     		ldr	r2, [r2, #20]
 8572 0020 C021     		mov	r1, #192
 8573 0022 0903     		lsl	r1, r1, #12
 8574 0024 0A43     		orr	r2, r1
 8575 0026 5A61     		str	r2, [r3, #20]
2011:../Sources/mcg.c ****   PORTA_GPCHR = (0xC0000 | PORT_PCR_MUX(1)); // configure the pin muxes for GPIO
 8576              		.loc 1 2011 0
 8577 0028 3B4A     		ldr	r2, .L662+4
 8578 002a 8423     		mov	r3, #132
 8579 002c 3B49     		ldr	r1, .L662+8
 8580 002e D150     		str	r1, [r2, r3]
2012:../Sources/mcg.c ****   // Drive EXTAL high
2013:../Sources/mcg.c ****   FGPIOA_PSOR = 0x40000; // set PTA18 data out high
 8581              		.loc 1 2013 0
 8582 0030 384B     		ldr	r3, .L662
 8583 0032 8022     		mov	r2, #128
 8584 0034 D202     		lsl	r2, r2, #11
 8585 0036 5A60     		str	r2, [r3, #4]
2014:../Sources/mcg.c ****   // Configure XTAL as an Input, no pull up 
2015:../Sources/mcg.c ****   FGPIOA_PDDR &= ~(0x80000); // clear PTA19 data direction to make it an input 
 8586              		.loc 1 2015 0
 8587 0038 364B     		ldr	r3, .L662
 8588 003a 364A     		ldr	r2, .L662
 8589 003c 5269     		ldr	r2, [r2, #20]
 8590 003e 111C     		mov	r1, r2
 8591 0040 374A     		ldr	r2, .L662+12
 8592 0042 0A40     		and	r2, r1
 8593 0044 5A61     		str	r2, [r3, #20]
2016:../Sources/mcg.c ****   // Wait for ~2 time constants
2017:../Sources/mcg.c ****   for (i = 0 ; i < 300 ; i++) {} 
 8594              		.loc 1 2017 0
 8595 0046 3B1D     		add	r3, r7, #4
 8596 0048 0022     		mov	r2, #0
 8597 004a 1A80     		strh	r2, [r3]
 8598 004c 04E0     		b	.L654
 8599              	.L655:
 8600              		.loc 1 2017 0 is_stmt 0 discriminator 2
 8601 004e 3B1D     		add	r3, r7, #4
 8602 0050 3A1D     		add	r2, r7, #4
 8603 0052 1288     		ldrh	r2, [r2]
 8604 0054 0132     		add	r2, r2, #1
 8605 0056 1A80     		strh	r2, [r3]
 8606              	.L654:
 8607              		.loc 1 2017 0 discriminator 1
 8608 0058 3B1D     		add	r3, r7, #4
 8609 005a 0021     		mov	r1, #0
 8610 005c 5A5E     		ldrsh	r2, [r3, r1]
 8611 005e 314B     		ldr	r3, .L662+16
 8612 0060 9A42     		cmp	r2, r3
 8613 0062 F4DD     		ble	.L655
2018:../Sources/mcg.c ****   // Check if XTAL was pulled high
2019:../Sources/mcg.c ****   if (FGPIOA_PDIR & 0x80000)
 8614              		.loc 1 2019 0 is_stmt 1
 8615 0064 2B4B     		ldr	r3, .L662
 8616 0066 1B69     		ldr	r3, [r3, #16]
 8617 0068 1A1C     		mov	r2, r3
 8618 006a 8023     		mov	r3, #128
 8619 006c 1B03     		lsl	r3, r3, #12
 8620 006e 1340     		and	r3, r2
 8621 0070 02D0     		beq	.L656
2020:../Sources/mcg.c ****   {
2021:../Sources/mcg.c ****     xtal_high = 1;
 8622              		.loc 1 2021 0
 8623 0072 BB1D     		add	r3, r7, #6
 8624 0074 0122     		mov	r2, #1
 8625 0076 1A70     		strb	r2, [r3]
 8626              	.L656:
2022:../Sources/mcg.c ****   }
2023:../Sources/mcg.c ****   // Configure EXTAL and XTAL as GPIO driving low
2024:../Sources/mcg.c ****   FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 data output
 8627              		.loc 1 2024 0
 8628 0078 264B     		ldr	r3, .L662
 8629 007a C022     		mov	r2, #192
 8630 007c 1203     		lsl	r2, r2, #12
 8631 007e 9A60     		str	r2, [r3, #8]
2025:../Sources/mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 8632              		.loc 1 2025 0
 8633 0080 244B     		ldr	r3, .L662
 8634 0082 244A     		ldr	r2, .L662
 8635 0084 5269     		ldr	r2, [r2, #20]
 8636 0086 C021     		mov	r1, #192
 8637 0088 0903     		lsl	r1, r1, #12
 8638 008a 0A43     		orr	r2, r1
 8639 008c 5A61     		str	r2, [r3, #20]
2026:../Sources/mcg.c ****   // Drive XTAL high
2027:../Sources/mcg.c ****   FGPIOA_PSOR = 0x80000; // set PTA19 data out high
 8640              		.loc 1 2027 0
 8641 008e 214B     		ldr	r3, .L662
 8642 0090 8022     		mov	r2, #128
 8643 0092 1203     		lsl	r2, r2, #12
 8644 0094 5A60     		str	r2, [r3, #4]
2028:../Sources/mcg.c ****   // Configure EXTAL as Input, no pull up
2029:../Sources/mcg.c ****   FGPIOA_PDDR &= ~(0x40000); // clear PTA18 data direction to make it an input
 8645              		.loc 1 2029 0
 8646 0096 1F4B     		ldr	r3, .L662
 8647 0098 1E4A     		ldr	r2, .L662
 8648 009a 5269     		ldr	r2, [r2, #20]
 8649 009c 111C     		mov	r1, r2
 8650 009e 224A     		ldr	r2, .L662+20
 8651 00a0 0A40     		and	r2, r1
 8652 00a2 5A61     		str	r2, [r3, #20]
2030:../Sources/mcg.c ****   // Wait for ~2 time constants
2031:../Sources/mcg.c ****   for (i = 0 ; i < 300 ; i++) {} 
 8653              		.loc 1 2031 0
 8654 00a4 3B1D     		add	r3, r7, #4
 8655 00a6 0022     		mov	r2, #0
 8656 00a8 1A80     		strh	r2, [r3]
 8657 00aa 04E0     		b	.L657
 8658              	.L658:
 8659              		.loc 1 2031 0 is_stmt 0 discriminator 2
 8660 00ac 3B1D     		add	r3, r7, #4
 8661 00ae 3A1D     		add	r2, r7, #4
 8662 00b0 1288     		ldrh	r2, [r2]
 8663 00b2 0132     		add	r2, r2, #1
 8664 00b4 1A80     		strh	r2, [r3]
 8665              	.L657:
 8666              		.loc 1 2031 0 discriminator 1
 8667 00b6 3B1D     		add	r3, r7, #4
 8668 00b8 0021     		mov	r1, #0
 8669 00ba 5A5E     		ldrsh	r2, [r3, r1]
 8670 00bc 194B     		ldr	r3, .L662+16
 8671 00be 9A42     		cmp	r2, r3
 8672 00c0 F4DD     		ble	.L658
2032:../Sources/mcg.c ****   // Check if EXTAL was pulled high
2033:../Sources/mcg.c ****   if (FGPIOA_PDIR & 0x40000)
 8673              		.loc 1 2033 0 is_stmt 1
 8674 00c2 144B     		ldr	r3, .L662
 8675 00c4 1B69     		ldr	r3, [r3, #16]
 8676 00c6 1A1C     		mov	r2, r3
 8677 00c8 8023     		mov	r3, #128
 8678 00ca DB02     		lsl	r3, r3, #11
 8679 00cc 1340     		and	r3, r2
 8680 00ce 02D0     		beq	.L659
2034:../Sources/mcg.c ****   {
2035:../Sources/mcg.c ****     extal_high = 1;
 8681              		.loc 1 2035 0
 8682 00d0 FB1D     		add	r3, r7, #7
 8683 00d2 0122     		mov	r2, #1
 8684 00d4 1A70     		strb	r2, [r3]
 8685              	.L659:
2036:../Sources/mcg.c ****   }
2037:../Sources/mcg.c **** 
2038:../Sources/mcg.c ****   // Now configure both pins back to their default state
2039:../Sources/mcg.c ****   PORTA_GPCHR = 0x000C0000; // clear pta18 and 19 mux values to default
 8686              		.loc 1 2039 0
 8687 00d6 104A     		ldr	r2, .L662+4
 8688 00d8 8423     		mov	r3, #132
 8689 00da C021     		mov	r1, #192
 8690 00dc 0903     		lsl	r1, r1, #12
 8691 00de D150     		str	r1, [r2, r3]
2040:../Sources/mcg.c ****   FGPIOA_PDDR &= ~(0xC0000);    // set PTA18 and 19 as inputs
 8692              		.loc 1 2040 0
 8693 00e0 0C4B     		ldr	r3, .L662
 8694 00e2 0C4A     		ldr	r2, .L662
 8695 00e4 5269     		ldr	r2, [r2, #20]
 8696 00e6 111C     		mov	r1, r2
 8697 00e8 104A     		ldr	r2, .L662+24
 8698 00ea 0A40     		and	r2, r1
 8699 00ec 5A61     		str	r2, [r3, #20]
2041:../Sources/mcg.c ****   FGPIOA_PCOR = 0xC0000;        // clear PTA18 and 19 output data
 8700              		.loc 1 2041 0
 8701 00ee 094B     		ldr	r3, .L662
 8702 00f0 C022     		mov	r2, #192
 8703 00f2 1203     		lsl	r2, r2, #12
 8704 00f4 9A60     		str	r2, [r3, #8]
2042:../Sources/mcg.c **** 
2043:../Sources/mcg.c ****   // If both rising and falling are true return 1, else return 0
2044:../Sources/mcg.c ****   if (extal_high && xtal_high)
 8705              		.loc 1 2044 0
 8706 00f6 FB1D     		add	r3, r7, #7
 8707 00f8 1B78     		ldrb	r3, [r3]
 8708 00fa 002B     		cmp	r3, #0
 8709 00fc 05D0     		beq	.L660
 8710              		.loc 1 2044 0 is_stmt 0 discriminator 1
 8711 00fe BB1D     		add	r3, r7, #6
 8712 0100 1B78     		ldrb	r3, [r3]
 8713 0102 002B     		cmp	r3, #0
 8714 0104 01D0     		beq	.L660
2045:../Sources/mcg.c ****   {
2046:../Sources/mcg.c ****     return 1;
 8715              		.loc 1 2046 0 is_stmt 1
 8716 0106 0123     		mov	r3, #1
 8717 0108 00E0     		b	.L661
 8718              	.L660:
2047:../Sources/mcg.c ****   }
2048:../Sources/mcg.c ****   else
2049:../Sources/mcg.c ****   {
2050:../Sources/mcg.c ****     return 0;
 8719              		.loc 1 2050 0
 8720 010a 0023     		mov	r3, #0
 8721              	.L661:
2051:../Sources/mcg.c ****   }       
2052:../Sources/mcg.c **** } // chk_for_resistor
 8722              		.loc 1 2052 0
 8723 010c 181C     		mov	r0, r3
 8724 010e BD46     		mov	sp, r7
 8725 0110 02B0     		add	sp, sp, #8
 8726              		@ sp needed for prologue
 8727 0112 80BD     		pop	{r7, pc}
 8728              	.L663:
 8729              		.align	2
 8730              	.L662:
 8731 0114 00F00FF8 		.word	-133173248
 8732 0118 00900440 		.word	1074040832
 8733 011c 00010C00 		.word	786688
 8734 0120 FFFFF7FF 		.word	-524289
 8735 0124 2B010000 		.word	299
 8736 0128 FFFFFBFF 		.word	-262145
 8737 012c FFFFF3FF 		.word	-786433
 8738              		.cfi_endproc
 8739              	.LFE28:
 8741              		.text
 8742              	.Letext0:
 8743              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 8744              		.file 3 "D:/Freescale Demos/struct/Interrupts/Interrupts - Timer/TPM_IRQ/Project_Headers/MKL25Z4.h
DEFINED SYMBOLS
                            *ABS*:00000000 mcg.c
                            *COM*:00000001 drs_val
                            *COM*:00000001 dmx32_val
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:21     .text.pll_init:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:26     .text.pll_init:00000000 pll_init
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:551    .text.pll_init:00000324 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:569    .text.pll_init:00000364 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:860    .text.pll_init:0000053c $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:867    .text.new_pll_freq:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:872    .text.new_pll_freq:00000000 new_pll_freq
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1357   .text.new_pll_freq:000002f0 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1368   .text.pee_pbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1373   .text.pee_pbe:00000000 pee_pbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1498   .text.pee_pbe:000000a8 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1504   .text.pbe_pee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1509   .text.pbe_pee:00000000 pbe_pee
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1724   .text.pbe_pee:0000013c $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1730   .text.pbe_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1735   .text.pbe_fbe:00000000 pbe_fbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1864   .text.pbe_fbe:000000ac $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1870   .text.fbe_pbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:1875   .text.fbe_pbe:00000000 fbe_pbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2215   .text.fbe_pbe:00000208 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2225   .text.pbe_blpe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2230   .text.pbe_blpe:00000000 pbe_blpe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2309   .text.pbe_blpe:00000064 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2314   .text.blpe_pbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2319   .text.blpe_pbe:00000000 blpe_pbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2631   .text.blpe_pbe:000001dc $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2639   .text.blpe_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2644   .text.blpe_fbe:00000000 blpe_fbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2773   .text.blpe_fbe:000000b0 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2779   .text.fbe_blpe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2784   .text.fbe_blpe:00000000 fbe_blpe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2863   .text.fbe_blpe:00000064 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2868   .text.fbe_fei:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:2873   .text.fbe_fei:00000000 fbe_fei
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7818   .text.fll_freq:00000000 fll_freq
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3113   .text.fbe_fei:00000158 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3121   .text.fei_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3126   .text.fei_fbe:00000000 fei_fbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3611   .text.fei_fbe:000002e4 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3629   .text.fbe_fee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3634   .text.fbe_fee:00000000 fbe_fee
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3834   .text.fbe_fee:00000130 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3840   .text.fee_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3845   .text.fee_fbe:00000000 fee_fbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3969   .text.fee_fbe:000000a8 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3975   .text.fbe_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:3980   .text.fbe_fbi:00000000 fbe_fbi
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:4394   .text.fbe_fbi:00000268 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:4404   .text.fbi_fbe:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:4409   .text.fbi_fbe:00000000 fbi_fbe
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:4904   .text.fbi_fbe:000002f4 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:4922   .text.fbi_blpi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:4927   .text.fbi_blpi:00000000 fbi_blpi
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5037   .text.fbi_blpi:0000009c $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5042   .text.blpi_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5047   .text.blpi_fbi:00000000 blpi_fbi
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5157   .text.blpi_fbi:0000009c $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5162   .text.fbi_fee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5167   .text.fbi_fee:00000000 fbi_fee
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5673   .text.fbi_fee:00000314 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5689   .text.fbi_fee:0000034c $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5725   .text.fbi_fee:0000037c $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5730   .text.fee_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:5735   .text.fee_fbi:00000000 fee_fbi
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6118   .text.fee_fbi:00000234 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6128   .text.fbi_fei:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6133   .text.fbi_fei:00000000 fbi_fei
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6371   .text.fbi_fei:00000154 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6379   .text.fei_fbi:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6384   .text.fei_fbi:00000000 fei_fbi
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6729   .text.fei_fbi:00000200 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6739   .text.fei_fee:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:6744   .text.fei_fee:00000000 fei_fee
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7205   .text.fei_fee:000002c4 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7223   .text.fee_fei:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7228   .text.fee_fei:00000000 fee_fei
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7385   .text.fee_fei:000000d8 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7398   .text.atc:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7403   .text.atc:00000000 atc
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8155   .text.what_mcg_mode:00000000 what_mcg_mode
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7797   .text.atc:0000027c $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:7813   .text.fll_freq:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8135   .text.fll_freq:000001ac $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8150   .text.what_mcg_mode:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8468   .text.what_mcg_mode:000001d0 $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8473   .text.clk_monitor_0:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8478   .text.clk_monitor_0:00000000 clk_monitor_0
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8530   .text.clk_monitor_0:0000003c $d
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8535   .text.chk_for_resistor:00000000 $t
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8540   .text.chk_for_resistor:00000000 chk_for_resistor
C:\Users\ehughes\AppData\Local\Temp\cctDrPga.s:8731   .text.chk_for_resistor:00000114 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_idiv
__aeabi_uidiv
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2uiz
